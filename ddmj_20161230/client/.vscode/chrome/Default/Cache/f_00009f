require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"Alert":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'c12553sxCxG/on0Bz7rkX0f', 'Alert');
// scripts/components/Alert.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _alert: null,
        _btnOK: null,
        _btnCancel: null,
        _title: null,
        _content: null,
        _onok: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }
        this._alert = cc.find("Canvas/alert");
        this._title = cc.find("Canvas/alert/title").getComponent(cc.Label);
        this._content = cc.find("Canvas/alert/content").getComponent(cc.Label);

        this._btnOK = cc.find("Canvas/alert/btn_ok");
        this._btnCancel = cc.find("Canvas/alert/btn_cancel");

        cc.vv.utils.addClickEvent(this._btnOK, this.node, "Alert", "onBtnClicked");
        cc.vv.utils.addClickEvent(this._btnCancel, this.node, "Alert", "onBtnClicked");

        this._alert.active = false;
        cc.vv.alert = this;
    },

    onBtnClicked: function onBtnClicked(event) {
        if (event.target.name == "btn_ok") {
            if (this._onok) {
                this._onok();
            }
        }
        this._alert.active = false;
        this._onok = null;
    },

    show: function show(title, content, onok, needcancel) {
        this._alert.active = true;
        this._onok = onok;
        this._title.string = title;
        this._content.string = content;
        if (needcancel) {
            this._btnCancel.active = true;
            this._btnOK.x = -150;
            this._btnCancel.x = 150;
        } else {
            this._btnCancel.active = false;
            this._btnOK.x = 0;
        }
    },

    onDestory: function onDestory() {
        if (cc.vv) {
            cc.vv.alert = null;
        }
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"AnysdkMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'f58cea6lrpDZJSNs2BGBqxN', 'AnysdkMgr');
// scripts/AnysdkMgr.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _isCapturing: false
    },

    // use this for initialization
    onLoad: function onLoad() {},

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    init: function init() {
        this.ANDROID_API = "com/vivigames/scmj/WXAPI";
        this.IOS_API = "AppController";
    },

    login: function login() {
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            jsb.reflection.callStaticMethod(this.ANDROID_API, "Login", "()V");
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod(this.IOS_API, "login");
        } else {
            console.log("platform:" + cc.sys.os + " dosn't implement share.");
        }
    },

    share: function share(title, desc) {
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            jsb.reflection.callStaticMethod(this.ANDROID_API, "Share", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V", cc.vv.SI.appweb, title, desc);
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod(this.IOS_API, "share:shareTitle:shareDesc:", cc.vv.SI.appweb, title, desc);
        } else {
            console.log("platform:" + cc.sys.os + " dosn't implement share.");
        }
    },

    shareResult: function shareResult() {
        if (this._isCapturing) {
            return;
        }
        this._isCapturing = true;
        var size = cc.director.getWinSize();
        var currentDate = new Date();
        var fileName = "result_share.jpg";
        var fullPath = jsb.fileUtils.getWritablePath() + fileName;
        if (jsb.fileUtils.isFileExist(fullPath)) {
            jsb.fileUtils.removeFile(fullPath);
        }
        var texture = new cc.RenderTexture(Math.floor(size.width), Math.floor(size.height));
        texture.setPosition(cc.p(size.width / 2, size.height / 2));
        texture.begin();
        cc.director.getRunningScene().visit();
        texture.end();
        texture.saveToFile(fileName, cc.IMAGE_FORMAT_JPG);

        var self = this;
        var tryTimes = 0;
        var fn = function fn() {
            if (jsb.fileUtils.isFileExist(fullPath)) {
                var height = 100;
                var scale = height / size.height;
                var width = Math.floor(size.width * scale);

                if (cc.sys.os == cc.sys.OS_ANDROID) {
                    jsb.reflection.callStaticMethod(self.ANDROID_API, "ShareIMG", "(Ljava/lang/String;II)V", fullPath, width, height);
                } else if (cc.sys.os == cc.sys.OS_IOS) {
                    jsb.reflection.callStaticMethod(self.IOS_API, "shareIMG:width:height:", fullPath, width, height);
                } else {
                    console.log("platform:" + cc.sys.os + " dosn't implement share.");
                }
                self._isCapturing = false;
            } else {
                tryTimes++;
                if (tryTimes > 10) {
                    console.log("time out...");
                    return;
                }
                setTimeout(fn, 50);
            }
        };
        setTimeout(fn, 50);
    },

    onLoginResp: function onLoginResp(code) {
        var fn = function fn(ret) {
            if (ret.errcode == 0) {
                cc.sys.localStorage.setItem("wx_account", ret.account);
                cc.sys.localStorage.setItem("wx_sign", ret.sign);
            }
            cc.vv.userMgr.onAuth(ret);
        };
        cc.vv.http.sendRequest("/wechat_auth", { code: code, os: cc.sys.os }, fn);
    }
});

cc._RF.pop();
},{}],"AudioMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, '55caepcpvFK5r0Ax5f8jss4', 'AudioMgr');
// scripts/AudioMgr.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        bgmVolume: 1.0,
        sfxVolume: 1.0,

        bgmAudioID: -1
    },

    // use this for initialization
    init: function init() {
        var t = cc.sys.localStorage.getItem("bgmVolume");
        if (t != null) {
            this.bgmVolume = parseFloat(t);
        }

        var t = cc.sys.localStorage.getItem("sfxVolume");
        if (t != null) {
            this.sfxVolume = parseFloat(t);
        }

        cc.game.on(cc.game.EVENT_HIDE, function () {
            console.log("cc.audioEngine.pauseAll");
            cc.audioEngine.pauseAll();
        });
        cc.game.on(cc.game.EVENT_SHOW, function () {
            console.log("cc.audioEngine.resumeAll");
            cc.audioEngine.resumeAll();
        });
    },

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    getUrl: function getUrl(url) {
        return cc.url.raw("resources/sounds/" + url);
    },

    playBGM: function playBGM(url) {
        var audioUrl = this.getUrl(url);
        console.log(audioUrl);
        if (this.bgmAudioID >= 0) {
            cc.audioEngine.stop(this.bgmAudioID);
        }
        this.bgmAudioID = cc.audioEngine.play(audioUrl, true, this.bgmVolume);
    },
    playSFX: function playSFX(url) {
        var audioUrl = this.getUrl(url);
        if (this.sfxVolume > 0) {
            var audioId = cc.audioEngine.play(audioUrl, false, this.sfxVolume);
        }
    },


    setSFXVolume: function setSFXVolume(v) {
        if (this.sfxVolume != v) {
            cc.sys.localStorage.setItem("sfxVolume", v);
            this.sfxVolume = v;
        }
    },

    setBGMVolume: function setBGMVolume(v, force) {
        if (this.bgmAudioID >= 0) {
            if (v > 0) {
                cc.audioEngine.resume(this.bgmAudioID);
            } else {
                cc.audioEngine.pause(this.bgmAudioID);
            }
            //cc.audioEngine.setVolume(this.bgmAudioID,this.bgmVolume);
        }
        if (this.bgmVolume != v || force) {
            cc.sys.localStorage.setItem("bgmVolume", v);
            this.bgmVolume = v;
            cc.audioEngine.setVolume(this.bgmAudioID, v);
        }
    },

    pauseAll: function pauseAll() {
        cc.audioEngine.pauseAll();
    },

    resumeAll: function resumeAll() {
        cc.audioEngine.resumeAll();
    }
});

cc._RF.pop();
},{}],"Chat":[function(require,module,exports){
"use strict";
cc._RF.push(module, '58f27rxustNsYlRX3fryN8X', 'Chat');
// scripts/components/Chat.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _chatRoot: null,
        _tabQuick: null,
        _tabEmoji: null,
        _iptChat: null,

        _quickChatInfo: null,
        _btnChat: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }

        cc.vv.chat = this;

        this._btnChat = this.node.getChildByName("btn_chat");
        this._btnChat.active = cc.vv.replayMgr.isReplay() == false;

        this._chatRoot = this.node.getChildByName("chat");
        this._chatRoot.active = false;

        this._tabQuick = this._chatRoot.getChildByName("quickchatlist");
        this._tabEmoji = this._chatRoot.getChildByName("emojis");

        this._iptChat = this._chatRoot.getChildByName("iptChat").getComponent(cc.EditBox);

        this._quickChatInfo = {};
        this._quickChatInfo["item0"] = { index: 0, content: "快点啊，都等到我花儿都谢谢了！", sound: "fix_msg_1.mp3" };
        this._quickChatInfo["item1"] = { index: 1, content: "怎么又断线了，网络怎么这么差啊！", sound: "fix_msg_2.mp3" };
        this._quickChatInfo["item2"] = { index: 2, content: "不要走，决战到天亮！", sound: "fix_msg_3.mp3" };
        this._quickChatInfo["item3"] = { index: 3, content: "你的牌打得也太好了！", sound: "fix_msg_4.mp3" };
        this._quickChatInfo["item4"] = { index: 4, content: "你是妹妹还是哥哥啊？", sound: "fix_msg_5.mp3" };
        this._quickChatInfo["item5"] = { index: 5, content: "和你合作真是太愉快了！", sound: "fix_msg_6.mp3" };
        this._quickChatInfo["item6"] = { index: 6, content: "大家好，很高兴见到各位！", sound: "fix_msg_7.mp3" };
        this._quickChatInfo["item7"] = { index: 7, content: "各位，真是不好意思，我得离开一会儿。", sound: "fix_msg_8.mp3" };
        this._quickChatInfo["item8"] = { index: 8, content: "不要吵了，专心玩游戏吧！", sound: "fix_msg_9.mp3" };
    },

    getQuickChatInfo: function getQuickChatInfo(index) {
        var key = "item" + index;
        return this._quickChatInfo[key];
    },


    onBtnChatClicked: function onBtnChatClicked() {
        this._chatRoot.active = true;
    },

    onBgClicked: function onBgClicked() {
        this._chatRoot.active = false;
    },

    onTabClicked: function onTabClicked(event) {
        if (event.target.name == "tabQuick") {
            this._tabQuick.active = true;
            this._tabEmoji.active = false;
        } else if (event.target.name == "tabEmoji") {
            this._tabQuick.active = false;
            this._tabEmoji.active = true;
        }
    },

    onQuickChatItemClicked: function onQuickChatItemClicked(event) {
        this._chatRoot.active = false;
        var info = this._quickChatInfo[event.target.name];
        cc.vv.net.send("quick_chat", info.index);
    },

    onEmojiItemClicked: function onEmojiItemClicked(event) {
        console.log(event.target.name);
        this._chatRoot.active = false;
        cc.vv.net.send("emoji", event.target.name);
    },

    onBtnSendChatClicked: function onBtnSendChatClicked() {
        this._chatRoot.active = false;
        if (this._iptChat.string == "") {
            return;
        }
        cc.vv.net.send("chat", this._iptChat.string);
        this._iptChat.string = "";
    }

});

cc._RF.pop();
},{}],"CheckBox":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'dc9e5hcegFBFpbh0CwUFw8V', 'CheckBox');
// scripts/components/CheckBox.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        target: cc.Node,
        sprite: cc.SpriteFrame,
        checkedSprite: cc.SpriteFrame,
        checked: false
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.refresh();
    },

    onClicked: function onClicked() {
        this.checked = !this.checked;
        this.refresh();
    },

    refresh: function refresh() {
        var targetSprite = this.target.getComponent(cc.Sprite);
        if (this.checked) {
            targetSprite.spriteFrame = this.checkedSprite;
        } else {
            targetSprite.spriteFrame = this.sprite;
        }
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"CreateRole":[function(require,module,exports){
"use strict";
cc._RF.push(module, '5d56bFYy/REb77pQCq9YHh6', 'CreateRole');
// scripts/components/CreateRole.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        inputName: cc.EditBox
    },

    onRandomBtnClicked: function onRandomBtnClicked() {
        var names = ["上官", "欧阳", "东方", "端木", "独孤", "司马", "南宫", "夏侯", "诸葛", "皇甫", "长孙", "宇文", "轩辕", "东郭", "子车", "东阳", "子言"];

        var names2 = ["雀圣", "赌侠", "赌圣", "稳赢", "不输", "好运", "自摸", "有钱", "土豪"];
        var idx = Math.floor(Math.random() * (names.length - 1));
        var idx2 = Math.floor(Math.random() * (names2.length - 1));
        this.inputName.string = names[idx] + names2[idx2];
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (!cc.sys.isNative && cc.sys.isMobile) {
            var cvs = this.node.getComponent(cc.Canvas);
            cvs.fitHeight = true;
            cvs.fitWidth = true;
        }
        this.onRandomBtnClicked();
    },

    onBtnConfirmClicked: function onBtnConfirmClicked() {
        var name = this.inputName.string;
        if (name == "") {
            console.log("invalid name.");
            return;
        }
        console.log(name);
        cc.vv.userMgr.create(name);
    }
    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"CreateRoom":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'eec07HsL4pBn5/PiT3SYBew', 'CreateRoom');
// scripts/components/CreateRoom.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _difenxuanze: null,
        _zimo: null,
        _wanfaxuanze: null,
        _zuidafanshu: null,
        _jushuxuanze: null,
        _dianganghua: null,
        _leixingxuanze: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        this._leixingxuanze = [];
        var t = this.node.getChildByName("leixingxuanze");
        for (var i = 0; i < t.childrenCount; ++i) {
            var n = t.children[i].getComponent("RadioButton");
            if (n != null) {
                this._leixingxuanze.push(n);
            }
        }

        this._difenxuanze = [];
        var t = this.node.getChildByName("difenxuanze");
        for (var i = 0; i < t.childrenCount; ++i) {
            var n = t.children[i].getComponent("RadioButton");
            if (n != null) {
                this._difenxuanze.push(n);
            }
        }
        //console.log(this._difenxuanze);

        this._zimo = [];
        var t = this.node.getChildByName("zimojiacheng");
        for (var i = 0; i < t.childrenCount; ++i) {
            var n = t.children[i].getComponent("RadioButton");
            if (n != null) {
                this._zimo.push(n);
            }
        }
        //console.log(this._zimo);

        this._wanfaxuanze = [];
        var t = this.node.getChildByName("wanfaxuanze");
        for (var i = 0; i < t.childrenCount; ++i) {
            var n = t.children[i].getComponent("CheckBox");
            if (n != null) {
                this._wanfaxuanze.push(n);
            }
        }
        //console.log(this._wanfaxuanze);

        this._zuidafanshu = [];
        var t = this.node.getChildByName("zuidafanshu");
        for (var i = 0; i < t.childrenCount; ++i) {
            var n = t.children[i].getComponent("RadioButton");
            if (n != null) {
                this._zuidafanshu.push(n);
            }
        }
        //console.log(this._zuidafanshu);

        this._jushuxuanze = [];
        var t = this.node.getChildByName("xuanzejushu");
        for (var i = 0; i < t.childrenCount; ++i) {
            var n = t.children[i].getComponent("RadioButton");
            if (n != null) {
                this._jushuxuanze.push(n);
            }
        }

        this._dianganghua = [];
        var t = this.node.getChildByName("dianganghua");
        for (var i = 0; i < t.childrenCount; ++i) {
            var n = t.children[i].getComponent("RadioButton");
            if (n != null) {
                this._dianganghua.push(n);
            }
        }
        //console.log(this._jushuxuanze);
    },

    onBtnBack: function onBtnBack() {
        this.node.active = false;
    },

    onBtnOK: function onBtnOK() {
        this.node.active = false;
        this.createRoom();
    },

    createRoom: function createRoom() {
        var self = this;
        var onCreate = function onCreate(ret) {
            if (ret.errcode !== 0) {
                cc.vv.wc.hide();
                //console.log(ret.errmsg);
                if (ret.errcode == 2222) {
                    cc.vv.alert.show("提示", "房卡不足，创建房间失败!");
                } else {
                    cc.vv.alert.show("提示", "创建房间失败,错误码:" + ret.errcode);
                }
            } else {
                cc.vv.gameNetMgr.connectGameServer(ret);
            }
        };

        var difen = 0;
        for (var i = 0; i < self._difenxuanze.length; ++i) {
            if (self._difenxuanze[i].checked) {
                difen = i;
                break;
            }
        }

        var zimo = 0;
        for (var i = 0; i < self._zimo.length; ++i) {
            if (self._zimo[i].checked) {
                zimo = i;
                break;
            }
        }

        var huansanzhang = self._wanfaxuanze[0].checked;
        var jiangdui = self._wanfaxuanze[1].checked;
        var menqing = self._wanfaxuanze[2].checked;
        var tiandihu = self._wanfaxuanze[3].checked;

        var type = 0;
        for (var i = 0; i < self._leixingxuanze.length; ++i) {
            if (self._leixingxuanze[i].checked) {
                type = i;
                break;
            }
        }

        if (type == 0) {
            type = "xzdd";
        } else {
            type = "xlch";
        }

        var zuidafanshu = 0;
        for (var i = 0; i < self._zuidafanshu.length; ++i) {
            if (self._zuidafanshu[i].checked) {
                zuidafanshu = i;
                break;
            }
        }

        var jushuxuanze = 0;
        for (var i = 0; i < self._jushuxuanze.length; ++i) {
            if (self._jushuxuanze[i].checked) {
                jushuxuanze = i;
                break;
            }
        }

        var dianganghua = 0;
        for (var i = 0; i < self._dianganghua.length; ++i) {
            if (self._dianganghua[i].checked) {
                dianganghua = i;
                break;
            }
        }

        var conf = {
            type: type,
            difen: difen,
            zimo: zimo,
            jiangdui: jiangdui,
            huansanzhang: huansanzhang,
            zuidafanshu: zuidafanshu,
            jushuxuanze: jushuxuanze,
            dianganghua: dianganghua,
            menqing: menqing,
            tiandihu: tiandihu
        };

        var data = {
            account: cc.vv.userMgr.account,
            sign: cc.vv.userMgr.sign,
            conf: JSON.stringify(conf)
        };
        console.log(data);
        cc.vv.wc.show("正在创建房间");
        cc.vv.http.sendRequest("/create_private_room", data, onCreate);
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"DingQue":[function(require,module,exports){
"use strict";
cc._RF.push(module, '907582awNJFnobC/mZGFLBq', 'DingQue');
// scripts/components/DingQue.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        queYiMen: null,
        tips: [],
        selected: [],
        dingques: []
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }
        this.initView();
        this.initDingQue();
        this.initEventHandlers();
    },

    initView: function initView() {
        var gameChild = this.node.getChildByName("game");
        this.queYiMen = gameChild.getChildByName("dingque");
        this.queYiMen.active = cc.vv.gameNetMgr.isDingQueing;

        var arr = ["myself", "right", "up", "left"];
        for (var i = 0; i < arr.length; ++i) {
            var side = gameChild.getChildByName(arr[i]);
            var seat = side.getChildByName("seat");
            var dingque = seat.getChildByName("que");
            this.dingques.push(dingque);
        }
        this.reset();

        var tips = this.queYiMen.getChildByName("tips");
        for (var i = 0; i < tips.childrenCount; ++i) {
            var n = tips.children[i];
            this.tips.push(n.getComponent(cc.Label));
        }

        if (cc.vv.gameNetMgr.gamestate == "dingque") {
            this.showDingQueChoice();
        }
    },

    initEventHandlers: function initEventHandlers() {
        var self = this;
        this.node.on('game_dingque', function (data) {
            self.showDingQueChoice();
        });

        this.node.on('game_dingque_notify', function (data) {
            var seatIndex = cc.vv.gameNetMgr.getSeatIndexByID(data.detail);
            var localIndex = cc.vv.gameNetMgr.getLocalIndex(seatIndex);
            console.log("game_dingque_notify:" + localIndex);
            self.tips[localIndex].node.active = true;
        });

        this.node.on('game_dingque_finish', function () {
            //通知每一个玩家定缺的花色
            self.queYiMen.active = false;
            cc.vv.gameNetMgr.isDingQueing = false;
            self.initDingQue();
        });
    },

    showDingQueChoice: function showDingQueChoice() {
        this.queYiMen.active = true;
        var sd = cc.vv.gameNetMgr.getSelfData();
        var typeCounts = [0, 0, 0];
        for (var i = 0; i < sd.holds.length; ++i) {
            var pai = sd.holds[i];
            var type = cc.vv.mahjongmgr.getMahjongType(pai);
            typeCounts[type]++;
        }

        var min = 65535;
        var minIndex = 0;
        for (var i = 0; i < typeCounts.length; ++i) {
            if (typeCounts[i] < min) {
                min = typeCounts[i];
                minIndex = i;
            }
        }

        var arr = ["tong", "tiao", "wan"];
        for (var i = 0; i < arr.length; ++i) {
            var node = this.queYiMen.getChildByName(arr[i]);
            if (minIndex == i) {
                node.getComponent(cc.Animation).play("dingque_tuijian");
            } else {
                node.getComponent(cc.Animation).stop();
            }
            //this.queYiMen.getChildByName(arr[i]).getChildByName('jian').active = minIndex == i;    
        }

        this.reset();
        for (var i = 0; i < this.tips.length; ++i) {
            var n = this.tips[i];
            if (i > 0) {
                n.node.active = false;
            } else {
                n.node.active = true;
            }
        }
    },

    initDingQue: function initDingQue() {
        var arr = ["tong", "tiao", "wan"];
        var data = cc.vv.gameNetMgr.seats;
        for (var i = 0; i < data.length; ++i) {
            var que = data[i].dingque;
            if (que == null || que < 0 || que >= arr.length) {
                que = null;
            } else {
                que = arr[que];
            }

            var localIndex = cc.vv.gameNetMgr.getLocalIndex(i);
            if (que) {
                this.dingques[localIndex].getChildByName(que).active = true;
            }
        }
    },

    reset: function reset() {
        this.setInteractable(true);

        this.selected.push(this.queYiMen.getChildByName("tong_selected"));
        this.selected.push(this.queYiMen.getChildByName("tiao_selected"));
        this.selected.push(this.queYiMen.getChildByName("wan_selected"));
        for (var i = 0; i < this.selected.length; ++i) {
            this.selected[i].active = false;
        }

        for (var i = 0; i < this.dingques.length; ++i) {
            for (var j = 0; j < this.dingques[i].children.length; ++j) {
                this.dingques[i].children[j].active = false;
            }
        }
    },

    onQueYiMenClicked: function onQueYiMenClicked(event) {
        var type = 0;
        if (event.target.name == "tong") {
            type = 0;
        } else if (event.target.name == "tiao") {
            type = 1;
        } else if (event.target.name == "wan") {
            type = 2;
        }

        for (var i = 0; i < this.selected.length; ++i) {
            this.selected[i].active = false;
        }
        this.selected[type].active = true;
        cc.vv.gameNetMgr.dingque = type;
        cc.vv.net.send("dingque", type);

        //this.setInteractable(false);
    },

    setInteractable: function setInteractable(value) {
        this.queYiMen.getChildByName("tong").getComponent(cc.Button).interactable = value;
        this.queYiMen.getChildByName("tiao").getComponent(cc.Button).interactable = value;
        this.queYiMen.getChildByName("wan").getComponent(cc.Button).interactable = value;
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],2:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":1,"ieee754":4,"isarray":3}],3:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],4:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"Folds":[function(require,module,exports){
"use strict";
cc._RF.push(module, '0bf63eiZEFMWbW03o8heqa5', 'Folds');
// scripts/components/Folds.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _folds: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }

        this.initView();
        this.initEventHandler();

        this.initAllFolds();
    },

    initView: function initView() {
        this._folds = {};
        var game = this.node.getChildByName("game");
        var sides = ["myself", "right", "up", "left"];
        for (var i = 0; i < sides.length; ++i) {
            var sideName = sides[i];
            var sideRoot = game.getChildByName(sideName);
            var folds = [];
            var foldRoot = sideRoot.getChildByName("folds");
            for (var j = 0; j < foldRoot.children.length; ++j) {
                var n = foldRoot.children[j];
                n.active = false;
                var sprite = n.getComponent(cc.Sprite);
                sprite.spriteFrame = null;
                folds.push(sprite);
            }
            this._folds[sideName] = folds;
        }

        this.hideAllFolds();
    },

    hideAllFolds: function hideAllFolds() {
        for (var k in this._folds) {
            var f = this._folds[i];
            for (var i in f) {
                f[i].node.active = false;
            }
        }
    },

    initEventHandler: function initEventHandler() {
        var self = this;
        this.node.on('game_begin', function (data) {
            self.initAllFolds();
        });

        this.node.on('game_sync', function (data) {
            self.initAllFolds();
        });

        this.node.on('game_chupai_notify', function (data) {
            self.initFolds(data.detail);
        });

        this.node.on('guo_notify', function (data) {
            self.initFolds(data.detail);
        });
    },

    initAllFolds: function initAllFolds() {
        var seats = cc.vv.gameNetMgr.seats;
        for (var i in seats) {
            this.initFolds(seats[i]);
        }
    },

    initFolds: function initFolds(seatData) {
        var folds = seatData.folds;
        if (folds == null) {
            return;
        }
        var localIndex = cc.vv.gameNetMgr.getLocalIndex(seatData.seatindex);
        var pre = cc.vv.mahjongmgr.getFoldPre(localIndex);
        var side = cc.vv.mahjongmgr.getSide(localIndex);

        var foldsSprites = this._folds[side];
        for (var i = 0; i < foldsSprites.length; ++i) {
            var index = i;
            if (side == "right" || side == "up") {
                index = foldsSprites.length - i - 1;
            }
            var sprite = foldsSprites[index];
            sprite.node.active = true;
            this.setSpriteFrameByMJID(pre, sprite, folds[i]);
        }
        for (var i = folds.length; i < foldsSprites.length; ++i) {
            var index = i;
            if (side == "right" || side == "up") {
                index = foldsSprites.length - i - 1;
            }
            var sprite = foldsSprites[index];

            sprite.spriteFrame = null;
            sprite.node.active = false;
        }
    },

    setSpriteFrameByMJID: function setSpriteFrameByMJID(pre, sprite, mjid) {
        sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID(pre, mjid);
        sprite.node.active = true;
    }

});

cc._RF.pop();
},{}],"GameNetMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, '9545659TARKZLMoHGqXoY2N', 'GameNetMgr');
// scripts/GameNetMgr.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        dataEventHandler: null,
        roomId: null,
        maxNumOfGames: 0,
        numOfGames: 0,
        numOfMJ: 0,
        seatIndex: -1,
        seats: null,
        turn: -1,
        button: -1,
        dingque: -1,
        chupai: -1,
        isDingQueing: false,
        isHuanSanZhang: false,
        gamestate: "",
        isOver: false,
        dissoveData: null
    },

    reset: function reset() {
        this.turn = -1;
        this.chupai = -1, this.dingque = -1;
        this.button = -1;
        this.gamestate = "";
        this.dingque = -1;
        this.isDingQueing = false;
        this.isHuanSanZhang = false;
        this.curaction = null;
        for (var i = 0; i < this.seats.length; ++i) {
            this.seats[i].holds = [];
            this.seats[i].folds = [];
            this.seats[i].pengs = [];
            this.seats[i].angangs = [];
            this.seats[i].diangangs = [];
            this.seats[i].wangangs = [];
            this.seats[i].dingque = -1;
            this.seats[i].ready = false;
            this.seats[i].hued = false;
            this.seats[i].huanpais = null;
            this.huanpaimethod = -1;
        }
    },

    clear: function clear() {
        this.dataEventHandler = null;
        if (this.isOver == null) {
            this.seats = null;
            this.roomId = null;
            this.maxNumOfGames = 0;
            this.numOfGames = 0;
        }
    },

    dispatchEvent: function dispatchEvent(event, data) {
        if (this.dataEventHandler) {
            this.dataEventHandler.emit(event, data);
        }
    },


    getSeatIndexByID: function getSeatIndexByID(userId) {
        for (var i = 0; i < this.seats.length; ++i) {
            var s = this.seats[i];
            if (s.userid == userId) {
                return i;
            }
        }
        return -1;
    },

    isOwner: function isOwner() {
        return this.seatIndex == 0;
    },

    getSeatByID: function getSeatByID(userId) {
        var seatIndex = this.getSeatIndexByID(userId);
        var seat = this.seats[seatIndex];
        return seat;
    },

    getSelfData: function getSelfData() {
        return this.seats[this.seatIndex];
    },

    getLocalIndex: function getLocalIndex(index) {
        var ret = (index - this.seatIndex + 4) % 4;
        return ret;
    },

    prepareReplay: function prepareReplay(roomInfo, detailOfGame) {
        this.roomId = roomInfo.id;
        this.seats = roomInfo.seats;
        this.turn = detailOfGame.base_info.button;
        var baseInfo = detailOfGame.base_info;
        for (var i = 0; i < this.seats.length; ++i) {
            var s = this.seats[i];
            s.seatindex = i;
            s.score = null;
            s.holds = baseInfo.game_seats[i];
            s.pengs = [];
            s.angangs = [];
            s.diangangs = [];
            s.wangangs = [];
            s.folds = [];
            console.log(s);
            if (cc.vv.userMgr.userId == s.userid) {
                this.seatIndex = i;
            }
        }
        this.conf = {
            type: baseInfo.type
        };
        if (this.conf.type == null) {
            this.conf.type == "xzdd";
        }
    },

    getWanfa: function getWanfa() {
        var conf = this.conf;
        if (conf && conf.maxGames != null && conf.maxFan != null) {
            var strArr = [];
            strArr.push(conf.maxGames + "局");
            strArr.push(conf.maxFan + "番封顶");
            if (conf.hsz) {
                strArr.push("换三张");
            }
            if (conf.zimo == 1) {
                strArr.push("自摸加番");
            } else {
                strArr.push("自摸加底");
            }
            if (conf.jiangdui) {
                strArr.push("将对");
            }
            if (conf.dianganghua == 1) {
                strArr.push("点杠花(自摸)");
            } else {
                strArr.push("点杠花(放炮)");
            }
            if (conf.menqing) {
                strArr.push("门清、中张");
            }
            if (conf.tiandihu) {
                strArr.push("天地胡");
            }
            return strArr.join(" ");
        }
        return "";
    },

    initHandlers: function initHandlers() {
        var self = this;
        cc.vv.net.addHandler("login_result", function (data) {
            console.log(data);
            if (data.errcode === 0) {
                var data = data.data;
                self.roomId = data.roomid;
                self.conf = data.conf;
                self.maxNumOfGames = data.conf.maxGames;
                self.numOfGames = data.numofgames;
                self.seats = data.seats;
                self.seatIndex = self.getSeatIndexByID(cc.vv.userMgr.userId);
                self.isOver = false;
            } else {
                console.log(data.errmsg);
            }
        });

        cc.vv.net.addHandler("login_finished", function (data) {
            console.log("login_finished");
            cc.director.loadScene("mjgame");
        });

        cc.vv.net.addHandler("exit_result", function (data) {
            self.roomId = null;
            self.turn = -1;
            self.dingque = -1;
            self.isDingQueing = false;
            self.seats = null;
        });

        cc.vv.net.addHandler("exit_notify_push", function (data) {
            var userId = data;
            var s = self.getSeatByID(userId);
            if (s != null) {
                s.userid = 0;
                s.name = "";
                self.dispatchEvent("user_state_changed", s);
            }
        });

        cc.vv.net.addHandler("dispress_push", function (data) {
            self.roomId = null;
            self.turn = -1;
            self.dingque = -1;
            self.isDingQueing = false;
            self.seats = null;
        });

        cc.vv.net.addHandler("disconnect", function (data) {
            if (self.roomId == null) {
                cc.director.loadScene("hall");
            } else {
                if (self.isOver == false) {
                    cc.vv.userMgr.oldRoomId = self.roomId;
                    self.dispatchEvent("disconnect");
                } else {
                    self.roomId = null;
                }
            }
        });

        cc.vv.net.addHandler("new_user_comes_push", function (data) {
            //console.log(data);
            var seatIndex = data.seatindex;
            if (self.seats[seatIndex].userid > 0) {
                self.seats[seatIndex].online = true;
            } else {
                data.online = true;
                self.seats[seatIndex] = data;
            }
            self.dispatchEvent('new_user', self.seats[seatIndex]);
        });

        cc.vv.net.addHandler("user_state_push", function (data) {
            //console.log(data);
            var userId = data.userid;
            var seat = self.getSeatByID(userId);
            seat.online = data.online;
            self.dispatchEvent('user_state_changed', seat);
        });

        cc.vv.net.addHandler("user_ready_push", function (data) {
            //console.log(data);
            var userId = data.userid;
            var seat = self.getSeatByID(userId);
            seat.ready = data.ready;
            self.dispatchEvent('user_state_changed', seat);
        });

        cc.vv.net.addHandler("game_holds_push", function (data) {
            var seat = self.seats[self.seatIndex];
            console.log(data);
            seat.holds = data;

            for (var i = 0; i < self.seats.length; ++i) {
                var s = self.seats[i];
                if (s.folds == null) {
                    s.folds = [];
                }
                if (s.pengs == null) {
                    s.pengs = [];
                }
                if (s.angangs == null) {
                    s.angangs = [];
                }
                if (s.diangangs == null) {
                    s.diangangs = [];
                }
                if (s.wangangs == null) {
                    s.wangangs = [];
                }
                s.ready = false;
            }
            self.dispatchEvent('game_holds');
        });

        cc.vv.net.addHandler("game_begin_push", function (data) {
            console.log('game_action_push');
            console.log(data);
            self.button = data;
            self.turn = self.button;
            self.gamestate = "begin";
            self.dispatchEvent('game_begin');
        });

        cc.vv.net.addHandler("game_playing_push", function (data) {
            console.log('game_playing_push');
            self.gamestate = "playing";
            self.dispatchEvent('game_playing');
        });

        cc.vv.net.addHandler("game_sync_push", function (data) {
            console.log("game_sync_push");
            console.log(data);
            self.numOfMJ = data.numofmj;
            self.gamestate = data.state;
            if (self.gamestate == "dingque") {
                self.isDingQueing = true;
            } else if (self.gamestate == "huanpai") {
                self.isHuanSanZhang = true;
            }
            self.turn = data.turn;
            self.button = data.button;
            self.chupai = data.chuPai;
            self.huanpaimethod = data.huanpaimethod;
            for (var i = 0; i < 4; ++i) {
                var seat = self.seats[i];
                var sd = data.seats[i];
                seat.holds = sd.holds;
                seat.folds = sd.folds;
                seat.angangs = sd.angangs;
                seat.diangangs = sd.diangangs;
                seat.wangangs = sd.wangangs;
                seat.pengs = sd.pengs;
                seat.dingque = sd.que;
                seat.hued = sd.hued;
                seat.iszimo = sd.iszimo;
                seat.huinfo = sd.huinfo;
                seat.huanpais = sd.huanpais;
                if (i == self.seatIndex) {
                    self.dingque = sd.que;
                }
            }
        });

        cc.vv.net.addHandler("game_dingque_push", function (data) {
            self.isDingQueing = true;
            self.isHuanSanZhang = false;
            self.dispatchEvent('game_dingque');
        });

        cc.vv.net.addHandler("game_huanpai_push", function (data) {
            self.isHuanSanZhang = true;
            self.dispatchEvent('game_huanpai');
        });

        cc.vv.net.addHandler("hangang_notify_push", function (data) {
            self.dispatchEvent('hangang_notify', data);
        });

        cc.vv.net.addHandler("game_action_push", function (data) {
            self.curaction = data;
            console.log(data);
            self.dispatchEvent('game_action', data);
        });

        cc.vv.net.addHandler("game_chupai_push", function (data) {
            console.log('game_chupai_push');
            //console.log(data);
            var turnUserID = data;
            var si = self.getSeatIndexByID(turnUserID);
            self.doTurnChange(si);
        });

        cc.vv.net.addHandler("game_num_push", function (data) {
            self.numOfGames = data;
            self.dispatchEvent('game_num', data);
        });

        cc.vv.net.addHandler("game_over_push", function (data) {
            console.log('game_over_push');
            var results = data.results;
            for (var i = 0; i < self.seats.length; ++i) {
                self.seats[i].score = results.length == 0 ? 0 : results[i].totalscore;
            }
            self.dispatchEvent('game_over', results);
            if (data.endinfo) {
                self.isOver = true;
                self.dispatchEvent('game_end', data.endinfo);
            }
            self.reset();
            for (var i = 0; i < self.seats.length; ++i) {
                self.dispatchEvent('user_state_changed', self.seats[i]);
            }
        });

        cc.vv.net.addHandler("mj_count_push", function (data) {
            console.log('mj_count_push');
            self.numOfMJ = data;
            //console.log(data);
            self.dispatchEvent('mj_count', data);
        });

        cc.vv.net.addHandler("hu_push", function (data) {
            console.log('hu_push');
            console.log(data);
            self.doHu(data);
        });

        cc.vv.net.addHandler("game_chupai_notify_push", function (data) {
            var userId = data.userId;
            var pai = data.pai;
            var si = self.getSeatIndexByID(userId);
            self.doChupai(si, pai);
        });

        cc.vv.net.addHandler("game_mopai_push", function (data) {
            console.log('game_mopai_push');
            self.doMopai(self.seatIndex, data);
        });

        cc.vv.net.addHandler("guo_notify_push", function (data) {
            console.log('guo_notify_push');
            var userId = data.userId;
            var pai = data.pai;
            var si = self.getSeatIndexByID(userId);
            self.doGuo(si, pai);
        });

        cc.vv.net.addHandler("guo_result", function (data) {
            console.log('guo_result');
            self.dispatchEvent('guo_result');
        });

        cc.vv.net.addHandler("guohu_push", function (data) {
            console.log('guohu_push');
            self.dispatchEvent("push_notice", { info: "过胡", time: 1.5 });
        });

        cc.vv.net.addHandler("huanpai_notify", function (data) {
            var seat = self.getSeatByID(data.si);
            seat.huanpais = data.huanpais;
            self.dispatchEvent('huanpai_notify', seat);
        });

        cc.vv.net.addHandler("game_huanpai_over_push", function (data) {
            console.log('game_huanpai_over_push');
            var info = "";
            var method = data.method;
            if (method == 0) {
                info = "换对家牌";
            } else if (method == 1) {
                info = "换下家牌";
            } else {
                info = "换上家牌";
            }
            self.huanpaimethod = method;
            cc.vv.gameNetMgr.isHuanSanZhang = false;
            self.dispatchEvent("game_huanpai_over");
            self.dispatchEvent("push_notice", { info: info, time: 2 });
        });

        cc.vv.net.addHandler("peng_notify_push", function (data) {
            console.log('peng_notify_push');
            console.log(data);
            var userId = data.userid;
            var pai = data.pai;
            var si = self.getSeatIndexByID(userId);
            self.doPeng(si, data.pai);
        });

        cc.vv.net.addHandler("gang_notify_push", function (data) {
            console.log('gang_notify_push');
            console.log(data);
            var userId = data.userid;
            var pai = data.pai;
            var si = self.getSeatIndexByID(userId);
            self.doGang(si, pai, data.gangtype);
        });

        cc.vv.net.addHandler("game_dingque_notify_push", function (data) {
            self.dispatchEvent('game_dingque_notify', data);
        });

        cc.vv.net.addHandler("game_dingque_finish_push", function (data) {
            for (var i = 0; i < data.length; ++i) {
                self.seats[i].dingque = data[i];
            }
            self.dispatchEvent('game_dingque_finish', data);
        });

        cc.vv.net.addHandler("chat_push", function (data) {
            self.dispatchEvent("chat_push", data);
        });

        cc.vv.net.addHandler("quick_chat_push", function (data) {
            self.dispatchEvent("quick_chat_push", data);
        });

        cc.vv.net.addHandler("emoji_push", function (data) {
            self.dispatchEvent("emoji_push", data);
        });

        cc.vv.net.addHandler("dissolve_notice_push", function (data) {
            console.log("dissolve_notice_push");
            console.log(data);
            self.dissoveData = data;
            self.dispatchEvent("dissolve_notice", data);
        });

        cc.vv.net.addHandler("dissolve_cancel_push", function (data) {
            self.dissoveData = null;
            self.dispatchEvent("dissolve_cancel", data);
        });

        cc.vv.net.addHandler("voice_msg_push", function (data) {
            self.dispatchEvent("voice_msg", data);
        });
    },

    doGuo: function doGuo(seatIndex, pai) {
        var seatData = this.seats[seatIndex];
        var folds = seatData.folds;
        folds.push(pai);
        this.dispatchEvent('guo_notify', seatData);
    },

    doMopai: function doMopai(seatIndex, pai) {
        var seatData = this.seats[seatIndex];
        if (seatData.holds) {
            seatData.holds.push(pai);
            this.dispatchEvent('game_mopai', { seatIndex: seatIndex, pai: pai });
        }
    },

    doChupai: function doChupai(seatIndex, pai) {
        this.chupai = pai;
        var seatData = this.seats[seatIndex];
        if (seatData.holds) {
            var idx = seatData.holds.indexOf(pai);
            seatData.holds.splice(idx, 1);
        }
        this.dispatchEvent('game_chupai_notify', { seatData: seatData, pai: pai });
    },

    doPeng: function doPeng(seatIndex, pai) {
        var seatData = this.seats[seatIndex];
        //移除手牌
        if (seatData.holds) {
            for (var i = 0; i < 2; ++i) {
                var idx = seatData.holds.indexOf(pai);
                seatData.holds.splice(idx, 1);
            }
        }

        //更新碰牌数据
        var pengs = seatData.pengs;
        pengs.push(pai);

        this.dispatchEvent('peng_notify', seatData);
    },

    getGangType: function getGangType(seatData, pai) {
        if (seatData.pengs.indexOf(pai) != -1) {
            return "wangang";
        } else {
            var cnt = 0;
            for (var i = 0; i < seatData.holds.length; ++i) {
                if (seatData.holds[i] == pai) {
                    cnt++;
                }
            }
            if (cnt == 3) {
                return "diangang";
            } else {
                return "angang";
            }
        }
    },

    doGang: function doGang(seatIndex, pai, gangtype) {
        var seatData = this.seats[seatIndex];

        if (!gangtype) {
            gangtype = this.getGangType(seatData, pai);
        }

        if (gangtype == "wangang") {
            if (seatData.pengs.indexOf(pai) != -1) {
                var idx = seatData.pengs.indexOf(pai);
                if (idx != -1) {
                    seatData.pengs.splice(idx, 1);
                }
            }
            seatData.wangangs.push(pai);
        }
        if (seatData.holds) {
            for (var i = 0; i <= 4; ++i) {
                var idx = seatData.holds.indexOf(pai);
                if (idx == -1) {
                    //如果没有找到，表示移完了，直接跳出循环
                    break;
                }
                seatData.holds.splice(idx, 1);
            }
        }
        if (gangtype == "angang") {
            seatData.angangs.push(pai);
        } else if (gangtype == "diangang") {
            seatData.diangangs.push(pai);
        }
        this.dispatchEvent('gang_notify', { seatData: seatData, gangtype: gangtype });
    },

    doHu: function doHu(data) {
        this.dispatchEvent('hupai', data);
    },

    doTurnChange: function doTurnChange(si) {
        var data = {
            last: this.turn,
            turn: si
        };
        this.turn = si;
        this.dispatchEvent('game_chupai', data);
    },

    connectGameServer: function connectGameServer(data) {
        this.dissoveData = null;
        cc.vv.net.ip = data.ip + ":" + data.port;
        console.log(cc.vv.net.ip);
        var self = this;

        var onConnectOK = function onConnectOK() {
            console.log("onConnectOK");
            var sd = {
                token: data.token,
                roomid: data.roomid,
                time: data.time,
                sign: data.sign
            };
            cc.vv.net.send("login", sd);
        };

        var onConnectFailed = function onConnectFailed() {
            console.log("failed.");
            cc.vv.wc.hide();
        };
        cc.vv.wc.show("正在进入房间");
        cc.vv.net.connect(onConnectOK, onConnectFailed);
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"GameOver":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'facfdljnx5F+rFDAq5Qbmqa', 'GameOver');
// scripts/components/GameOver.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _gameover: null,
        _gameresult: null,
        _seats: [],
        _isGameEnd: false,
        _pingju: null,
        _win: null,
        _lose: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }
        if (cc.vv.gameNetMgr.conf == null) {
            return;
        }
        if (cc.vv.gameNetMgr.conf.type == "xzdd") {
            this._gameover = this.node.getChildByName("game_over");
        } else {
            this._gameover = this.node.getChildByName("game_over_xlch");
        }

        this._gameover.active = false;

        this._pingju = this._gameover.getChildByName("pingju");
        this._win = this._gameover.getChildByName("win");
        this._lose = this._gameover.getChildByName("lose");

        this._gameresult = this.node.getChildByName("game_result");

        var wanfa = this._gameover.getChildByName("wanfa").getComponent(cc.Label);
        wanfa.string = cc.vv.gameNetMgr.getWanfa();

        var listRoot = this._gameover.getChildByName("result_list");
        for (var i = 1; i <= 4; ++i) {
            var s = "s" + i;
            var sn = listRoot.getChildByName(s);
            var viewdata = {};
            viewdata.username = sn.getChildByName('username').getComponent(cc.Label);
            viewdata.reason = sn.getChildByName('reason').getComponent(cc.Label);

            var f = sn.getChildByName('fan');
            if (f != null) {
                viewdata.fan = f.getComponent(cc.Label);
            }

            viewdata.score = sn.getChildByName('score').getComponent(cc.Label);
            viewdata.hu = sn.getChildByName('hu');
            viewdata.mahjongs = sn.getChildByName('pai');
            viewdata.zhuang = sn.getChildByName('zhuang');
            viewdata.hupai = sn.getChildByName('hupai');
            viewdata._pengandgang = [];
            this._seats.push(viewdata);
        }

        //初始化网络事件监听器
        var self = this;
        this.node.on('game_over', function (data) {
            self.onGameOver(data.detail);
        });

        this.node.on('game_end', function (data) {
            self._isGameEnd = true;
        });
    },

    onGameOver: function onGameOver(data) {
        if (cc.vv.gameNetMgr.conf.type == "xzdd") {
            this.onGameOver_XZDD(data);
        } else {
            this.onGameOver_XLCH(data);
        }
    },
    onGameOver_XZDD: function onGameOver_XZDD(data) {
        console.log(data);
        if (data.length == 0) {
            this._gameresult.active = true;
            return;
        }
        this._gameover.active = true;
        this._pingju.active = false;
        this._win.active = false;
        this._lose.active = false;

        var myscore = data[cc.vv.gameNetMgr.seatIndex].score;
        if (myscore > 0) {
            this._win.active = true;
        } else if (myscore < 0) {
            this._lose.active = true;
        } else {
            this._pingju.active = true;
        }

        //显示玩家信息
        for (var i = 0; i < 4; ++i) {
            var seatView = this._seats[i];
            var userData = data[i];
            var hued = false;
            //胡牌的玩家才显示 是否清一色 根xn的字样
            var numOfGangs = userData.angangs.length + userData.wangangs.length + userData.diangangs.length;
            var numOfGen = userData.numofgen;
            var actionArr = [];
            var is7pairs = false;
            var ischadajiao = false;
            for (var j = 0; j < userData.actions.length; ++j) {
                var ac = userData.actions[j];
                if (ac.type == "zimo" || ac.type == "ganghua" || ac.type == "dianganghua" || ac.type == "hu" || ac.type == "gangpaohu" || ac.type == "qiangganghu" || ac.type == "chadajiao") {
                    if (userData.pattern == "7pairs") {
                        actionArr.push("七对");
                    } else if (userData.pattern == "l7pairs") {
                        actionArr.push("龙七对");
                    } else if (userData.pattern == "j7pairs") {
                        actionArr.push("将七对");
                    } else if (userData.pattern == "duidui") {
                        actionArr.push("碰碰胡");
                    } else if (userData.pattern == "jiangdui") {
                        actionArr.push("将对");
                    }

                    if (ac.type == "zimo") {
                        actionArr.push("自摸");
                    } else if (ac.type == "ganghua") {
                        actionArr.push("杠上花");
                    } else if (ac.type == "dianganghua") {
                        actionArr.push("点杠花");
                    } else if (ac.type == "gangpaohu") {
                        actionArr.push("杠炮胡");
                    } else if (ac.type == "qiangganghu") {
                        actionArr.push("抢杠胡");
                    } else if (ac.type == "chadajiao") {
                        ischadajiao = true;
                    }
                    hued = true;
                } else if (ac.type == "fangpao") {
                    actionArr.push("放炮");
                } else if (ac.type == "angang") {
                    actionArr.push("暗杠");
                } else if (ac.type == "diangang") {
                    actionArr.push("明杠");
                } else if (ac.type == "wangang") {
                    actionArr.push("弯杠");
                } else if (ac.type == "fanggang") {
                    actionArr.push("放杠");
                } else if (ac.type == "zhuanshougang") {
                    actionArr.push("转手杠");
                } else if (ac.type == "beiqianggang") {
                    actionArr.push("被抢杠");
                } else if (ac.type == "beichadajiao") {
                    actionArr.push("被查叫");
                }
            }

            if (hued) {
                if (userData.qingyise) {
                    actionArr.push("清一色");
                }

                if (userData.menqing) {
                    actionArr.push("门清");
                }

                if (userData.zhongzhang) {
                    actionArr.push("中张");
                }

                if (userData.jingouhu) {
                    actionArr.push("金钩胡");
                }

                if (userData.haidihu) {
                    actionArr.push("海底胡");
                }

                if (userData.tianhu) {
                    actionArr.push("天胡");
                }

                if (userData.dihu) {
                    actionArr.push("地胡");
                }

                if (numOfGen > 0) {
                    actionArr.push("根x" + numOfGen);
                }

                if (ischadajiao) {
                    actionArr.push("查大叫");
                }
            }

            for (var o = 0; o < 3; ++o) {
                seatView.hu.children[o].active = false;
            }
            if (userData.huorder >= 0) {
                seatView.hu.children[userData.huorder].active = true;
            }

            seatView.username.string = cc.vv.gameNetMgr.seats[i].name;
            seatView.zhuang.active = cc.vv.gameNetMgr.button == i;
            seatView.reason.string = actionArr.join("、");

            //胡牌的玩家才有番
            var fan = 0;
            if (hued) {
                fan = userData.fan;
            }
            seatView.fan.string = fan + "番";

            //
            if (userData.score > 0) {
                seatView.score.string = "+" + userData.score;
            } else {
                seatView.score.string = userData.score;
            }

            var hupai = -1;
            if (hued) {
                hupai = userData.holds.pop();
            }

            cc.vv.mahjongmgr.sortMJ(userData.holds, userData.dingque);

            //胡牌不参与排序
            if (hued) {
                userData.holds.push(hupai);
            }

            //隐藏所有牌
            for (var k = 0; k < seatView.mahjongs.childrenCount; ++k) {
                var n = seatView.mahjongs.children[k];
                n.active = false;
            }

            var lackingNum = (userData.pengs.length + numOfGangs) * 3;
            //显示相关的牌
            for (var k = 0; k < userData.holds.length; ++k) {
                var pai = userData.holds[k];
                var n = seatView.mahjongs.children[k + lackingNum];
                n.active = true;
                var sprite = n.getComponent(cc.Sprite);
                sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", pai);
            }

            for (var k = 0; k < seatView._pengandgang.length; ++k) {
                seatView._pengandgang[k].active = false;
            }

            //初始化杠牌
            var index = 0;
            var gangs = userData.angangs;
            for (var k = 0; k < gangs.length; ++k) {
                var mjid = gangs[k];
                this.initPengAndGangs(seatView, index, mjid, "angang");
                index++;
            }

            var gangs = userData.diangangs;
            for (var k = 0; k < gangs.length; ++k) {
                var mjid = gangs[k];
                this.initPengAndGangs(seatView, index, mjid, "diangang");
                index++;
            }

            var gangs = userData.wangangs;
            for (var k = 0; k < gangs.length; ++k) {
                var mjid = gangs[k];
                this.initPengAndGangs(seatView, index, mjid, "wangang");
                index++;
            }

            //初始化碰牌
            var pengs = userData.pengs;
            if (pengs) {
                for (var k = 0; k < pengs.length; ++k) {
                    var mjid = pengs[k];
                    this.initPengAndGangs(seatView, index, mjid, "peng");
                    index++;
                }
            }
        }
    },

    onGameOver_XLCH: function onGameOver_XLCH(data) {
        console.log(data);
        if (data.length == 0) {
            this._gameresult.active = true;
            return;
        }
        this._gameover.active = true;
        this._pingju.active = false;
        this._win.active = false;
        this._lose.active = false;

        var myscore = data[cc.vv.gameNetMgr.seatIndex].score;
        if (myscore > 0) {
            this._win.active = true;
        } else if (myscore < 0) {
            this._lose.active = true;
        } else {
            this._pingju.active = true;
        }

        //显示玩家信息
        for (var i = 0; i < 4; ++i) {
            var seatView = this._seats[i];
            var userData = data[i];
            var hued = false;
            var actionArr = [];
            var is7pairs = false;
            var ischadajiao = false;
            var hupaiRoot = seatView.hupai;

            for (var j = 0; j < hupaiRoot.children.length; ++j) {
                hupaiRoot.children[j].active = false;
            }

            var hi = 0;
            for (var j = 0; j < userData.huinfo.length; ++j) {
                var info = userData.huinfo[j];
                hued = hued || info.ishupai;
                if (info.ishupai) {
                    if (hi < hupaiRoot.children.length) {
                        var hupaiView = hupaiRoot.children[hi];
                        hupaiView.active = true;
                        hupaiView.getComponent(cc.Sprite).spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("B_", info.pai);
                        hi++;
                    }
                }

                var str = "";
                var sep = "";

                var dataseat = userData;
                if (!info.ishupai) {
                    if (info.action == "fangpao") {
                        str = "放炮";
                    } else if (info.action == "gangpao") {
                        str = "杠上炮";
                    } else if (info.action == "beiqianggang") {
                        str = "被抢杠";
                    } else {
                        str = "被查大叫";
                    }

                    dataseat = data[info.target];
                    info = dataseat.huinfo[info.index];
                } else {
                    if (info.action == "hu") {
                        str = "接炮胡";
                    } else if (info.action == "zimo") {
                        str = "自摸";
                    } else if (info.action == "ganghua") {
                        str = "杠上花";
                    } else if (info.action == "dianganghua") {
                        str = "点杠花";
                    } else if (info.action == "gangpaohu") {
                        str = "杠炮胡";
                    } else if (info.action == "qiangganghu") {
                        str = "抢杠胡";
                    } else if (info.action == "chadajiao") {
                        str = "查大叫";
                    }
                }

                str += "(";

                if (info.pattern == "7pairs") {
                    str += "七对";
                    sep = "、";
                } else if (info.pattern == "l7pairs") {
                    str += "龙七对";
                    sep = "、";
                } else if (info.pattern == "j7pairs") {
                    str += "将七对";
                    sep = "、";
                } else if (info.pattern == "duidui") {
                    str += "碰碰胡";
                    sep = "、";
                } else if (info.pattern == "jiangdui") {
                    str += "将对";
                    sep = "、";
                }

                if (info.haidihu) {
                    str += sep + "海底胡";
                    sep = "、";
                }

                if (info.tianhu) {
                    str += sep + "天胡";
                    sep = "、";
                }

                if (info.dihu) {
                    str += sep + "地胡";
                    sep = "、";
                }

                if (dataseat.qingyise) {
                    str += sep + "清一色";
                    sep = "、";
                }

                if (dataseat.menqing) {
                    str += sep + "门清";
                    sep = "、";
                }

                if (dataseat.jingouhu) {
                    str += sep + "金钩胡";
                    sep = "、";
                }

                if (dataseat.zhongzhang) {
                    str += sep + "中张";
                    sep = "、";
                }

                if (info.numofgen > 0) {
                    str += sep + "根x" + info.numofgen;
                    sep = "、";
                }

                if (sep == "") {
                    str += "平胡";
                }

                str += "、" + info.fan + "番";

                str += ")";
                actionArr.push(str);
            }

            seatView.hu.active = hued;

            if (userData.angangs.length) {
                actionArr.push("暗杠x" + userData.angangs.length);
            }

            if (userData.diangangs.length) {
                actionArr.push("明杠x" + userData.diangangs.length);
            }

            if (userData.wangangs.length) {
                actionArr.push("巴杠x" + userData.wangangs.length);
            }

            seatView.username.string = cc.vv.gameNetMgr.seats[i].name;
            seatView.zhuang.active = cc.vv.gameNetMgr.button == i;
            seatView.reason.string = actionArr.join("、");

            //
            if (userData.score > 0) {
                seatView.score.string = "+" + userData.score;
            } else {
                seatView.score.string = userData.score;
            }

            //隐藏所有牌
            for (var k = 0; k < seatView.mahjongs.childrenCount; ++k) {
                var n = seatView.mahjongs.children[k];
                n.active = false;
            }

            cc.vv.mahjongmgr.sortMJ(userData.holds, userData.dingque);

            var numOfGangs = userData.angangs.length + userData.wangangs.length + userData.diangangs.length;

            var lackingNum = (userData.pengs.length + numOfGangs) * 3;
            //显示相关的牌
            for (var k = 0; k < userData.holds.length; ++k) {
                var pai = userData.holds[k];
                var n = seatView.mahjongs.children[k + lackingNum];
                n.active = true;
                var sprite = n.getComponent(cc.Sprite);
                sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", pai);
            }

            for (var k = 0; k < seatView._pengandgang.length; ++k) {
                seatView._pengandgang[k].active = false;
            }

            //初始化杠牌
            var index = 0;
            var gangs = userData.angangs;
            for (var k = 0; k < gangs.length; ++k) {
                var mjid = gangs[k];
                this.initPengAndGangs(seatView, index, mjid, "angang");
                index++;
            }

            var gangs = userData.diangangs;
            for (var k = 0; k < gangs.length; ++k) {
                var mjid = gangs[k];
                this.initPengAndGangs(seatView, index, mjid, "diangang");
                index++;
            }

            var gangs = userData.wangangs;
            for (var k = 0; k < gangs.length; ++k) {
                var mjid = gangs[k];
                this.initPengAndGangs(seatView, index, mjid, "wangang");
                index++;
            }

            //初始化碰牌
            var pengs = userData.pengs;
            if (pengs) {
                for (var k = 0; k < pengs.length; ++k) {
                    var mjid = pengs[k];
                    this.initPengAndGangs(seatView, index, mjid, "peng");
                    index++;
                }
            }
        }
    },

    initPengAndGangs: function initPengAndGangs(seatView, index, mjid, flag) {
        var pgroot = null;
        if (seatView._pengandgang.length <= index) {
            pgroot = cc.instantiate(cc.vv.mahjongmgr.pengPrefabSelf);
            seatView._pengandgang.push(pgroot);
            seatView.mahjongs.addChild(pgroot);
        } else {
            pgroot = seatView._pengandgang[index];
            pgroot.active = true;
        }

        var sprites = pgroot.getComponentsInChildren(cc.Sprite);
        for (var s = 0; s < sprites.length; ++s) {
            var sprite = sprites[s];
            if (sprite.node.name == "gang") {
                var isGang = flag != "peng";
                sprite.node.active = isGang;
                sprite.node.scaleX = 1.0;
                sprite.node.scaleY = 1.0;
                if (flag == "angang") {
                    sprite.spriteFrame = cc.vv.mahjongmgr.getEmptySpriteFrame("myself");
                    sprite.node.scaleX = 1.4;
                    sprite.node.scaleY = 1.4;
                } else {
                    sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("B_", mjid);
                }
            } else {
                sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("B_", mjid);
            }
        }
        pgroot.x = index * 55 * 3 + index * 10;
    },

    onBtnReadyClicked: function onBtnReadyClicked() {
        console.log("onBtnReadyClicked");
        if (this._isGameEnd) {
            this._gameresult.active = true;
        } else {
            cc.vv.net.send('ready');
        }
        this._gameover.active = false;
    },

    onBtnShareClicked: function onBtnShareClicked() {
        console.log("onBtnShareClicked");
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"GameResult":[function(require,module,exports){
"use strict";
cc._RF.push(module, '2b08d8pm0VBDLYlZIdfLuPS', 'GameResult');
// scripts/components/GameResult.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _gameresult: null,
        _seats: []
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }

        this._gameresult = this.node.getChildByName("game_result");
        //this._gameresult.active = false;

        var seats = this._gameresult.getChildByName("seats");
        for (var i = 0; i < seats.children.length; ++i) {
            this._seats.push(seats.children[i].getComponent("Seat"));
        }

        var btnClose = cc.find("Canvas/game_result/btnClose");
        if (btnClose) {
            cc.vv.utils.addClickEvent(btnClose, this.node, "GameResult", "onBtnCloseClicked");
        }

        var btnShare = cc.find("Canvas/game_result/btnShare");
        if (btnShare) {
            cc.vv.utils.addClickEvent(btnShare, this.node, "GameResult", "onBtnShareClicked");
        }

        //初始化网络事件监听器
        var self = this;
        this.node.on('game_end', function (data) {
            self.onGameEnd(data.detail);
        });
    },

    showResult: function showResult(seat, info, isZuiJiaPaoShou) {
        seat.node.getChildByName("zuijiapaoshou").active = isZuiJiaPaoShou;

        seat.node.getChildByName("zimocishu").getComponent(cc.Label).string = info.numzimo;
        seat.node.getChildByName("jiepaocishu").getComponent(cc.Label).string = info.numjiepao;
        seat.node.getChildByName("dianpaocishu").getComponent(cc.Label).string = info.numdianpao;
        seat.node.getChildByName("angangcishu").getComponent(cc.Label).string = info.numangang;
        seat.node.getChildByName("minggangcishu").getComponent(cc.Label).string = info.numminggang;
        seat.node.getChildByName("chajiaocishu").getComponent(cc.Label).string = info.numchadajiao;
    },

    onGameEnd: function onGameEnd(endinfo) {
        var seats = cc.vv.gameNetMgr.seats;
        var maxscore = -1;
        var maxdianpao = 0;
        var dianpaogaoshou = -1;
        for (var i = 0; i < seats.length; ++i) {
            var seat = seats[i];
            if (seat.score > maxscore) {
                maxscore = seat.score;
            }
            if (endinfo[i].numdianpao > maxdianpao) {
                maxdianpao = endinfo[i].numdianpao;
                dianpaogaoshou = i;
            }
        }

        for (var i = 0; i < seats.length; ++i) {
            var seat = seats[i];
            var isBigwin = false;
            if (seat.score > 0) {
                isBigwin = seat.score == maxscore;
            }
            this._seats[i].setInfo(seat.name, seat.score, isBigwin);
            this._seats[i].setID(seat.userid);
            var isZuiJiaPaoShou = dianpaogaoshou == i;
            this.showResult(this._seats[i], endinfo[i], isZuiJiaPaoShou);
        }
    },

    onBtnCloseClicked: function onBtnCloseClicked() {
        cc.director.loadScene("hall");
    },

    onBtnShareClicked: function onBtnShareClicked() {
        cc.vv.anysdkMgr.shareResult();
    }
});

cc._RF.pop();
},{}],"Global":[function(require,module,exports){
"use strict";
cc._RF.push(module, '24e30ZJLgdH3rs1R1CvqN8U', 'Global');
// scripts/Global.js

"use strict";

var Global = cc.Class({
    extends: cc.Component,
    statics: {
        isstarted: false,
        netinited: false,
        userguid: 0,
        nickname: "",
        money: 0,
        lv: 0,
        roomId: 0
    }
});

cc._RF.pop();
},{}],"HTTP":[function(require,module,exports){
"use strict";
cc._RF.push(module, '90ae61J525JQIt5taF3Nce2', 'HTTP');
// scripts/HTTP.js

"use strict";

//var URL = "http://118.89.235.34:9000";
//var URL = "http://120.24.181.145:9000";
//var URL = "http://120.24.59.70:9000";
var URL = "http://121.41.43.104:9900";

cc.VERSION = 20161227;
var HTTP = cc.Class({
    extends: cc.Component,

    statics: {
        sessionId: 0,
        userId: 0,
        master_url: URL,
        url: URL,
        sendRequest: function sendRequest(path, data, handler, extraUrl) {
            var xhr = cc.loader.getXMLHttpRequest();
            xhr.timeout = 5000;
            var str = "?";
            for (var k in data) {
                if (str != "?") {
                    str += "&";
                }
                str += k + "=" + data[k];
            }
            if (extraUrl == null) {
                extraUrl = HTTP.url;
            }
            var requestURL = extraUrl + path + encodeURI(str);
            console.log("RequestURL:" + requestURL);
            xhr.open("GET", requestURL, true);
            if (cc.sys.isNative) {
                xhr.setRequestHeader("Accept-Encoding", "gzip,deflate", "text/html;charset=UTF-8");
            }

            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
                    console.log("http res(" + xhr.responseText.length + "):" + xhr.responseText);
                    try {
                        var ret = JSON.parse(xhr.responseText);
                        if (handler !== null) {
                            handler(ret);
                        } /* code */
                    } catch (e) {
                        console.log("err:" + e);
                        //handler(null);
                    } finally {
                        if (cc.vv && cc.vv.wc) {
                            //       cc.vv.wc.hide();    
                        }
                    }
                }
            };

            if (cc.vv && cc.vv.wc) {
                //cc.vv.wc.show();
            }
            xhr.send();
            return xhr;
        }
    }
});

cc._RF.pop();
},{}],"Hall":[function(require,module,exports){
"use strict";
cc._RF.push(module, '6edb3jjx+FBepS1mk1xKDF2', 'Hall');
// scripts/components/Hall.js

"use strict";

var Net = require("Net");
var Global = require("Global");
cc.Class({
    extends: cc.Component,

    properties: {
        lblName: cc.Label,
        lblMoney: cc.Label,
        lblGems: cc.Label,
        lblID: cc.Label,
        lblNotice: cc.Label,
        joinGameWin: cc.Node,
        createRoomWin: cc.Node,
        settingsWin: cc.Node,
        helpWin: cc.Node,
        xiaoxiWin: cc.Node,
        btnJoinGame: cc.Node,
        btnReturnGame: cc.Node,
        sprHeadImg: cc.Sprite
    },

    initNetHandlers: function initNetHandlers() {
        var self = this;
    },

    onShare: function onShare() {
        cc.vv.anysdkMgr.share("达达麻将", "达达麻将，包含了血战到底、血流成河等多种四川流行麻将玩法。");
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (!cc.sys.isNative && cc.sys.isMobile) {
            var cvs = this.node.getComponent(cc.Canvas);
            cvs.fitHeight = true;
            cvs.fitWidth = true;
        }
        if (!cc.vv) {
            cc.director.loadScene("loading");
            return;
        }
        this.initLabels();

        if (cc.vv.gameNetMgr.roomId == null) {
            this.btnJoinGame.active = true;
            this.btnReturnGame.active = false;
        } else {
            this.btnJoinGame.active = false;
            this.btnReturnGame.active = true;
        }

        //var params = cc.vv.args;
        var roomId = cc.vv.userMgr.oldRoomId;
        if (roomId != null) {
            cc.vv.userMgr.oldRoomId = null;
            cc.vv.userMgr.enterRoom(roomId);
        }

        var imgLoader = this.sprHeadImg.node.getComponent("ImageLoader");
        imgLoader.setUserID(cc.vv.userMgr.userId);
        cc.vv.utils.addClickEvent(this.sprHeadImg.node, this.node, "Hall", "onBtnClicked");

        this.addComponent("UserInfoShow");

        this.initButtonHandler("Canvas/right_bottom/btn_shezhi");
        this.initButtonHandler("Canvas/right_bottom/btn_help");
        this.initButtonHandler("Canvas/right_bottom/btn_xiaoxi");
        this.helpWin.addComponent("OnBack");
        this.xiaoxiWin.addComponent("OnBack");

        if (!cc.vv.userMgr.notice) {
            cc.vv.userMgr.notice = {
                version: null,
                msg: "数据请求中..."
            };
        }

        if (!cc.vv.userMgr.gemstip) {
            cc.vv.userMgr.gemstip = {
                version: null,
                msg: "数据请求中..."
            };
        }

        this.lblNotice.string = cc.vv.userMgr.notice.msg;

        this.refreshInfo();
        this.refreshNotice();
        this.refreshGemsTip();

        cc.vv.audioMgr.playBGM("bgMain.mp3");
    },

    refreshInfo: function refreshInfo() {
        var self = this;
        var onGet = function onGet(ret) {
            if (ret.errcode !== 0) {
                console.log(ret.errmsg);
            } else {
                if (ret.gems != null) {
                    this.lblGems.string = ret.gems;
                }
            }
        };

        var data = {
            account: cc.vv.userMgr.account,
            sign: cc.vv.userMgr.sign
        };
        cc.vv.http.sendRequest("/get_user_status", data, onGet.bind(this));
    },

    refreshGemsTip: function refreshGemsTip() {
        var self = this;
        var onGet = function onGet(ret) {
            if (ret.errcode !== 0) {
                console.log(ret.errmsg);
            } else {
                cc.vv.userMgr.gemstip.version = ret.version;
                cc.vv.userMgr.gemstip.msg = ret.msg.replace("<newline>", "\n");
            }
        };

        var data = {
            account: cc.vv.userMgr.account,
            sign: cc.vv.userMgr.sign,
            type: "fkgm",
            version: cc.vv.userMgr.gemstip.version
        };
        cc.vv.http.sendRequest("/get_message", data, onGet.bind(this));
    },

    refreshNotice: function refreshNotice() {
        var self = this;
        var onGet = function onGet(ret) {
            if (ret.errcode !== 0) {
                console.log(ret.errmsg);
            } else {
                cc.vv.userMgr.notice.version = ret.version;
                cc.vv.userMgr.notice.msg = ret.msg;
                this.lblNotice.string = ret.msg;
            }
        };

        var data = {
            account: cc.vv.userMgr.account,
            sign: cc.vv.userMgr.sign,
            type: "notice",
            version: cc.vv.userMgr.notice.version
        };
        cc.vv.http.sendRequest("/get_message", data, onGet.bind(this));
    },

    initButtonHandler: function initButtonHandler(btnPath) {
        var btn = cc.find(btnPath);
        cc.vv.utils.addClickEvent(btn, this.node, "Hall", "onBtnClicked");
    },

    initLabels: function initLabels() {
        this.lblName.string = cc.vv.userMgr.userName;
        this.lblMoney.string = cc.vv.userMgr.coins;
        this.lblGems.string = cc.vv.userMgr.gems;
        this.lblID.string = "ID:" + cc.vv.userMgr.userId;
    },

    onBtnClicked: function onBtnClicked(event) {
        if (event.target.name == "btn_shezhi") {
            this.settingsWin.active = true;
        } else if (event.target.name == "btn_help") {
            this.helpWin.active = true;
        } else if (event.target.name == "btn_xiaoxi") {
            this.xiaoxiWin.active = true;
        } else if (event.target.name == "head") {
            cc.vv.userinfoShow.show(cc.vv.userMgr.userName, cc.vv.userMgr.userId, this.sprHeadImg, cc.vv.userMgr.sex, cc.vv.userMgr.ip);
        }
    },

    onJoinGameClicked: function onJoinGameClicked() {
        this.joinGameWin.active = true;
    },

    onReturnGameClicked: function onReturnGameClicked() {
        cc.director.loadScene("mjgame");
    },

    onBtnAddGemsClicked: function onBtnAddGemsClicked() {
        cc.vv.alert.show("提示", cc.vv.userMgr.gemstip.msg);
        this.refreshInfo();
    },

    onCreateRoomClicked: function onCreateRoomClicked() {
        if (cc.vv.gameNetMgr.roomId != null) {
            cc.vv.alert.show("提示", "房间已经创建!\n必须解散当前房间才能创建新的房间");
            return;
        }
        console.log("onCreateRoomClicked");
        this.createRoomWin.active = true;
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        var x = this.lblNotice.node.x;
        x -= dt * 100;
        if (x + this.lblNotice.node.width < -1000) {
            x = 500;
        }
        this.lblNotice.node.x = x;

        if (cc.vv && cc.vv.userMgr.roomData != null) {
            cc.vv.userMgr.enterRoom(cc.vv.userMgr.roomData);
            cc.vv.userMgr.roomData = null;
        }
    }
});

cc._RF.pop();
},{"Global":"Global","Net":"Net"}],"History":[function(require,module,exports){
(function (Buffer){
"use strict";
cc._RF.push(module, '4d7bci0LUxMT6MJKXJDj89w', 'History');
// scripts/components/History.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        HistoryItemPrefab: {
            default: null,
            type: cc.Prefab
        },
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _history: null,
        _viewlist: null,
        _content: null,
        _viewitemTemp: null,
        _historyData: null,
        _curRoomInfo: null,
        _emptyTip: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        this._history = this.node.getChildByName("history");
        this._history.active = false;

        this._emptyTip = this._history.getChildByName("emptyTip");
        this._emptyTip.active = true;

        this._viewlist = this._history.getChildByName("viewlist");
        this._content = cc.find("view/content", this._viewlist);

        this._viewitemTemp = this._content.children[0];
        this._content.removeChild(this._viewitemTemp);

        var node = cc.find("Canvas/btn_zhanji");
        this.addClickEvent(node, this.node, "History", "onBtnHistoryClicked");

        var node = cc.find("Canvas/history/btn_back");
        this.addClickEvent(node, this.node, "History", "onBtnBackClicked");
    },

    addClickEvent: function addClickEvent(node, target, component, handler) {
        var eventHandler = new cc.Component.EventHandler();
        eventHandler.target = target;
        eventHandler.component = component;
        eventHandler.handler = handler;

        var clickEvents = node.getComponent(cc.Button).clickEvents;
        clickEvents.push(eventHandler);
    },

    onBtnBackClicked: function onBtnBackClicked() {
        if (this._curRoomInfo == null) {
            this._historyData = null;
            this._history.active = false;
        } else {
            this.initRoomHistoryList(this._historyData);
        }
    },

    onBtnHistoryClicked: function onBtnHistoryClicked() {
        this._history.active = true;
        var self = this;
        cc.vv.userMgr.getHistoryList(function (data) {
            data.sort(function (a, b) {
                return a.time < b.time;
            });
            self._historyData = data;
            for (var i = 0; i < data.length; ++i) {
                for (var j = 0; j < 4; ++j) {
                    var s = data[i].seats[j];
                    s.name = new Buffer(s.name, 'base64').toString();
                }
            }
            self.initRoomHistoryList(data);
        });
    },

    dateFormat: function dateFormat(time) {
        var date = new Date(time);
        var datetime = "{0}-{1}-{2} {3}:{4}:{5}";
        var year = date.getFullYear();
        var month = date.getMonth() + 1;
        month = month >= 10 ? month : "0" + month;
        var day = date.getDate();
        day = day >= 10 ? day : "0" + day;
        var h = date.getHours();
        h = h >= 10 ? h : "0" + h;
        var m = date.getMinutes();
        m = m >= 10 ? m : "0" + m;
        var s = date.getSeconds();
        s = s >= 10 ? s : "0" + s;
        datetime = datetime.format(year, month, day, h, m, s);
        return datetime;
    },

    initRoomHistoryList: function initRoomHistoryList(data) {
        for (var i = 0; i < data.length; ++i) {
            var node = this.getViewItem(i);
            node.idx = i;
            var titleId = "" + (i + 1);
            node.getChildByName("title").getComponent(cc.Label).string = titleId;
            node.getChildByName("roomNo").getComponent(cc.Label).string = "房间ID:" + data[i].id;
            var datetime = this.dateFormat(data[i].time * 1000);
            node.getChildByName("time").getComponent(cc.Label).string = datetime;

            var btnOp = node.getChildByName("btnOp");
            btnOp.idx = i;
            btnOp.getChildByName("Label").getComponent(cc.Label).string = "详情";

            for (var j = 0; j < 4; ++j) {
                var s = data[i].seats[j];
                var info = s.name + ":" + s.score;
                //console.log(info);
                node.getChildByName("info" + j).getComponent(cc.Label).string = info;
            }
        }
        this._emptyTip.active = data.length == 0;
        this.shrinkContent(data.length);
        this._curRoomInfo = null;
    },

    initGameHistoryList: function initGameHistoryList(roomInfo, data) {
        data.sort(function (a, b) {
            return a.create_time < b.create_time;
        });
        for (var i = 0; i < data.length; ++i) {
            var node = this.getViewItem(i);
            var idx = data.length - i - 1;
            node.idx = idx;
            var titleId = "" + (idx + 1);
            node.getChildByName("title").getComponent(cc.Label).string = titleId;
            node.getChildByName("roomNo").getComponent(cc.Label).string = "房间ID:" + roomInfo.id;
            var datetime = this.dateFormat(data[i].create_time * 1000);
            node.getChildByName("time").getComponent(cc.Label).string = datetime;

            var btnOp = node.getChildByName("btnOp");
            btnOp.idx = idx;
            btnOp.getChildByName("Label").getComponent(cc.Label).string = "回放";

            var result = JSON.parse(data[i].result);
            for (var j = 0; j < 4; ++j) {
                var s = roomInfo.seats[j];
                var info = s.name + ":" + result[j];
                //console.log(info);
                node.getChildByName("info" + j).getComponent(cc.Label).string = info;
            }
        }
        this.shrinkContent(data.length);
        this._curRoomInfo = roomInfo;
    },

    getViewItem: function getViewItem(index) {
        var content = this._content;
        if (content.childrenCount > index) {
            return content.children[index];
        }
        var node = cc.instantiate(this._viewitemTemp);
        content.addChild(node);
        return node;
    },
    shrinkContent: function shrinkContent(num) {
        while (this._content.childrenCount > num) {
            var lastOne = this._content.children[this._content.childrenCount - 1];
            this._content.removeChild(lastOne, true);
        }
    },

    getGameListOfRoom: function getGameListOfRoom(idx) {
        var self = this;
        var roomInfo = this._historyData[idx];
        cc.vv.userMgr.getGamesOfRoom(roomInfo.uuid, function (data) {
            if (data != null && data.length > 0) {
                self.initGameHistoryList(roomInfo, data);
            }
        });
    },

    getDetailOfGame: function getDetailOfGame(idx) {
        var self = this;
        var roomUUID = this._curRoomInfo.uuid;
        cc.vv.userMgr.getDetailOfGame(roomUUID, idx, function (data) {
            data.base_info = JSON.parse(data.base_info);
            data.action_records = JSON.parse(data.action_records);
            cc.vv.gameNetMgr.prepareReplay(self._curRoomInfo, data);
            cc.vv.replayMgr.init(data);
            cc.director.loadScene("mjgame");
        });
    },

    onViewItemClicked: function onViewItemClicked(event) {
        var idx = event.target.idx;
        console.log(idx);
        if (this._curRoomInfo == null) {
            this.getGameListOfRoom(idx);
        } else {
            this.getDetailOfGame(idx);
        }
    },

    onBtnOpClicked: function onBtnOpClicked(event) {
        var idx = event.target.parent.idx;
        console.log(idx);
        if (this._curRoomInfo == null) {
            this.getGameListOfRoom(idx);
        } else {
            this.getDetailOfGame(idx);
        }
    }

});

cc._RF.pop();
}).call(this,require("buffer").Buffer)

},{"buffer":2}],"HotUpdate":[function(require,module,exports){
"use strict";
cc._RF.push(module, '17141EodNRM/4IpsE04IyCU', 'HotUpdate');
// scripts/HotUpdate.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        updatePanel: {
            default: null,
            type: cc.Node
        },
        manifestUrl: {
            default: null,
            url: cc.RawAsset
        },
        percent: {
            default: null,
            type: cc.Label
        },
        lblErr: {
            default: null,
            type: cc.Label
        }
    },

    checkCb: function checkCb(event) {
        cc.log('Code: ' + event.getEventCode());
        switch (event.getEventCode()) {
            case jsb.EventAssetsManager.ERROR_NO_LOCAL_MANIFEST:
                cc.log("No local manifest file found, hot update skipped.");
                cc.eventManager.removeListener(this._checkListener);
                break;
            case jsb.EventAssetsManager.ERROR_DOWNLOAD_MANIFEST:
            case jsb.EventAssetsManager.ERROR_PARSE_MANIFEST:
                cc.log("Fail to download manifest file, hot update skipped.");
                cc.eventManager.removeListener(this._checkListener);
                break;
            case jsb.EventAssetsManager.ALREADY_UP_TO_DATE:
                cc.log("Already up to date with the latest remote version.");
                cc.eventManager.removeListener(this._checkListener);
                this.lblErr.string += "游戏不需要更新\n";
                cc.director.loadScene("loading");
                break;
            case jsb.EventAssetsManager.NEW_VERSION_FOUND:
                this._needUpdate = true;
                this.updatePanel.active = true;
                this.percent.string = '00.00%';
                cc.eventManager.removeListener(this._checkListener);
                break;
            default:
                break;
        }
        this.hotUpdate();
    },

    updateCb: function updateCb(event) {
        var needRestart = false;
        var failed = false;
        switch (event.getEventCode()) {
            case jsb.EventAssetsManager.ERROR_NO_LOCAL_MANIFEST:
                cc.log('No local manifest file found, hot update skipped.');
                failed = true;
                break;
            case jsb.EventAssetsManager.UPDATE_PROGRESSION:
                var percent = event.getPercent();
                var percentByFile = event.getPercentByFile();

                var msg = event.getMessage();
                if (msg) {
                    cc.log(msg);
                }
                cc.log(percent.toFixed(2) + '%');
                this.percent.string = percent + '%';
                break;
            case jsb.EventAssetsManager.ERROR_DOWNLOAD_MANIFEST:
            case jsb.EventAssetsManager.ERROR_PARSE_MANIFEST:
                cc.log('Fail to download manifest file, hot update skipped.');
                failed = true;
                break;
            case jsb.EventAssetsManager.ALREADY_UP_TO_DATE:
                cc.log('Already up to date with the latest remote version.');
                failed = true;
                break;
            case jsb.EventAssetsManager.UPDATE_FINISHED:
                cc.log('Update finished. ' + event.getMessage());

                needRestart = true;
                break;
            case jsb.EventAssetsManager.UPDATE_FAILED:
                cc.log('Update failed. ' + event.getMessage());

                this._failCount++;
                if (this._failCount < 5) {
                    this._am.downloadFailedAssets();
                } else {
                    cc.log('Reach maximum fail count, exit update process');
                    this._failCount = 0;
                    failed = true;
                }
                break;
            case jsb.EventAssetsManager.ERROR_UPDATING:
                cc.log('Asset update error: ' + event.getAssetId() + ', ' + event.getMessage());
                break;
            case jsb.EventAssetsManager.ERROR_DECOMPRESS:
                cc.log(event.getMessage());
                break;
            default:
                break;
        }

        if (failed) {
            cc.eventManager.removeListener(this._updateListener);
            this.updatePanel.active = false;
        }

        if (needRestart) {
            cc.eventManager.removeListener(this._updateListener);
            // Prepend the manifest's search path
            var searchPaths = jsb.fileUtils.getSearchPaths();
            var newPaths = this._am.getLocalManifest().getSearchPaths();
            Array.prototype.unshift(searchPaths, newPaths);
            // This value will be retrieved and appended to the default search path during game startup,
            // please refer to samples/js-tests/main.js for detailed usage.
            // !!! Re-add the search paths in main.js is very important, otherwise, new scripts won't take effect.
            cc.sys.localStorage.setItem('HotUpdateSearchPaths', JSON.stringify(searchPaths));

            jsb.fileUtils.setSearchPaths(searchPaths);
            this.lblErr.string += "游戏资源更新完毕\n";
            cc.game.restart();
        }
    },

    hotUpdate: function hotUpdate() {
        if (this._am && this._needUpdate) {
            this.lblErr.string += "开始更新游戏资源...\n";
            this._updateListener = new jsb.EventListenerAssetsManager(this._am, this.updateCb.bind(this));
            cc.eventManager.addListener(this._updateListener, 1);

            this._failCount = 0;
            this._am.update();
        }
    },

    // use this for initialization
    onLoad: function onLoad() {
        // Hot update is only available in Native build
        if (!cc.sys.isNative) {
            return;
        }
        this.lblErr.string += "检查游戏资源...\n";
        var storagePath = (jsb.fileUtils ? jsb.fileUtils.getWritablePath() : '/') + 'tiantianqipai-asset';
        cc.log('Storage path for remote asset : ' + storagePath);
        this.lblErr.string += storagePath + "\n";
        cc.log('Local manifest URL : ' + this.manifestUrl);
        this._am = new jsb.AssetsManager(this.manifestUrl, storagePath);
        this._am.retain();

        this._needUpdate = false;
        if (this._am.getLocalManifest().isLoaded()) {
            this._checkListener = new jsb.EventListenerAssetsManager(this._am, this.checkCb.bind(this));
            cc.eventManager.addListener(this._checkListener, 1);

            this._am.checkUpdate();
        }
    },

    onDestroy: function onDestroy() {
        this._am && this._am.release();
    }
});

cc._RF.pop();
},{}],"HuanSanZhang":[function(require,module,exports){
"use strict";
cc._RF.push(module, '9a096oAgU5HwrxX05ZPNYtW', 'HuanSanZhang');
// scripts/components/HuanSanZhang.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _huanpaitip: null,
        _huanpaiArr: []
    },

    // use this for initialization
    onLoad: function onLoad() {
        this._huanpaitip = cc.find("Canvas/huansanzhang");
        this._huanpaitip.active = cc.vv.gameNetMgr.isHuanSanZhang;

        if (this._huanpaitip.active) {
            this.showHuanpai(cc.vv.gameNetMgr.getSelfData().huanpais == null);
        }
        this.initHuaipaiInfo();

        var btnOk = cc.find("Canvas/huansanzhang/btn_ok");
        if (btnOk) {
            cc.vv.utils.addClickEvent(btnOk, this.node, "HuanSanZhang", "onHuanSanZhang");
        }

        var self = this;

        this.node.on('game_huanpai', function (data) {
            self._huanpaitip.active = true;
            self.showHuanpai(true);
        });

        this.node.on('huanpai_notify', function (data) {
            if (data.detail.seatindex == cc.vv.gameNetMgr.seatIndex) {
                self.initHuaipaiInfo();
            }
        });

        this.node.on('game_huanpai_over', function (data) {
            self._huanpaitip.active = false;
            for (var i = 0; i < self._huanpaiArr.length; ++i) {
                self._huanpaiArr[i].y = 0;
            }
            self._huanpaiArr = [];
            self.initHuaipaiInfo();
        });

        this.node.on('game_huanpai_result', function (data) {
            cc.vv.gameNetMgr.isHuanSanZhang = false;
            self._huanpaitip.active = false;
            for (var i = 0; i < self._huanpaiArr.length; ++i) {
                self._huanpaiArr[i].y = 0;
            }
            self._huanpaiArr = [];
        });

        this.node.on('mj_clicked', function (data) {
            var target = data.detail;
            //如果已经点起来，则取消
            var idx = self._huanpaiArr.indexOf(target);
            if (idx != -1) {
                target.y = 0;
                self._huanpaiArr.splice(idx, 1);
            } else {
                //如果是新的，则加入
                if (self._huanpaiArr.length < 3) {
                    self._huanpaiArr.push(target);
                    target.y = 15;
                }
            }
        });
    },

    showHuanpai: function showHuanpai(interactable) {
        this._huanpaitip.getChildByName("info").getComponent(cc.Label).string = "请选择三张一样花色的牌";
        this._huanpaitip.getChildByName("btn_ok").getComponent(cc.Button).interactable = interactable;
        this._huanpaitip.getChildByName("mask").active = false;
    },

    initHuaipaiInfo: function initHuaipaiInfo() {
        var huaipaiinfo = cc.find("Canvas/game/huanpaiinfo");
        var seat = cc.vv.gameNetMgr.getSelfData();
        if (seat.huanpais == null) {
            huaipaiinfo.active = false;
            return;
        }
        huaipaiinfo.active = true;
        for (var i = 0; i < seat.huanpais.length; ++i) {
            huaipaiinfo.getChildByName("hp" + (i + 1)).getComponent(cc.Sprite).spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", seat.huanpais[i]);
        }

        var hpm = huaipaiinfo.getChildByName("hpm");
        hpm.active = true;
        if (cc.vv.gameNetMgr.huanpaimethod == 0) {
            hpm.rotation = 90;
        } else if (cc.vv.gameNetMgr.huanpaimethod == 1) {
            hpm.rotation = 0;
        } else if (cc.vv.gameNetMgr.huanpaimethod == 2) {
            hpm.rotation = 180;
        } else {
            hpm.active = false;
        }
    },

    onHuanSanZhang: function onHuanSanZhang(event) {
        if (this._huanpaiArr.length != 3) {
            return;
        }

        var type = null;
        for (var i = 0; i < this._huanpaiArr.length; ++i) {
            var pai = this._huanpaiArr[i].mjId;
            var nt = cc.vv.mahjongmgr.getMahjongType(pai);
            if (type == null) {
                type = nt;
            } else {
                if (type != nt) {
                    return;
                }
            }
        }

        var data = {
            p1: this._huanpaiArr[0].mjId,
            p2: this._huanpaiArr[1].mjId,
            p3: this._huanpaiArr[2].mjId
        };

        this._huanpaitip.getChildByName("info").getComponent(cc.Label).string = "等待其他玩家选牌...";
        this._huanpaitip.getChildByName("btn_ok").getComponent(cc.Button).interactable = false;
        this._huanpaitip.getChildByName("mask").active = true;

        cc.vv.net.send("huanpai", data);
    }

});

cc._RF.pop();
},{}],"ImageLoader":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'ed057Bgp8FHlJbGI+ljAN7d', 'ImageLoader');
// scripts/components/ImageLoader.js

"use strict";

function loadImage(url, code, callback) {
    /*
    if(cc.vv.images == null){
        cc.vv.images = {};
    }
    var imageInfo = cc.vv.images[url];
    if(imageInfo == null){
        imageInfo = {
            image:null,
            queue:[],
        };
        cc.vv.images[url] = imageInfo;
    }
    
    cc.loader.load(url,function (err,tex) {
        imageInfo.image = tex;
        var spriteFrame = new cc.SpriteFrame(tex, cc.Rect(0, 0, tex.width, tex.height));
        for(var i = 0; i < imageInfo.queue.length; ++i){
            var itm = imageInfo.queue[i];
            itm.callback(itm.code,spriteFrame);
        }
        itm.queue = [];
    });
    if(imageInfo.image != null){
        var tex = imageInfo.image;
        var spriteFrame = new cc.SpriteFrame(tex, cc.Rect(0, 0, tex.width, tex.height));
        callback(code,spriteFrame);
    }
    else{
        imageInfo.queue.push({code:code,callback:callback});
    }*/
    cc.loader.load(url, function (err, tex) {
        var spriteFrame = new cc.SpriteFrame(tex, cc.Rect(0, 0, tex.width, tex.height));
        callback(code, spriteFrame);
    });
};

function getBaseInfo(userid, callback) {
    if (cc.vv.baseInfoMap == null) {
        cc.vv.baseInfoMap = {};
    }

    if (cc.vv.baseInfoMap[userid] != null) {
        callback(userid, cc.vv.baseInfoMap[userid]);
    } else {
        cc.vv.http.sendRequest('/base_info', { userid: userid }, function (ret) {
            var url = null;
            if (ret.headimgurl) {
                url = ret.headimgurl + ".jpg";
            }
            var info = {
                name: ret.name,
                sex: ret.sex,
                url: url
            };
            cc.vv.baseInfoMap[userid] = info;
            callback(userid, info);
        }, cc.vv.http.master_url);
    }
};

cc.Class({
    extends: cc.Component,
    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.setupSpriteFrame();
    },

    setUserID: function setUserID(userid) {
        if (cc.sys.isNative == false) {
            return;
        }
        if (!userid) {
            return;
        }
        if (cc.vv.images == null) {
            cc.vv.images = {};
        }

        var self = this;
        getBaseInfo(userid, function (code, info) {
            if (info && info.url) {
                loadImage(info.url, userid, function (err, spriteFrame) {
                    self._spriteFrame = spriteFrame;
                    self.setupSpriteFrame();
                });
            }
        });
    },

    setupSpriteFrame: function setupSpriteFrame() {
        if (this._spriteFrame) {
            var spr = this.getComponent(cc.Sprite);
            if (spr) {
                spr.spriteFrame = this._spriteFrame;
            }
        }
    }
    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"JoinGameInput":[function(require,module,exports){
"use strict";
cc._RF.push(module, '10a1c8jz95Ju4NnpkOWUfin', 'JoinGameInput');
// scripts/components/JoinGameInput.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        nums: {
            default: [],
            type: [cc.Label]
        },
        _inputIndex: 0
    },

    // use this for initialization
    onLoad: function onLoad() {},

    onEnable: function onEnable() {
        this.onResetClicked();
    },

    onInputFinished: function onInputFinished(roomId) {
        cc.vv.userMgr.enterRoom(roomId, function (ret) {
            if (ret.errcode == 0) {
                this.node.active = false;
            } else {
                var content = "房间[" + roomId + "]不存在，请重新输入!";
                if (ret.errcode == 4) {
                    content = "房间[" + roomId + "]已满!";
                }
                cc.vv.alert.show("提示", content);
                this.onResetClicked();
            }
        }.bind(this));
    },

    onInput: function onInput(num) {
        if (this._inputIndex >= this.nums.length) {
            return;
        }
        this.nums[this._inputIndex].string = num;
        this._inputIndex += 1;

        if (this._inputIndex == this.nums.length) {
            var roomId = this.parseRoomID();
            console.log("ok:" + roomId);
            this.onInputFinished(roomId);
        }
    },

    onN0Clicked: function onN0Clicked() {
        this.onInput(0);
    },
    onN1Clicked: function onN1Clicked() {
        this.onInput(1);
    },
    onN2Clicked: function onN2Clicked() {
        this.onInput(2);
    },
    onN3Clicked: function onN3Clicked() {
        this.onInput(3);
    },
    onN4Clicked: function onN4Clicked() {
        this.onInput(4);
    },
    onN5Clicked: function onN5Clicked() {
        this.onInput(5);
    },
    onN6Clicked: function onN6Clicked() {
        this.onInput(6);
    },
    onN7Clicked: function onN7Clicked() {
        this.onInput(7);
    },
    onN8Clicked: function onN8Clicked() {
        this.onInput(8);
    },
    onN9Clicked: function onN9Clicked() {
        this.onInput(9);
    },
    onResetClicked: function onResetClicked() {
        for (var i = 0; i < this.nums.length; ++i) {
            this.nums[i].string = "";
        }
        this._inputIndex = 0;
    },
    onDelClicked: function onDelClicked() {
        if (this._inputIndex > 0) {
            this._inputIndex -= 1;
            this.nums[this._inputIndex].string = "";
        }
    },
    onCloseClicked: function onCloseClicked() {
        this.node.active = false;
    },

    parseRoomID: function parseRoomID() {
        var str = "";
        for (var i = 0; i < this.nums.length; ++i) {
            str += this.nums[i].string;
        }
        return str;
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"LoadingLogic":[function(require,module,exports){
"use strict";
cc._RF.push(module, '350d3Ry9aVIqJR27fP2H/z1', 'LoadingLogic');
// scripts/components/LoadingLogic.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        tipLabel: cc.Label,
        _stateStr: '',
        _progress: 0.0,
        _splash: null,
        _isLoading: false
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (!cc.sys.isNative && cc.sys.isMobile) {
            var cvs = this.node.getComponent(cc.Canvas);
            cvs.fitHeight = true;
            cvs.fitWidth = true;
        }
        this.initMgr();
        this.tipLabel.string = this._stateStr;

        this._splash = cc.find("Canvas/splash");
        this._splash.active = true;
    },

    start: function start() {
        var self = this;
        var SHOW_TIME = 3000;
        var FADE_TIME = 500;
        if (cc.sys.os != cc.sys.OS_IOS || !cc.sys.isNative) {
            self._splash.active = true;
            var t = Date.now();
            var fn = function fn() {
                var dt = Date.now() - t;
                if (dt < SHOW_TIME) {
                    setTimeout(fn, 33);
                } else {
                    var op = (1 - (dt - SHOW_TIME) / FADE_TIME) * 255;
                    if (op < 0) {
                        self._splash.opacity = 0;
                        self.checkVersion();
                    } else {
                        self._splash.opacity = op;
                        setTimeout(fn, 33);
                    }
                }
            };
            setTimeout(fn, 33);
        } else {
            this._splash.active = false;
            this.checkVersion();
        }
    },

    initMgr: function initMgr() {
        cc.vv = {};
        var UserMgr = require("UserMgr");
        cc.vv.userMgr = new UserMgr();

        var ReplayMgr = require("ReplayMgr");
        cc.vv.replayMgr = new ReplayMgr();

        cc.vv.http = require("HTTP");
        cc.vv.global = require("Global");
        cc.vv.net = require("Net");

        var GameNetMgr = require("GameNetMgr");
        cc.vv.gameNetMgr = new GameNetMgr();
        cc.vv.gameNetMgr.initHandlers();

        var AnysdkMgr = require("AnysdkMgr");
        cc.vv.anysdkMgr = new AnysdkMgr();
        cc.vv.anysdkMgr.init();

        var VoiceMgr = require("VoiceMgr");
        cc.vv.voiceMgr = new VoiceMgr();
        cc.vv.voiceMgr.init();

        var AudioMgr = require("AudioMgr");
        cc.vv.audioMgr = new AudioMgr();
        cc.vv.audioMgr.init();

        var Utils = require("Utils");
        cc.vv.utils = new Utils();

        cc.args = this.urlParse();
    },

    urlParse: function urlParse() {
        var params = {};
        if (window.location == null) {
            return params;
        }
        var name, value;
        var str = window.location.href; //取得整个地址栏
        var num = str.indexOf("?");
        str = str.substr(num + 1); //取得所有参数   stringvar.substr(start [, length ]

        var arr = str.split("&"); //各个参数放到数组里
        for (var i = 0; i < arr.length; i++) {
            num = arr[i].indexOf("=");
            if (num > 0) {
                name = arr[i].substring(0, num);
                value = arr[i].substr(num + 1);
                params[name] = value;
            }
        }
        return params;
    },

    checkVersion: function checkVersion() {
        var self = this;
        var onGetVersion = function onGetVersion(ret) {
            if (ret.version == null) {
                console.log("error.");
            } else {
                cc.vv.SI = ret;
                if (ret.version != cc.VERSION) {
                    cc.find("Canvas/alert").active = true;
                } else {
                    self.startPreloading();
                }
            }
        };

        var xhr = null;
        var complete = false;
        var fnRequest = function fnRequest() {
            self._stateStr = "正在连接服务器";
            xhr = cc.vv.http.sendRequest("/get_serverinfo", null, function (ret) {
                xhr = null;
                complete = true;
                onGetVersion(ret);
            });
            setTimeout(fn, 5000);
        };

        var fn = function fn() {
            if (!complete) {
                if (xhr) {
                    xhr.abort();
                    self._stateStr = "连接失败，即将重试";
                    setTimeout(function () {
                        fnRequest();
                    }, 5000);
                } else {
                    fnRequest();
                }
            }
        };
        fn();
    },

    onBtnDownloadClicked: function onBtnDownloadClicked() {
        cc.sys.openURL(cc.vv.SI.appweb);
    },

    startPreloading: function startPreloading() {
        this._stateStr = "正在加载资源，请稍候";
        this._isLoading = true;
        var self = this;

        cc.loader.onProgress = function (completedCount, totalCount, item) {
            //console.log("completedCount:" + completedCount + ",totalCount:" + totalCount );
            if (self._isLoading) {
                self._progress = completedCount / totalCount;
            }
        };

        cc.loader.loadResAll("textures", function (err, assets) {
            self.onLoadComplete();
        });
    },

    onLoadComplete: function onLoadComplete() {
        this._isLoading = false;
        this._stateStr = "准备登陆";
        cc.director.loadScene("login");
        cc.loader.onComplete = null;
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        if (this._stateStr.length == 0) {
            return;
        }
        this.tipLabel.string = this._stateStr + ' ';
        if (this._isLoading) {
            this.tipLabel.string += Math.floor(this._progress * 100) + "%";
        } else {
            var t = Math.floor(Date.now() / 1000) % 4;
            for (var i = 0; i < t; ++i) {
                this.tipLabel.string += '.';
            }
        }
    }
});

cc._RF.pop();
},{"AnysdkMgr":"AnysdkMgr","AudioMgr":"AudioMgr","GameNetMgr":"GameNetMgr","Global":"Global","HTTP":"HTTP","Net":"Net","ReplayMgr":"ReplayMgr","UserMgr":"UserMgr","Utils":"Utils","VoiceMgr":"VoiceMgr"}],"Login":[function(require,module,exports){
"use strict";
cc._RF.push(module, '572a7Qfh69N9ZLXkNthANfi', 'Login');
// scripts/components/Login.js

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

String.prototype.format = function (args) {
    if (arguments.length > 0) {
        var result = this;
        if (arguments.length == 1 && (typeof args === "undefined" ? "undefined" : _typeof(args)) == "object") {
            for (var key in args) {
                var reg = new RegExp("({" + key + "})", "g");
                result = result.replace(reg, args[key]);
            }
        } else {
            for (var i = 0; i < arguments.length; i++) {
                if (arguments[i] == undefined) {
                    return "";
                } else {
                    var reg = new RegExp("({[" + i + "]})", "g");
                    result = result.replace(reg, arguments[i]);
                }
            }
        }
        return result;
    } else {
        return this;
    }
};

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _mima: null,
        _mimaIndex: 0
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (!cc.sys.isNative && cc.sys.isMobile) {
            var cvs = this.node.getComponent(cc.Canvas);
            cvs.fitHeight = true;
            cvs.fitWidth = true;
        }

        if (!cc.vv) {
            cc.director.loadScene("loading");
            return;
        }
        cc.vv.http.url = cc.vv.http.master_url;
        cc.vv.net.addHandler('push_need_create_role', function () {
            console.log("onLoad:push_need_create_role");
            cc.director.loadScene("createrole");
        });

        cc.vv.audioMgr.playBGM("bgMain.mp3");

        this._mima = ["A", "A", "B", "B", "A", "B", "A", "B", "A", "A", "A", "B", "B", "B"];

        if (!cc.sys.isNative || cc.sys.os == cc.sys.OS_WINDOWS) {
            cc.find("Canvas/btn_yk").active = true;
        }
    },

    start: function start() {
        var account = cc.sys.localStorage.getItem("wx_account");
        var sign = cc.sys.localStorage.getItem("wx_sign");
        if (account != null && sign != null) {
            var ret = {
                errcode: 0,
                account: account,
                sign: sign
            };
            cc.vv.userMgr.onAuth(ret);
        }
    },

    onBtnQuickStartClicked: function onBtnQuickStartClicked() {
        cc.vv.userMgr.guestAuth();
    },

    onBtnWeichatClicked: function onBtnWeichatClicked() {
        var self = this;
        cc.vv.anysdkMgr.login();
    },

    onBtnMIMAClicked: function onBtnMIMAClicked(event) {
        if (this._mima[this._mimaIndex] == event.target.name) {
            this._mimaIndex++;
            if (this._mimaIndex == this._mima.length) {
                cc.find("Canvas/btn_yk").active = true;
            }
        } else {
            console.log("oh ho~~~");
            this._mimaIndex = 0;
        }
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"MJGame":[function(require,module,exports){
"use strict";
cc._RF.push(module, '7fa8fcvrqFOj6lhh6xHzd3c', 'MJGame');
// scripts/components/MJGame.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        gameRoot: {
            default: null,
            type: cc.Node
        },

        prepareRoot: {
            default: null,
            type: cc.Node
        },

        _myMJArr: [],
        _options: null,
        _selectedMJ: null,
        _chupaiSprite: [],
        _mjcount: null,
        _gamecount: null,
        _hupaiTips: [],
        _hupaiLists: [],
        _playEfxs: [],
        _opts: []
    },

    onLoad: function onLoad() {
        if (!cc.sys.isNative && cc.sys.isMobile) {
            var cvs = this.node.getComponent(cc.Canvas);
            cvs.fitHeight = true;
            cvs.fitWidth = true;
        }
        if (!cc.vv) {
            cc.director.loadScene("loading");
            return;
        }
        this.addComponent("NoticeTip");
        this.addComponent("GameOver");
        this.addComponent("DingQue");
        this.addComponent("PengGangs");
        this.addComponent("MJRoom");
        this.addComponent("TimePointer");
        this.addComponent("GameResult");
        this.addComponent("Chat");
        this.addComponent("Folds");
        this.addComponent("ReplayCtrl");
        this.addComponent("PopupMgr");
        this.addComponent("HuanSanZhang");
        this.addComponent("ReConnect");
        this.addComponent("Voice");
        this.addComponent("UserInfoShow");

        this.initView();
        this.initEventHandlers();

        this.gameRoot.active = false;
        this.prepareRoot.active = true;
        this.initWanfaLabel();
        this.onGameBeign();
        cc.vv.audioMgr.playBGM("bgFight.mp3");
    },

    initView: function initView() {

        //搜索需要的子节点
        var gameChild = this.node.getChildByName("game");

        this._mjcount = gameChild.getChildByName('mjcount').getComponent(cc.Label);
        this._mjcount.string = "剩余" + cc.vv.gameNetMgr.numOfMJ + "张";
        this._gamecount = gameChild.getChildByName('gamecount').getComponent(cc.Label);
        this._gamecount.string = "" + cc.vv.gameNetMgr.numOfGames + "/" + cc.vv.gameNetMgr.maxNumOfGames + "局";

        var myselfChild = gameChild.getChildByName("myself");
        var myholds = myselfChild.getChildByName("holds");

        for (var i = 0; i < myholds.children.length; ++i) {
            var sprite = myholds.children[i].getComponent(cc.Sprite);
            this._myMJArr.push(sprite);
            sprite.spriteFrame = null;
        }

        var realwidth = cc.director.getVisibleSize().width;
        myholds.scaleX *= realwidth / 1280;
        myholds.scaleY *= realwidth / 1280;

        var sides = ["myself", "right", "up", "left"];
        for (var i = 0; i < sides.length; ++i) {
            var side = sides[i];

            var sideChild = gameChild.getChildByName(side);
            this._hupaiTips.push(sideChild.getChildByName("HuPai"));
            this._hupaiLists.push(sideChild.getChildByName("hupailist"));
            this._playEfxs.push(sideChild.getChildByName("play_efx").getComponent(cc.Animation));
            this._chupaiSprite.push(sideChild.getChildByName("ChuPai").children[0].getComponent(cc.Sprite));

            var opt = sideChild.getChildByName("opt");
            opt.active = false;
            var sprite = opt.getChildByName("pai").getComponent(cc.Sprite);
            var data = {
                node: opt,
                sprite: sprite
            };
            this._opts.push(data);
        }

        var opts = gameChild.getChildByName("ops");
        this._options = opts;
        this.hideOptions();
        this.hideChupai();
    },

    hideChupai: function hideChupai() {
        for (var i = 0; i < this._chupaiSprite.length; ++i) {
            this._chupaiSprite[i].node.active = false;
        }
    },

    initEventHandlers: function initEventHandlers() {
        cc.vv.gameNetMgr.dataEventHandler = this.node;

        //初始化事件监听器
        var self = this;

        this.node.on('game_holds', function (data) {
            self.initMahjongs();
            self.checkQueYiMen();
        });

        this.node.on('game_begin', function (data) {
            self.onGameBeign();
        });

        this.node.on('game_sync', function (data) {
            self.onGameBeign();
        });

        this.node.on('game_chupai', function (data) {
            data = data.detail;
            self.hideChupai();
            self.checkQueYiMen();
            if (data.last != cc.vv.gameNetMgr.seatIndex) {
                self.initMopai(data.last, null);
            }
            if (!cc.vv.replayMgr.isReplay() && data.turn != cc.vv.gameNetMgr.seatIndex) {
                self.initMopai(data.turn, -1);
            }
        });

        this.node.on('game_mopai', function (data) {
            self.hideChupai();
            data = data.detail;
            var pai = data.pai;
            var localIndex = cc.vv.gameNetMgr.getLocalIndex(data.seatIndex);
            if (localIndex == 0) {
                var index = 13;
                var sprite = self._myMJArr[index];
                self.setSpriteFrameByMJID("M_", sprite, pai, index);
                sprite.node.mjId = pai;
            } else if (cc.vv.replayMgr.isReplay()) {
                self.initMopai(data.seatIndex, pai);
            }
        });

        this.node.on('game_action', function (data) {
            self.showAction(data.detail);
        });

        this.node.on('hupai', function (data) {
            var data = data.detail;
            //如果不是玩家自己，则将玩家的牌都放倒
            var seatIndex = data.seatindex;
            var localIndex = cc.vv.gameNetMgr.getLocalIndex(seatIndex);
            var hupai = self._hupaiTips[localIndex];
            hupai.active = true;

            if (localIndex == 0) {
                self.hideOptions();
            }
            var seatData = cc.vv.gameNetMgr.seats[seatIndex];
            seatData.hued = true;
            if (cc.vv.gameNetMgr.conf.type == "xlch") {
                hupai.getChildByName("sprHu").active = true;
                hupai.getChildByName("sprZimo").active = false;
                self.initHupai(localIndex, data.hupai);
                if (data.iszimo) {
                    if (seatData.seatindex == cc.vv.gameNetMgr.seatIndex) {
                        seatData.holds.pop();
                        self.initMahjongs();
                    } else {
                        self.initOtherMahjongs(seatData);
                    }
                }
            } else {
                hupai.getChildByName("sprHu").active = !data.iszimo;
                hupai.getChildByName("sprZimo").active = data.iszimo;

                if (!(data.iszimo && localIndex == 0)) {
                    //if(cc.vv.replayMgr.isReplay() == false && localIndex != 0){
                    //    self.initEmptySprites(seatIndex);                
                    //}
                    self.initMopai(seatIndex, data.hupai);
                }
            }

            if (cc.vv.replayMgr.isReplay() == true && cc.vv.gameNetMgr.conf.type != "xlch") {
                var opt = self._opts[localIndex];
                opt.node.active = true;
                opt.sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", data.hupai);
            }

            if (data.iszimo) {
                self.playEfx(localIndex, "play_zimo");
            } else {
                self.playEfx(localIndex, "play_hu");
            }

            cc.vv.audioMgr.playSFX("nv/hu.mp3");
        });

        this.node.on('mj_count', function (data) {
            self._mjcount.string = "剩余" + cc.vv.gameNetMgr.numOfMJ + "张";
        });

        this.node.on('game_num', function (data) {
            self._gamecount.string = "" + cc.vv.gameNetMgr.numOfGames + "/" + cc.vv.gameNetMgr.maxNumOfGames + "局";
        });

        this.node.on('game_over', function (data) {
            self.gameRoot.active = false;
            self.prepareRoot.active = true;
        });

        this.node.on('game_chupai_notify', function (data) {
            self.hideChupai();
            var seatData = data.detail.seatData;
            //如果是自己，则刷新手牌
            if (seatData.seatindex == cc.vv.gameNetMgr.seatIndex) {
                self.initMahjongs();
            } else {
                self.initOtherMahjongs(seatData);
            }
            self.showChupai();
            var audioUrl = cc.vv.mahjongmgr.getAudioURLByMJID(data.detail.pai);
            cc.vv.audioMgr.playSFX(audioUrl);
        });

        this.node.on('guo_notify', function (data) {
            self.hideChupai();
            self.hideOptions();
            var seatData = data.detail;
            //如果是自己，则刷新手牌
            if (seatData.seatindex == cc.vv.gameNetMgr.seatIndex) {
                self.initMahjongs();
            }
            cc.vv.audioMgr.playSFX("give.mp3");
        });

        this.node.on('guo_result', function (data) {
            self.hideOptions();
        });

        this.node.on('game_dingque_finish', function (data) {
            self.initMahjongs();
        });

        this.node.on('peng_notify', function (data) {
            self.hideChupai();

            var seatData = data.detail;
            if (seatData.seatindex == cc.vv.gameNetMgr.seatIndex) {
                self.initMahjongs();
            } else {
                self.initOtherMahjongs(seatData);
            }
            var localIndex = self.getLocalIndex(seatData.seatindex);
            self.playEfx(localIndex, "play_peng");
            cc.vv.audioMgr.playSFX("nv/peng.mp3");
            self.hideOptions();
        });

        this.node.on('gang_notify', function (data) {
            self.hideChupai();
            var data = data.detail;
            var seatData = data.seatData;
            var gangtype = data.gangtype;
            if (seatData.seatindex == cc.vv.gameNetMgr.seatIndex) {
                self.initMahjongs();
            } else {
                self.initOtherMahjongs(seatData);
            }

            var localIndex = self.getLocalIndex(seatData.seatindex);
            if (gangtype == "wangang") {
                self.playEfx(localIndex, "play_guafeng");
                cc.vv.audioMgr.playSFX("guafeng.mp3");
            } else {
                self.playEfx(localIndex, "play_xiayu");
                cc.vv.audioMgr.playSFX("rain.mp3");
            }
        });

        this.node.on("hangang_notify", function (data) {
            var data = data.detail;
            var localIndex = self.getLocalIndex(data);
            self.playEfx(localIndex, "play_gang");
            cc.vv.audioMgr.playSFX("nv/gang.mp3");
            self.hideOptions();
        });
    },

    showChupai: function showChupai() {
        var pai = cc.vv.gameNetMgr.chupai;
        if (pai >= 0) {
            //
            var localIndex = this.getLocalIndex(cc.vv.gameNetMgr.turn);
            var sprite = this._chupaiSprite[localIndex];
            sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", pai);
            sprite.node.active = true;
        }
    },

    addOption: function addOption(btnName, pai) {
        for (var i = 0; i < this._options.childrenCount; ++i) {
            var child = this._options.children[i];
            if (child.name == "op" && child.active == false) {
                child.active = true;
                var sprite = child.getChildByName("opTarget").getComponent(cc.Sprite);
                sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", pai);
                var btn = child.getChildByName(btnName);
                btn.active = true;
                btn.pai = pai;
                return;
            }
        }
    },

    hideOptions: function hideOptions(data) {
        this._options.active = false;
        for (var i = 0; i < this._options.childrenCount; ++i) {
            var child = this._options.children[i];
            if (child.name == "op") {
                child.active = false;
                child.getChildByName("btnPeng").active = false;
                child.getChildByName("btnGang").active = false;
                child.getChildByName("btnHu").active = false;
            }
        }
    },

    showAction: function showAction(data) {
        if (this._options.active) {
            this.hideOptions();
        }

        if (data && (data.hu || data.gang || data.peng)) {
            this._options.active = true;
            if (data.hu) {
                this.addOption("btnHu", data.pai);
            }
            if (data.peng) {
                this.addOption("btnPeng", data.pai);
            }

            if (data.gang) {
                for (var i = 0; i < data.gangpai.length; ++i) {
                    var gp = data.gangpai[i];
                    this.addOption("btnGang", gp);
                }
            }
        }
    },

    initWanfaLabel: function initWanfaLabel() {
        var wanfa = cc.find("Canvas/infobar/wanfa").getComponent(cc.Label);
        wanfa.string = cc.vv.gameNetMgr.getWanfa();
    },

    initHupai: function initHupai(localIndex, pai) {
        if (cc.vv.gameNetMgr.conf.type == "xlch") {
            var hupailist = this._hupaiLists[localIndex];
            for (var i = 0; i < hupailist.children.length; ++i) {
                var hupainode = hupailist.children[i];
                if (hupainode.active == false) {
                    var pre = cc.vv.mahjongmgr.getFoldPre(localIndex);
                    hupainode.getComponent(cc.Sprite).spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID(pre, pai);
                    hupainode.active = true;
                    break;
                }
            }
        }
    },

    playEfx: function playEfx(index, name) {
        this._playEfxs[index].node.active = true;
        this._playEfxs[index].play(name);
    },

    onGameBeign: function onGameBeign() {

        for (var i = 0; i < this._playEfxs.length; ++i) {
            this._playEfxs[i].node.active = false;
        }

        for (var i = 0; i < this._hupaiLists.length; ++i) {
            for (var j = 0; j < this._hupaiLists[i].childrenCount; ++j) {
                this._hupaiLists[i].children[j].active = false;
            }
        }

        for (var i = 0; i < cc.vv.gameNetMgr.seats.length; ++i) {
            var seatData = cc.vv.gameNetMgr.seats[i];
            var localIndex = cc.vv.gameNetMgr.getLocalIndex(i);
            var hupai = this._hupaiTips[localIndex];
            hupai.active = seatData.hued;
            if (seatData.hued) {
                hupai.getChildByName("sprHu").active = !seatData.iszimo;
                hupai.getChildByName("sprZimo").active = seatData.iszimo;
            }

            if (seatData.huinfo) {
                for (var j = 0; j < seatData.huinfo.length; ++j) {
                    var info = seatData.huinfo[j];
                    if (info.ishupai) {
                        this.initHupai(localIndex, info.pai);
                    }
                }
            }
        }

        this.hideChupai();
        this.hideOptions();
        var sides = ["right", "up", "left"];
        var gameChild = this.node.getChildByName("game");
        for (var i = 0; i < sides.length; ++i) {
            var sideChild = gameChild.getChildByName(sides[i]);
            var holds = sideChild.getChildByName("holds");
            for (var j = 0; j < holds.childrenCount; ++j) {
                var nc = holds.children[j];
                nc.active = true;
                nc.scaleX = 1.0;
                nc.scaleY = 1.0;
                var sprite = nc.getComponent(cc.Sprite);
                sprite.spriteFrame = cc.vv.mahjongmgr.holdsEmpty[i + 1];
            }
        }

        if (cc.vv.gameNetMgr.gamestate == "" && cc.vv.replayMgr.isReplay() == false) {
            return;
        }

        this.gameRoot.active = true;
        this.prepareRoot.active = false;
        this.initMahjongs();
        var seats = cc.vv.gameNetMgr.seats;
        for (var i in seats) {
            var seatData = seats[i];
            var localIndex = cc.vv.gameNetMgr.getLocalIndex(i);
            if (localIndex != 0) {
                this.initOtherMahjongs(seatData);
                if (i == cc.vv.gameNetMgr.turn) {
                    this.initMopai(i, -1);
                } else {
                    this.initMopai(i, null);
                }
            }
        }
        this.showChupai();
        if (cc.vv.gameNetMgr.curaction != null) {
            this.showAction(cc.vv.gameNetMgr.curaction);
            cc.vv.gameNetMgr.curaction = null;
        }

        this.checkQueYiMen();
    },

    onMJClicked: function onMJClicked(event) {
        if (cc.vv.gameNetMgr.isHuanSanZhang) {
            this.node.emit("mj_clicked", event.target);
            return;
        }

        //如果不是自己的轮子，则忽略
        if (cc.vv.gameNetMgr.turn != cc.vv.gameNetMgr.seatIndex) {
            console.log("not your turn." + cc.vv.gameNetMgr.turn);
            return;
        }

        for (var i = 0; i < this._myMJArr.length; ++i) {
            if (event.target == this._myMJArr[i].node) {
                //如果是再次点击，则出牌
                if (event.target == this._selectedMJ) {
                    this.shoot(this._selectedMJ.mjId);
                    this._selectedMJ.y = 0;
                    this._selectedMJ = null;
                    return;
                }
                if (this._selectedMJ != null) {
                    this._selectedMJ.y = 0;
                }
                event.target.y = 15;
                this._selectedMJ = event.target;
                return;
            }
        }
    },

    //出牌
    shoot: function shoot(mjId) {
        if (mjId == null) {
            return;
        }
        cc.vv.net.send('chupai', mjId);
    },

    getMJIndex: function getMJIndex(side, index) {
        if (side == "right" || side == "up") {
            return 13 - index;
        }
        return index;
    },

    initMopai: function initMopai(seatIndex, pai) {
        var localIndex = cc.vv.gameNetMgr.getLocalIndex(seatIndex);
        var side = cc.vv.mahjongmgr.getSide(localIndex);
        var pre = cc.vv.mahjongmgr.getFoldPre(localIndex);

        var gameChild = this.node.getChildByName("game");
        var sideChild = gameChild.getChildByName(side);
        var holds = sideChild.getChildByName("holds");

        var lastIndex = this.getMJIndex(side, 13);
        var nc = holds.children[lastIndex];

        nc.scaleX = 1.0;
        nc.scaleY = 1.0;

        if (pai == null) {
            nc.active = false;
        } else if (pai >= 0) {
            nc.active = true;
            if (side == "up") {
                nc.scaleX = 0.73;
                nc.scaleY = 0.73;
            }
            var sprite = nc.getComponent(cc.Sprite);
            sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID(pre, pai);
        } else if (pai != null) {
            nc.active = true;
            if (side == "up") {
                nc.scaleX = 1.0;
                nc.scaleY = 1.0;
            }
            var sprite = nc.getComponent(cc.Sprite);
            sprite.spriteFrame = cc.vv.mahjongmgr.getHoldsEmptySpriteFrame(side);
        }
    },

    initEmptySprites: function initEmptySprites(seatIndex) {
        var localIndex = cc.vv.gameNetMgr.getLocalIndex(seatIndex);
        var side = cc.vv.mahjongmgr.getSide(localIndex);
        var pre = cc.vv.mahjongmgr.getFoldPre(localIndex);

        var gameChild = this.node.getChildByName("game");
        var sideChild = gameChild.getChildByName(side);
        var holds = sideChild.getChildByName("holds");
        var spriteFrame = cc.vv.mahjongmgr.getEmptySpriteFrame(side);
        for (var i = 0; i < holds.childrenCount; ++i) {
            var nc = holds.children[i];
            nc.scaleX = 1.0;
            nc.scaleY = 1.0;

            var sprite = nc.getComponent(cc.Sprite);
            sprite.spriteFrame = spriteFrame;
        }
    },

    initOtherMahjongs: function initOtherMahjongs(seatData) {
        //console.log("seat:" + seatData.seatindex);
        var localIndex = this.getLocalIndex(seatData.seatindex);
        if (localIndex == 0) {
            return;
        }
        var side = cc.vv.mahjongmgr.getSide(localIndex);
        var game = this.node.getChildByName("game");
        var sideRoot = game.getChildByName(side);
        var sideHolds = sideRoot.getChildByName("holds");
        var num = seatData.pengs.length + seatData.angangs.length + seatData.diangangs.length + seatData.wangangs.length;
        num *= 3;
        for (var i = 0; i < num; ++i) {
            var idx = this.getMJIndex(side, i);
            sideHolds.children[idx].active = false;
        }

        var pre = cc.vv.mahjongmgr.getFoldPre(localIndex);
        var holds = this.sortHolds(seatData);
        if (holds != null && holds.length > 0) {
            for (var i = 0; i < holds.length; ++i) {
                var idx = this.getMJIndex(side, i + num);
                var sprite = sideHolds.children[idx].getComponent(cc.Sprite);
                if (side == "up") {
                    sprite.node.scaleX = 0.73;
                    sprite.node.scaleY = 0.73;
                }
                sprite.node.active = true;
                sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID(pre, holds[i]);
            }

            if (holds.length + num == 13) {
                var lasetIdx = this.getMJIndex(side, 13);
                sideHolds.children[lasetIdx].active = false;
            }
        }
    },

    sortHolds: function sortHolds(seatData) {
        var holds = seatData.holds;
        if (holds == null) {
            return null;
        }
        //如果手上的牌的数目是2,5,8,11,14，表示最后一张牌是刚摸到的牌
        var mopai = null;
        var l = holds.length;
        if (l == 2 || l == 5 || l == 8 || l == 11 || l == 14) {
            mopai = holds.pop();
        }

        var dingque = seatData.dingque;
        cc.vv.mahjongmgr.sortMJ(holds, dingque);

        //将摸牌添加到最后
        if (mopai != null) {
            holds.push(mopai);
        }
        return holds;
    },

    initMahjongs: function initMahjongs() {
        var seats = cc.vv.gameNetMgr.seats;
        var seatData = seats[cc.vv.gameNetMgr.seatIndex];
        var holds = this.sortHolds(seatData);
        if (holds == null) {
            return;
        }

        //初始化手牌
        var lackingNum = (seatData.pengs.length + seatData.angangs.length + seatData.diangangs.length + seatData.wangangs.length) * 3;
        for (var i = 0; i < holds.length; ++i) {
            var mjid = holds[i];
            var sprite = this._myMJArr[i + lackingNum];
            sprite.node.mjId = mjid;
            sprite.node.y = 0;
            this.setSpriteFrameByMJID("M_", sprite, mjid);
        }
        for (var i = 0; i < lackingNum; ++i) {
            var sprite = this._myMJArr[i];
            sprite.node.mjId = null;
            sprite.spriteFrame = null;
            sprite.node.active = false;
        }
        for (var i = lackingNum + holds.length; i < this._myMJArr.length; ++i) {
            var sprite = this._myMJArr[i];
            sprite.node.mjId = null;
            sprite.spriteFrame = null;
            sprite.node.active = false;
        }
    },

    setSpriteFrameByMJID: function setSpriteFrameByMJID(pre, sprite, mjid) {
        sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID(pre, mjid);
        sprite.node.active = true;
    },

    //如果玩家手上还有缺的牌没有打，则只能打缺牌
    checkQueYiMen: function checkQueYiMen() {
        if (cc.vv.gameNetMgr.conf == null || cc.vv.gameNetMgr.conf.type != "xlch" || !cc.vv.gameNetMgr.getSelfData().hued) {
            //遍历检查看是否有未打缺的牌 如果有，则需要将不是定缺的牌设置为不可用
            var dingque = cc.vv.gameNetMgr.dingque;
            //        console.log(dingque)
            var hasQue = false;
            if (cc.vv.gameNetMgr.seatIndex == cc.vv.gameNetMgr.turn) {
                for (var i = 0; i < this._myMJArr.length; ++i) {
                    var sprite = this._myMJArr[i];
                    //                console.log("sprite.node.mjId:" + sprite.node.mjId);
                    if (sprite.node.mjId != null) {
                        var type = cc.vv.mahjongmgr.getMahjongType(sprite.node.mjId);
                        if (type == dingque) {
                            hasQue = true;
                            break;
                        }
                    }
                }
            }

            //        console.log("hasQue:" + hasQue);
            for (var i = 0; i < this._myMJArr.length; ++i) {
                var sprite = this._myMJArr[i];
                if (sprite.node.mjId != null) {
                    var type = cc.vv.mahjongmgr.getMahjongType(sprite.node.mjId);
                    if (hasQue && type != dingque) {
                        sprite.node.getComponent(cc.Button).interactable = false;
                    } else {
                        sprite.node.getComponent(cc.Button).interactable = true;
                    }
                }
            }
        } else {
            if (cc.vv.gameNetMgr.seatIndex == cc.vv.gameNetMgr.turn) {
                for (var i = 0; i < 14; ++i) {
                    var sprite = this._myMJArr[i];
                    if (sprite.node.active == true) {
                        sprite.node.getComponent(cc.Button).interactable = i == 13;
                    }
                }
            } else {
                for (var i = 0; i < 14; ++i) {
                    var sprite = this._myMJArr[i];
                    if (sprite.node.active == true) {
                        sprite.node.getComponent(cc.Button).interactable = true;
                    }
                }
            }
        }
    },

    getLocalIndex: function getLocalIndex(index) {
        var ret = (index - cc.vv.gameNetMgr.seatIndex + 4) % 4;
        //console.log("old:" + index + ",base:" + cc.vv.gameNetMgr.seatIndex + ",new:" + ret);
        return ret;
    },

    onOptionClicked: function onOptionClicked(event) {
        console.log(event.target.pai);
        if (event.target.name == "btnPeng") {
            cc.vv.net.send("peng");
        } else if (event.target.name == "btnGang") {
            cc.vv.net.send("gang", event.target.pai);
        } else if (event.target.name == "btnHu") {
            cc.vv.net.send("hu");
        } else if (event.target.name == "btnGuo") {
            cc.vv.net.send("guo");
        }
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {},

    onDestroy: function onDestroy() {
        console.log("onDestroy");
        if (cc.vv) {
            cc.vv.gameNetMgr.clear();
        }
    }
});

cc._RF.pop();
},{}],"MJRoom":[function(require,module,exports){
"use strict";
cc._RF.push(module, '921dfQJZddJ+5GFUXqxmMmT', 'MJRoom');
// scripts/components/MJRoom.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        lblRoomNo: {
            default: null,
            type: cc.Label
        },
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _seats: [],
        _seats2: [],
        _timeLabel: null,
        _voiceMsgQueue: [],
        _lastPlayingSeat: null,
        _playingSeat: null,
        _lastPlayTime: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }

        this.initView();
        this.initSeats();
        this.initEventHandlers();
    },

    initView: function initView() {
        var prepare = this.node.getChildByName("prepare");
        var seats = prepare.getChildByName("seats");
        for (var i = 0; i < seats.children.length; ++i) {
            this._seats.push(seats.children[i].getComponent("Seat"));
        }

        this.refreshBtns();

        this.lblRoomNo = cc.find("Canvas/infobar/Z_room_txt/New Label").getComponent(cc.Label);
        this._timeLabel = cc.find("Canvas/infobar/time").getComponent(cc.Label);
        this.lblRoomNo.string = cc.vv.gameNetMgr.roomId;
        var gameChild = this.node.getChildByName("game");
        var sides = ["myself", "right", "up", "left"];
        for (var i = 0; i < sides.length; ++i) {
            var sideNode = gameChild.getChildByName(sides[i]);
            var seat = sideNode.getChildByName("seat");
            this._seats2.push(seat.getComponent("Seat"));
        }

        var btnWechat = cc.find("Canvas/prepare/btnWeichat");
        if (btnWechat) {
            cc.vv.utils.addClickEvent(btnWechat, this.node, "MJRoom", "onBtnWeichatClicked");
        }

        var titles = cc.find("Canvas/typeTitle");
        for (var i = 0; i < titles.children.length; ++i) {
            titles.children[i].active = false;
        }

        if (cc.vv.gameNetMgr.conf) {
            var type = cc.vv.gameNetMgr.conf.type;
            if (type == null || type == "") {
                type = "xzdd";
            }

            titles.getChildByName(type).active = true;
        }
    },

    refreshBtns: function refreshBtns() {
        var prepare = this.node.getChildByName("prepare");
        var btnExit = prepare.getChildByName("btnExit");
        var btnDispress = prepare.getChildByName("btnDissolve");
        var btnWeichat = prepare.getChildByName("btnWeichat");
        var btnBack = prepare.getChildByName("btnBack");
        var isIdle = cc.vv.gameNetMgr.numOfGames == 0;

        btnExit.active = !cc.vv.gameNetMgr.isOwner() && isIdle;
        btnDispress.active = cc.vv.gameNetMgr.isOwner() && isIdle;

        btnWeichat.active = isIdle;
        btnBack.active = isIdle;
    },

    initEventHandlers: function initEventHandlers() {
        var self = this;
        this.node.on('new_user', function (data) {
            self.initSingleSeat(data.detail);
        });

        this.node.on('user_state_changed', function (data) {
            self.initSingleSeat(data.detail);
        });

        this.node.on('game_begin', function (data) {
            self.refreshBtns();
            self.initSeats();
        });

        this.node.on('game_num', function (data) {
            self.refreshBtns();
        });

        this.node.on('game_huanpai', function (data) {
            for (var i in self._seats2) {
                self._seats2[i].refreshXuanPaiState();
            }
        });

        this.node.on('huanpai_notify', function (data) {
            var idx = data.detail.seatindex;
            var localIdx = cc.vv.gameNetMgr.getLocalIndex(idx);
            self._seats2[localIdx].refreshXuanPaiState();
        });

        this.node.on('game_huanpai_over', function (data) {
            for (var i in self._seats2) {
                self._seats2[i].refreshXuanPaiState();
            }
        });

        this.node.on('voice_msg', function (data) {
            var data = data.detail;
            self._voiceMsgQueue.push(data);
            self.playVoice();
        });

        this.node.on('chat_push', function (data) {
            var data = data.detail;
            var idx = cc.vv.gameNetMgr.getSeatIndexByID(data.sender);
            var localIdx = cc.vv.gameNetMgr.getLocalIndex(idx);
            self._seats[localIdx].chat(data.content);
            self._seats2[localIdx].chat(data.content);
        });

        this.node.on('quick_chat_push', function (data) {
            var data = data.detail;
            var idx = cc.vv.gameNetMgr.getSeatIndexByID(data.sender);
            var localIdx = cc.vv.gameNetMgr.getLocalIndex(idx);

            var index = data.content;
            var info = cc.vv.chat.getQuickChatInfo(index);
            self._seats[localIdx].chat(info.content);
            self._seats2[localIdx].chat(info.content);

            cc.vv.audioMgr.playSFX(info.sound);
        });

        this.node.on('emoji_push', function (data) {
            var data = data.detail;
            var idx = cc.vv.gameNetMgr.getSeatIndexByID(data.sender);
            var localIdx = cc.vv.gameNetMgr.getLocalIndex(idx);
            console.log(data);
            self._seats[localIdx].emoji(data.content);
            self._seats2[localIdx].emoji(data.content);
        });
    },

    initSeats: function initSeats() {
        var seats = cc.vv.gameNetMgr.seats;
        for (var i = 0; i < seats.length; ++i) {
            this.initSingleSeat(seats[i]);
        }
    },

    initSingleSeat: function initSingleSeat(seat) {
        var index = cc.vv.gameNetMgr.getLocalIndex(seat.seatindex);
        var isOffline = !seat.online;
        var isZhuang = seat.seatindex == cc.vv.gameNetMgr.button;

        console.log("isOffline:" + isOffline);

        this._seats[index].setInfo(seat.name, seat.score);
        this._seats[index].setReady(seat.ready);
        this._seats[index].setOffline(isOffline);
        this._seats[index].setID(seat.userid);
        this._seats[index].voiceMsg(false);

        this._seats2[index].setInfo(seat.name, seat.score);
        this._seats2[index].setZhuang(isZhuang);
        this._seats2[index].setOffline(isOffline);
        this._seats2[index].setID(seat.userid);
        this._seats2[index].voiceMsg(false);
        this._seats2[index].refreshXuanPaiState();
    },

    onBtnSettingsClicked: function onBtnSettingsClicked() {
        cc.vv.popupMgr.showSettings();
    },

    onBtnBackClicked: function onBtnBackClicked() {
        cc.vv.alert.show("返回大厅", "返回大厅房间仍会保留，快去邀请大伙来玩吧！", function () {
            cc.director.loadScene("hall");
        }, true);
    },

    onBtnChatClicked: function onBtnChatClicked() {},

    onBtnWeichatClicked: function onBtnWeichatClicked() {
        var title = "<血战到底>";
        if (cc.vv.gameNetMgr.conf.type == "xlch") {
            var title = "<血流成河>";
        }
        cc.vv.anysdkMgr.share("达达麻将" + title, "房号:" + cc.vv.gameNetMgr.roomId + " 玩法:" + cc.vv.gameNetMgr.getWanfa());
    },

    onBtnDissolveClicked: function onBtnDissolveClicked() {
        cc.vv.alert.show("解散房间", "解散房间不扣房卡，是否确定解散？", function () {
            cc.vv.net.send("dispress");
        }, true);
    },

    onBtnExit: function onBtnExit() {
        cc.vv.net.send("exit");
    },

    playVoice: function playVoice() {
        if (this._playingSeat == null && this._voiceMsgQueue.length) {
            console.log("playVoice2");
            var data = this._voiceMsgQueue.shift();
            var idx = cc.vv.gameNetMgr.getSeatIndexByID(data.sender);
            var localIndex = cc.vv.gameNetMgr.getLocalIndex(idx);
            this._playingSeat = localIndex;
            this._seats[localIndex].voiceMsg(true);
            this._seats2[localIndex].voiceMsg(true);

            var msgInfo = JSON.parse(data.content);

            var msgfile = "voicemsg.amr";
            console.log(msgInfo.msg.length);
            cc.vv.voiceMgr.writeVoice(msgfile, msgInfo.msg);
            cc.vv.voiceMgr.play(msgfile);
            this._lastPlayTime = Date.now() + msgInfo.time;
        }
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        var minutes = Math.floor(Date.now() / 1000 / 60);
        if (this._lastMinute != minutes) {
            this._lastMinute = minutes;
            var date = new Date();
            var h = date.getHours();
            h = h < 10 ? "0" + h : h;

            var m = date.getMinutes();
            m = m < 10 ? "0" + m : m;
            this._timeLabel.string = "" + h + ":" + m;
        }

        if (this._lastPlayTime != null) {
            if (Date.now() > this._lastPlayTime + 200) {
                this.onPlayerOver();
                this._lastPlayTime = null;
            }
        } else {
            this.playVoice();
        }
    },

    onPlayerOver: function onPlayerOver() {
        cc.vv.audioMgr.resumeAll();
        console.log("onPlayCallback:" + this._playingSeat);
        var localIndex = this._playingSeat;
        this._playingSeat = null;
        this._seats[localIndex].voiceMsg(false);
        this._seats2[localIndex].voiceMsg(false);
    },

    onDestroy: function onDestroy() {
        cc.vv.voiceMgr.stop();
        //        cc.vv.voiceMgr.onPlayCallback = null;
    }
});

cc._RF.pop();
},{}],"MahjongMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, '0ecea6X+IFIK5XFdJe38hXa', 'MahjongMgr');
// scripts/MahjongMgr.js

"use strict";

var mahjongSprites = [];

cc.Class({
    extends: cc.Component,

    properties: {
        leftAtlas: {
            default: null,
            type: cc.SpriteAtlas
        },

        rightAtlas: {
            default: null,
            type: cc.SpriteAtlas
        },

        bottomAtlas: {
            default: null,
            type: cc.SpriteAtlas
        },

        bottomFoldAtlas: {
            default: null,
            type: cc.SpriteAtlas
        },

        pengPrefabSelf: {
            default: null,
            type: cc.Prefab
        },

        pengPrefabLeft: {
            default: null,
            type: cc.Prefab
        },

        emptyAtlas: {
            default: null,
            type: cc.SpriteAtlas
        },

        holdsEmpty: {
            default: [],
            type: [cc.SpriteFrame]
        },

        _sides: null,
        _pres: null,
        _foldPres: null
    },

    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }
        this._sides = ["myself", "right", "up", "left"];
        this._pres = ["M_", "R_", "B_", "L_"];
        this._foldPres = ["B_", "R_", "B_", "L_"];
        cc.vv.mahjongmgr = this;
        //筒
        for (var i = 1; i < 10; ++i) {
            mahjongSprites.push("dot_" + i);
        }

        //条
        for (var i = 1; i < 10; ++i) {
            mahjongSprites.push("bamboo_" + i);
        }

        //万
        for (var i = 1; i < 10; ++i) {
            mahjongSprites.push("character_" + i);
        }

        //中、发、白
        mahjongSprites.push("red");
        mahjongSprites.push("green");
        mahjongSprites.push("white");

        //东西南北风
        mahjongSprites.push("wind_east");
        mahjongSprites.push("wind_west");
        mahjongSprites.push("wind_south");
        mahjongSprites.push("wind_north");
    },

    getMahjongSpriteByID: function getMahjongSpriteByID(id) {
        return mahjongSprites[id];
    },

    getMahjongType: function getMahjongType(id) {
        if (id >= 0 && id < 9) {
            return 0;
        } else if (id >= 9 && id < 18) {
            return 1;
        } else if (id >= 18 && id < 27) {
            return 2;
        }
    },

    getSpriteFrameByMJID: function getSpriteFrameByMJID(pre, mjid) {
        var spriteFrameName = this.getMahjongSpriteByID(mjid);
        spriteFrameName = pre + spriteFrameName;
        if (pre == "M_") {
            return this.bottomAtlas.getSpriteFrame(spriteFrameName);
        } else if (pre == "B_") {
            return this.bottomFoldAtlas.getSpriteFrame(spriteFrameName);
        } else if (pre == "L_") {
            return this.leftAtlas.getSpriteFrame(spriteFrameName);
        } else if (pre == "R_") {
            return this.rightAtlas.getSpriteFrame(spriteFrameName);
        }
    },

    getAudioURLByMJID: function getAudioURLByMJID(id) {
        var realId = 0;
        if (id >= 0 && id < 9) {
            realId = id + 21;
        } else if (id >= 9 && id < 18) {
            realId = id - 8;
        } else if (id >= 18 && id < 27) {
            realId = id - 7;
        }
        return "nv/" + realId + ".mp3";
    },

    getEmptySpriteFrame: function getEmptySpriteFrame(side) {
        if (side == "up") {
            return this.emptyAtlas.getSpriteFrame("e_mj_b_up");
        } else if (side == "myself") {
            return this.emptyAtlas.getSpriteFrame("e_mj_b_bottom");
        } else if (side == "left") {
            return this.emptyAtlas.getSpriteFrame("e_mj_b_left");
        } else if (side == "right") {
            return this.emptyAtlas.getSpriteFrame("e_mj_b_right");
        }
    },

    getHoldsEmptySpriteFrame: function getHoldsEmptySpriteFrame(side) {
        if (side == "up") {
            return this.emptyAtlas.getSpriteFrame("e_mj_up");
        } else if (side == "myself") {
            return null;
        } else if (side == "left") {
            return this.emptyAtlas.getSpriteFrame("e_mj_left");
        } else if (side == "right") {
            return this.emptyAtlas.getSpriteFrame("e_mj_right");
        }
    },

    sortMJ: function sortMJ(mahjongs, dingque) {
        var self = this;
        mahjongs.sort(function (a, b) {
            if (dingque >= 0) {
                var t1 = self.getMahjongType(a);
                var t2 = self.getMahjongType(b);
                if (t1 != t2) {
                    if (dingque == t1) {
                        return 1;
                    } else if (dingque == t2) {
                        return -1;
                    }
                }
            }
            return a - b;
        });
    },

    getSide: function getSide(localIndex) {
        return this._sides[localIndex];
    },

    getPre: function getPre(localIndex) {
        return this._pres[localIndex];
    },

    getFoldPre: function getFoldPre(localIndex) {
        return this._foldPres[localIndex];
    }
});

cc._RF.pop();
},{}],"Net":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'b1cc9yRd15CXqFg0vTGKZUk', 'Net');
// scripts/Net.js

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (window.io == null) {
    window.io = require("socket-io");
}

var Global = cc.Class({
    extends: cc.Component,
    statics: {
        ip: "",
        sio: null,
        isPinging: false,
        fnDisconnect: null,
        handlers: {},
        addHandler: function addHandler(event, fn) {
            if (this.handlers[event]) {
                console.log("event:" + event + "' handler has been registered.");
                return;
            }

            var handler = function handler(data) {
                //console.log(event + "(" + typeof(data) + "):" + (data? data.toString():"null"));
                if (event != "disconnect" && typeof data == "string") {
                    data = JSON.parse(data);
                }
                fn(data);
            };

            this.handlers[event] = handler;
            if (this.sio) {
                console.log("register:function " + event);
                this.sio.on(event, handler);
            }
        },
        connect: function connect(fnConnect, fnError) {
            var self = this;

            var opts = {
                'reconnection': false,
                'force new connection': true,
                'transports': ['websocket', 'polling']
            };
            this.sio = window.io.connect(this.ip, opts);
            this.sio.on('reconnect', function () {
                console.log('reconnection');
            });
            this.sio.on('connect', function (data) {
                self.sio.connected = true;
                fnConnect(data);
            });

            this.sio.on('disconnect', function (data) {
                console.log("disconnect");
                self.sio.connected = false;
                self.close();
            });

            this.sio.on('connect_failed', function () {
                console.log('connect_failed');
            });

            for (var key in this.handlers) {
                var value = this.handlers[key];
                if (typeof value == "function") {
                    if (key == 'disconnect') {
                        this.fnDisconnect = value;
                    } else {
                        console.log("register:function " + key);
                        this.sio.on(key, value);
                    }
                }
            }

            this.startHearbeat();
        },

        startHearbeat: function startHearbeat() {
            this.sio.on('game_pong', function () {
                console.log('game_pong');
                self.lastRecieveTime = Date.now();
            });
            this.lastRecieveTime = Date.now();
            var self = this;
            console.log(1);
            if (!self.isPinging) {
                console.log(1);
                self.isPinging = true;
                setInterval(function () {
                    console.log(3);
                    if (self.sio) {
                        console.log(4);
                        if (Date.now() - self.lastRecieveTime > 10000) {
                            self.close();
                        } else {
                            self.ping();
                        }
                    }
                }, 5000);
            }
        },
        send: function send(event, data) {
            if (this.sio.connected) {
                if (data != null && (typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
                    data = JSON.stringify(data);
                    //console.log(data);              
                }
                this.sio.emit(event, data);
            }
        },

        ping: function ping() {
            this.send('game_ping');
        },

        close: function close() {
            console.log('close');
            if (this.sio && this.sio.connected) {
                this.sio.connected = false;
                this.sio.disconnect();
                this.sio = null;
            }
            if (this.fnDisconnect) {
                this.fnDisconnect();
                this.fnDisconnect = null;
            }
        },

        test: function test(fnResult) {
            var xhr = null;
            var fn = function fn(ret) {
                fnResult(ret.isonline);
                xhr = null;
            };

            var arr = this.ip.split(':');
            var data = {
                account: cc.vv.userMgr.account,
                sign: cc.vv.userMgr.sign,
                ip: arr[0],
                port: arr[1]
            };
            xhr = cc.vv.http.sendRequest("/is_server_online", data, fn);
            setTimeout(function () {
                if (xhr) {
                    xhr.abort();
                    fnResult(false);
                }
            }, 1500);
            /*
            var opts = {
                'reconnection':false,
                'force new connection': true,
                'transports':['websocket', 'polling']
            }
            var self = this;
            this.testsio = window.io.connect(this.ip,opts);
            this.testsio.on('connect',function(){
                console.log('connect');
                self.testsio.close();
                self.testsio = null;
                fnResult(true);
            });
            this.testsio.on('connect_error',function(){
                console.log('connect_failed');
                self.testsio = null;
                fnResult(false);
            });
            */
        }
    }
});

cc._RF.pop();
},{"socket-io":"socket-io"}],"NoticeTip":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'df61b4+FzFDvbpO5g8UNVIM', 'NoticeTip');
// scripts/components/NoticeTip.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _guohu: null,
        _info: null,
        _guohuTime: -1
    },

    // use this for initialization
    onLoad: function onLoad() {
        this._guohu = cc.find("Canvas/tip_notice");
        this._guohu.active = false;

        this._info = cc.find("Canvas/tip_notice/info").getComponent(cc.Label);

        var self = this;
        this.node.on('push_notice', function (data) {
            var data = data.detail;
            self._guohu.active = true;
            self._guohuTime = data.time;
            self._info.string = data.info;
        });
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        if (this._guohuTime > 0) {
            this._guohuTime -= dt;
            if (this._guohuTime < 0) {
                this._guohu.active = false;
            }
        }
    }
});

cc._RF.pop();
},{}],"OnBack":[function(require,module,exports){
"use strict";
cc._RF.push(module, '6fd982Tyi5NOYJWt/fGY8Lj', 'OnBack');
// scripts/components/OnBack.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
    },

    // use this for initialization
    onLoad: function onLoad() {
        var btn = this.node.getChildByName("btn_back");
        cc.vv.utils.addClickEvent(btn, this.node, "OnBack", "onBtnClicked");
    },

    onBtnClicked: function onBtnClicked(event) {
        if (event.target.name == "btn_back") {
            this.node.active = false;
        }
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"PengGangs":[function(require,module,exports){
"use strict";
cc._RF.push(module, '279d9pNFGRB3rD/ngr1LIXQ', 'PengGangs');
// scripts/components/PengGangs.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (!cc.vv) {
            return;
        }

        var gameChild = this.node.getChildByName("game");
        var myself = gameChild.getChildByName("myself");
        var pengangroot = myself.getChildByName("penggangs");
        var realwidth = cc.director.getVisibleSize().width;
        var scale = realwidth / 1280;
        pengangroot.scaleX *= scale;
        pengangroot.scaleY *= scale;

        var self = this;
        this.node.on('peng_notify', function (data) {
            //刷新所有的牌
            //console.log(data.detail);
            var data = data.detail;
            self.onPengGangChanged(data);
        });

        this.node.on('gang_notify', function (data) {
            //刷新所有的牌
            //console.log(data.detail);
            var data = data.detail;
            self.onPengGangChanged(data.seatData);
        });

        this.node.on('game_begin', function (data) {
            self.onGameBein();
        });

        var seats = cc.vv.gameNetMgr.seats;
        for (var i in seats) {
            this.onPengGangChanged(seats[i]);
        }
    },

    onGameBein: function onGameBein() {
        this.hideSide("myself");
        this.hideSide("right");
        this.hideSide("up");
        this.hideSide("left");
    },

    hideSide: function hideSide(side) {
        var gameChild = this.node.getChildByName("game");
        var myself = gameChild.getChildByName(side);
        var pengangroot = myself.getChildByName("penggangs");
        if (pengangroot) {
            for (var i = 0; i < pengangroot.childrenCount; ++i) {
                pengangroot.children[i].active = false;
            }
        }
    },

    onPengGangChanged: function onPengGangChanged(seatData) {

        if (seatData.angangs == null && seatData.diangangs == null && seatData.wangangs == null && seatData.pengs == null) {
            return;
        }
        var localIndex = cc.vv.gameNetMgr.getLocalIndex(seatData.seatindex);
        var side = cc.vv.mahjongmgr.getSide(localIndex);
        var pre = cc.vv.mahjongmgr.getFoldPre(localIndex);

        console.log("onPengGangChanged" + localIndex);

        var gameChild = this.node.getChildByName("game");
        var myself = gameChild.getChildByName(side);
        var pengangroot = myself.getChildByName("penggangs");

        for (var i = 0; i < pengangroot.childrenCount; ++i) {
            pengangroot.children[i].active = false;
        }
        //初始化杠牌
        var index = 0;

        var gangs = seatData.angangs;
        for (var i = 0; i < gangs.length; ++i) {
            var mjid = gangs[i];
            this.initPengAndGangs(pengangroot, side, pre, index, mjid, "angang");
            index++;
        }
        var gangs = seatData.diangangs;
        for (var i = 0; i < gangs.length; ++i) {
            var mjid = gangs[i];
            this.initPengAndGangs(pengangroot, side, pre, index, mjid, "diangang");
            index++;
        }

        var gangs = seatData.wangangs;
        for (var i = 0; i < gangs.length; ++i) {
            var mjid = gangs[i];
            this.initPengAndGangs(pengangroot, side, pre, index, mjid, "wangang");
            index++;
        }

        //初始化碰牌
        var pengs = seatData.pengs;
        if (pengs) {
            for (var i = 0; i < pengs.length; ++i) {
                var mjid = pengs[i];
                this.initPengAndGangs(pengangroot, side, pre, index, mjid, "peng");
                index++;
            }
        }
    },

    initPengAndGangs: function initPengAndGangs(pengangroot, side, pre, index, mjid, flag) {
        var pgroot = null;
        if (pengangroot.childrenCount <= index) {
            if (side == "left" || side == "right") {
                pgroot = cc.instantiate(cc.vv.mahjongmgr.pengPrefabLeft);
            } else {
                pgroot = cc.instantiate(cc.vv.mahjongmgr.pengPrefabSelf);
            }

            pengangroot.addChild(pgroot);
        } else {
            pgroot = pengangroot.children[index];
            pgroot.active = true;
        }

        if (side == "left") {
            pgroot.y = -(index * 25 * 3);
        } else if (side == "right") {
            pgroot.y = index * 25 * 3;
            pgroot.setLocalZOrder(-index);
        } else if (side == "myself") {
            pgroot.x = index * 55 * 3 + index * 10;
        } else {
            pgroot.x = -(index * 55 * 3);
        }

        var sprites = pgroot.getComponentsInChildren(cc.Sprite);
        for (var s = 0; s < sprites.length; ++s) {
            var sprite = sprites[s];
            if (sprite.node.name == "gang") {
                var isGang = flag != "peng";
                sprite.node.active = isGang;
                sprite.node.scaleX = 1.0;
                sprite.node.scaleY = 1.0;
                if (flag == "angang") {
                    sprite.spriteFrame = cc.vv.mahjongmgr.getEmptySpriteFrame(side);
                    if (side == "myself" || side == "up") {
                        sprite.node.scaleX = 1.4;
                        sprite.node.scaleY = 1.4;
                    }
                } else {
                    sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID(pre, mjid);
                }
            } else {
                sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID(pre, mjid);
            }
        }
    }

});

cc._RF.pop();
},{}],"PopupMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'bc0d2VLgL1Avo166tHLsjCJ', 'PopupMgr');
// scripts/components/PopupMgr.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _popuproot: null,
        _settings: null,
        _dissolveNotice: null,

        _endTime: -1,
        _extraInfo: null,
        _noticeLabel: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }

        cc.vv.popupMgr = this;

        this._popuproot = cc.find("Canvas/popups");
        this._settings = cc.find("Canvas/popups/settings");
        this._dissolveNotice = cc.find("Canvas/popups/dissolve_notice");
        this._noticeLabel = this._dissolveNotice.getChildByName("info").getComponent(cc.Label);

        this.closeAll();

        this.addBtnHandler("settings/btn_close");
        this.addBtnHandler("settings/btn_sqjsfj");
        this.addBtnHandler("dissolve_notice/btn_agree");
        this.addBtnHandler("dissolve_notice/btn_reject");
        this.addBtnHandler("dissolve_notice/btn_ok");

        var self = this;
        this.node.on("dissolve_notice", function (event) {
            var data = event.detail;
            self.showDissolveNotice(data);
        });

        this.node.on("dissolve_cancel", function (event) {
            self.closeAll();
        });
    },

    start: function start() {
        if (cc.vv.gameNetMgr.dissoveData) {
            this.showDissolveNotice(cc.vv.gameNetMgr.dissoveData);
        }
    },

    addBtnHandler: function addBtnHandler(btnName) {
        var btn = cc.find("Canvas/popups/" + btnName);
        this.addClickEvent(btn, this.node, "PopupMgr", "onBtnClicked");
    },

    addClickEvent: function addClickEvent(node, target, component, handler) {
        var eventHandler = new cc.Component.EventHandler();
        eventHandler.target = target;
        eventHandler.component = component;
        eventHandler.handler = handler;

        var clickEvents = node.getComponent(cc.Button).clickEvents;
        clickEvents.push(eventHandler);
    },

    onBtnClicked: function onBtnClicked(event) {
        this.closeAll();
        var btnName = event.target.name;
        if (btnName == "btn_agree") {
            cc.vv.net.send("dissolve_agree");
        } else if (btnName == "btn_reject") {
            cc.vv.net.send("dissolve_reject");
        } else if (btnName == "btn_sqjsfj") {
            cc.vv.net.send("dissolve_request");
        }
    },

    closeAll: function closeAll() {
        this._popuproot.active = false;
        this._settings.active = false;
        this._dissolveNotice.active = false;
    },

    showSettings: function showSettings() {
        this.closeAll();
        this._popuproot.active = true;
        this._settings.active = true;
    },

    showDissolveRequest: function showDissolveRequest() {
        this.closeAll();
        this._popuproot.active = true;
    },

    showDissolveNotice: function showDissolveNotice(data) {
        this._endTime = Date.now() / 1000 + data.time;
        this._extraInfo = "";
        for (var i = 0; i < data.states.length; ++i) {
            var b = data.states[i];
            var name = cc.vv.gameNetMgr.seats[i].name;
            if (b) {
                this._extraInfo += "\n[已同意] " + name;
            } else {
                this._extraInfo += "\n[待确认] " + name;
            }
        }
        this.closeAll();
        this._popuproot.active = true;
        this._dissolveNotice.active = true;;
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        if (this._endTime > 0) {
            var lastTime = this._endTime - Date.now() / 1000;
            if (lastTime < 0) {
                this._endTime = -1;
            }

            var m = Math.floor(lastTime / 60);
            var s = Math.ceil(lastTime - m * 60);

            var str = "";
            if (m > 0) {
                str += m + "分";
            }

            this._noticeLabel.string = str + s + "秒后房间将自动解散" + this._extraInfo;
        }
    }
});

cc._RF.pop();
},{}],"RadioButton":[function(require,module,exports){
"use strict";
cc._RF.push(module, '8d571y2U+9AiKntO+TSf0Fb', 'RadioButton');
// scripts/components/RadioButton.js

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        target: cc.Node,
        sprite: cc.SpriteFrame,
        checkedSprite: cc.SpriteFrame,
        checked: false,
        groupId: -1
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }
        if (cc.vv.radiogroupmgr == null) {
            var RadioGroupMgr = require("RadioGroupMgr");
            cc.vv.radiogroupmgr = new RadioGroupMgr();
            cc.vv.radiogroupmgr.init();
        }
        console.log(_typeof(cc.vv.radiogroupmgr.add));
        cc.vv.radiogroupmgr.add(this);

        this.refresh();
    },

    refresh: function refresh() {
        var targetSprite = this.target.getComponent(cc.Sprite);
        if (this.checked) {
            targetSprite.spriteFrame = this.checkedSprite;
        } else {
            targetSprite.spriteFrame = this.sprite;
        }
    },

    check: function check(value) {
        this.checked = value;
        this.refresh();
    },

    onClicked: function onClicked() {
        cc.vv.radiogroupmgr.check(this);
    },

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    onDestroy: function onDestroy() {
        if (cc.vv && cc.vv.radiogroupmgr) {
            cc.vv.radiogroupmgr.del(this);
        }
    }
});

cc._RF.pop();
},{"RadioGroupMgr":"RadioGroupMgr"}],"RadioGroupMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, '824eapeRYNKY4RJzg2Z4YA2', 'RadioGroupMgr');
// scripts/components/RadioGroupMgr.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _groups: null
    },

    // use this for initialization
    init: function init() {
        this._groups = {};
    },

    add: function add(radioButton) {
        var groupId = radioButton.groupId;
        var buttons = this._groups[groupId];
        if (buttons == null) {
            buttons = [];
            this._groups[groupId] = buttons;
        }
        buttons.push(radioButton);
    },

    del: function del(radioButton) {
        var groupId = radioButton.groupId;
        var buttons = this._groups[groupId];
        if (buttons == null) {
            return;
        }
        var idx = buttons.indexOf(radioButton);
        if (idx != -1) {
            buttons.splice(idx, 1);
        }
        if (buttons.length == 0) {
            delete this._groups[groupId];
        }
    },

    check: function check(radioButton) {
        var groupId = radioButton.groupId;
        var buttons = this._groups[groupId];
        if (buttons == null) {
            return;
        }
        for (var i = 0; i < buttons.length; ++i) {
            var btn = buttons[i];
            if (btn == radioButton) {
                btn.check(true);
            } else {
                btn.check(false);
            }
        }
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"ReConnect":[function(require,module,exports){
"use strict";
cc._RF.push(module, '7f553G0boRH6KrTE7wACaXx', 'ReConnect');
// scripts/components/ReConnect.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _reconnect: null,
        _lblTip: null,
        _lastPing: 0
    },

    // use this for initialization
    onLoad: function onLoad() {
        this._reconnect = cc.find("Canvas/reconnect");
        this._lblTip = cc.find("Canvas/reconnect/tip").getComponent(cc.Label);
        var self = this;

        var fnTestServerOn = function fnTestServerOn() {
            cc.vv.net.test(function (ret) {
                if (ret) {
                    cc.director.loadScene('hall');
                } else {
                    setTimeout(fnTestServerOn, 3000);
                }
            });
        };

        var fn = function fn(data) {
            self.node.off('disconnect', fn);
            self._reconnect.active = true;
            fnTestServerOn();
        };
        console.log("adasfdasdfsdf");
        this.node.on('disconnect', fn);
    },
    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        if (this._reconnect.active) {
            var t = Math.floor(Date.now() / 1000) % 4;
            this._lblTip.string = "与服务器断开连接，正在尝试重连";
            for (var i = 0; i < t; ++i) {
                this._lblTip.string += '.';
            }
        }
    }
});

cc._RF.pop();
},{}],"ReplayCtrl":[function(require,module,exports){
"use strict";
cc._RF.push(module, '21e6a+ajGNDTJwDHbV3A72m', 'ReplayCtrl');
// scripts/components/ReplayCtrl.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _nextPlayTime: 1,
        _replay: null,
        _isPlaying: true
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }

        this._replay = cc.find("Canvas/replay");
        this._replay.active = cc.vv.replayMgr.isReplay();
    },

    onBtnPauseClicked: function onBtnPauseClicked() {
        this._isPlaying = false;
    },

    onBtnPlayClicked: function onBtnPlayClicked() {
        this._isPlaying = true;
    },

    onBtnBackClicked: function onBtnBackClicked() {
        cc.vv.replayMgr.clear();
        cc.vv.gameNetMgr.reset();
        cc.vv.gameNetMgr.roomId = null;
        cc.director.loadScene("hall");
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        if (cc.vv) {
            if (this._isPlaying && cc.vv.replayMgr.isReplay() == true && this._nextPlayTime > 0) {
                this._nextPlayTime -= dt;
                if (this._nextPlayTime < 0) {
                    this._nextPlayTime = cc.vv.replayMgr.takeAction();
                }
            }
        }
    }
});

cc._RF.pop();
},{}],"ReplayMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, '1a6a1p86NFL6KZEZCnbu7tt', 'ReplayMgr');
// scripts/ReplayMgr.js

'use strict';

var ACTION_CHUPAI = 1;
var ACTION_MOPAI = 2;
var ACTION_PENG = 3;
var ACTION_GANG = 4;
var ACTION_HU = 5;

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _lastAction: null,
        _actionRecords: null,
        _currentIndex: 0
    },

    // use this for initialization
    onLoad: function onLoad() {},

    clear: function clear() {
        this._lastAction = null;
        this._actionRecords = null;
        this._currentIndex = 0;
    },

    init: function init(data) {
        this._actionRecords = data.action_records;
        if (this._actionRecords == null) {
            this._actionRecords = {};
        }
        this._currentIndex = 0;
        this._lastAction = null;
    },

    isReplay: function isReplay() {
        return this._actionRecords != null;
    },

    getNextAction: function getNextAction() {
        if (this._currentIndex >= this._actionRecords.length) {
            return null;
        }

        var si = this._actionRecords[this._currentIndex++];
        var action = this._actionRecords[this._currentIndex++];
        var pai = this._actionRecords[this._currentIndex++];
        return { si: si, type: action, pai: pai };
    },

    takeAction: function takeAction() {
        var action = this.getNextAction();
        if (this._lastAction != null && this._lastAction.type == ACTION_CHUPAI) {
            if (action != null && action.type != ACTION_PENG && action.type != ACTION_GANG && action.type != ACTION_HU) {
                cc.vv.gameNetMgr.doGuo(this._lastAction.si, this._lastAction.pai);
            }
        }
        this._lastAction = action;
        if (action == null) {
            return -1;
        }
        var nextActionDelay = 1.0;
        if (action.type == ACTION_CHUPAI) {
            //console.log("chupai");
            cc.vv.gameNetMgr.doChupai(action.si, action.pai);
            return 1.0;
        } else if (action.type == ACTION_MOPAI) {
            //console.log("mopai");
            cc.vv.gameNetMgr.doMopai(action.si, action.pai);
            cc.vv.gameNetMgr.doTurnChange(action.si);
            return 0.5;
        } else if (action.type == ACTION_PENG) {
            //console.log("peng");
            cc.vv.gameNetMgr.doPeng(action.si, action.pai);
            cc.vv.gameNetMgr.doTurnChange(action.si);
            return 1.0;
        } else if (action.type == ACTION_GANG) {
            //console.log("gang");
            cc.vv.gameNetMgr.dispatchEvent('hangang_notify', action.si);
            cc.vv.gameNetMgr.doGang(action.si, action.pai);
            cc.vv.gameNetMgr.doTurnChange(action.si);
            return 1.0;
        } else if (action.type == ACTION_HU) {
            //console.log("hu");
            cc.vv.gameNetMgr.doHu({ seatindex: action.si, hupai: action.pai, iszimo: false });
            return 1.5;
        }
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"Seat":[function(require,module,exports){
"use strict";
cc._RF.push(module, '820870ltMZNDYlvzr+qCDEJ', 'Seat');
// scripts/components/Seat.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        _sprIcon: null,
        _zhuang: null,
        _ready: null,
        _offline: null,
        _lblName: null,
        _lblScore: null,
        _scoreBg: null,
        _nddayingjia: null,
        _voicemsg: null,

        _chatBubble: null,
        _emoji: null,
        _lastChatTime: -1,

        _userName: "",
        _score: 0,
        _dayingjia: false,
        _isOffline: false,
        _isReady: false,
        _isZhuang: false,
        _userId: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }

        this._sprIcon = this.node.getChildByName("icon").getComponent("ImageLoader");
        this._lblName = this.node.getChildByName("name").getComponent(cc.Label);
        this._lblScore = this.node.getChildByName("score").getComponent(cc.Label);
        this._voicemsg = this.node.getChildByName("voicemsg");
        this._xuanpai = this.node.getChildByName("xuanpai");
        this.refreshXuanPaiState();

        if (this._voicemsg) {
            this._voicemsg.active = false;
        }

        if (this._sprIcon && this._sprIcon.getComponent(cc.Button)) {
            cc.vv.utils.addClickEvent(this._sprIcon, this.node, "Seat", "onIconClicked");
        }

        this._offline = this.node.getChildByName("offline");

        this._ready = this.node.getChildByName("ready");

        this._zhuang = this.node.getChildByName("zhuang");

        this._scoreBg = this.node.getChildByName("Z_money_frame");
        this._nddayingjia = this.node.getChildByName("dayingjia");

        this._chatBubble = this.node.getChildByName("ChatBubble");
        if (this._chatBubble != null) {
            this._chatBubble.active = false;
        }

        this._emoji = this.node.getChildByName("emoji");
        if (this._emoji != null) {
            this._emoji.active = false;
        }

        this.refresh();

        if (this._sprIcon && this._userId) {
            this._sprIcon.setUserID(this._userId);
        }
    },

    onIconClicked: function onIconClicked() {
        var iconSprite = this._sprIcon.node.getComponent(cc.Sprite);
        if (this._userId != null && this._userId > 0) {
            var seat = cc.vv.gameNetMgr.getSeatByID(this._userId);
            var sex = 0;
            if (cc.vv.baseInfoMap) {
                var info = cc.vv.baseInfoMap[this._userId];
                if (info) {
                    sex = info.sex;
                }
            }
            cc.vv.userinfoShow.show(seat.name, seat.userid, iconSprite, sex, seat.ip);
        }
    },

    refresh: function refresh() {
        if (this._lblName != null) {
            this._lblName.string = this._userName;
        }

        if (this._lblScore != null) {
            this._lblScore.string = this._score;
        }

        if (this._nddayingjia != null) {
            this._nddayingjia.active = this._dayingjia == true;
        }

        if (this._offline) {
            this._offline.active = this._isOffline && this._userName != "";
        }

        if (this._ready) {
            this._ready.active = this._isReady && cc.vv.gameNetMgr.numOfGames > 0;
        }

        if (this._zhuang) {
            this._zhuang.active = this._isZhuang;
        }

        this.node.active = this._userName != null && this._userName != "";
    },

    setInfo: function setInfo(name, score, dayingjia) {
        this._userName = name;
        this._score = score;
        if (this._score == null) {
            this._score = 0;
        }
        this._dayingjia = dayingjia;

        if (this._scoreBg != null) {
            this._scoreBg.active = this._score != null;
        }

        if (this._lblScore != null) {
            this._lblScore.node.active = this._score != null;
        }

        this.refresh();
    },


    setZhuang: function setZhuang(value) {
        if (this._zhuang) {
            this._zhuang.active = value;
        }
    },

    setReady: function setReady(isReady) {
        this._isReady = isReady;
        if (this._ready) {
            this._ready.active = this._isReady && cc.vv.gameNetMgr.numOfGames > 0;
        }
    },

    setID: function setID(id) {
        var idNode = this.node.getChildByName("id");
        if (idNode) {
            var lbl = idNode.getComponent(cc.Label);
            lbl.string = "ID:" + id;
        }

        this._userId = id;
        if (this._sprIcon) {
            this._sprIcon.setUserID(id);
        }
    },

    setOffline: function setOffline(isOffline) {
        this._isOffline = isOffline;
        if (this._offline) {
            this._offline.active = this._isOffline && this._userName != "";
        }
    },

    chat: function chat(content) {
        if (this._chatBubble == null || this._emoji == null) {
            return;
        }
        this._emoji.active = false;
        this._chatBubble.active = true;
        this._chatBubble.getComponent(cc.Label).string = content;
        this._chatBubble.getChildByName("New Label").getComponent(cc.Label).string = content;
        this._lastChatTime = 3;
    },

    emoji: function emoji(_emoji) {
        //emoji = JSON.parse(emoji);
        if (this._emoji == null || this._emoji == null) {
            return;
        }
        console.log(_emoji);
        this._chatBubble.active = false;
        this._emoji.active = true;
        this._emoji.getComponent(cc.Animation).play(_emoji);
        this._lastChatTime = 3;
    },

    voiceMsg: function voiceMsg(show) {
        if (this._voicemsg) {
            this._voicemsg.active = show;
        }
    },

    refreshXuanPaiState: function refreshXuanPaiState() {
        if (this._xuanpai == null) {
            return;
        }

        this._xuanpai.active = cc.vv.gameNetMgr.isHuanSanZhang;
        if (cc.vv.gameNetMgr.isHuanSanZhang == false) {
            return;
        }

        this._xuanpai.getChildByName("xz").active = false;
        this._xuanpai.getChildByName("xd").active = false;

        var seat = cc.vv.gameNetMgr.getSeatByID(this._userId);
        if (seat) {
            if (seat.huanpais == null) {
                this._xuanpai.getChildByName("xz").active = true;
            } else {
                this._xuanpai.getChildByName("xd").active = true;
            }
        }
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        if (this._lastChatTime > 0) {
            this._lastChatTime -= dt;
            if (this._lastChatTime < 0) {
                this._chatBubble.active = false;
                this._emoji.active = false;
                this._emoji.getComponent(cc.Animation).stop();
            }
        }
    }
});

cc._RF.pop();
},{}],"Settings":[function(require,module,exports){
"use strict";
cc._RF.push(module, '4c04fyd89JAZY7qGjvubi+f', 'Settings');
// scripts/components/Settings.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _btnYXOpen: null,
        _btnYXClose: null,
        _btnYYOpen: null,
        _btnYYClose: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }

        this._btnYXOpen = this.node.getChildByName("yinxiao").getChildByName("btn_yx_open");
        this._btnYXClose = this.node.getChildByName("yinxiao").getChildByName("btn_yx_close");

        this._btnYYOpen = this.node.getChildByName("yinyue").getChildByName("btn_yy_open");
        this._btnYYClose = this.node.getChildByName("yinyue").getChildByName("btn_yy_close");

        this.initButtonHandler(this.node.getChildByName("btn_close"));
        this.initButtonHandler(this.node.getChildByName("btn_exit"));

        this.initButtonHandler(this._btnYXOpen);
        this.initButtonHandler(this._btnYXClose);
        this.initButtonHandler(this._btnYYOpen);
        this.initButtonHandler(this._btnYYClose);

        var slider = this.node.getChildByName("yinxiao").getChildByName("progress");
        cc.vv.utils.addSlideEvent(slider, this.node, "Settings", "onSlided");

        var slider = this.node.getChildByName("yinyue").getChildByName("progress");
        cc.vv.utils.addSlideEvent(slider, this.node, "Settings", "onSlided");

        this.refreshVolume();
    },

    onSlided: function onSlided(slider) {
        if (slider.node.parent.name == "yinxiao") {
            cc.vv.audioMgr.setSFXVolume(slider.progress);
        } else if (slider.node.parent.name == "yinyue") {
            cc.vv.audioMgr.setBGMVolume(slider.progress);
        }
        this.refreshVolume();
    },

    initButtonHandler: function initButtonHandler(btn) {
        cc.vv.utils.addClickEvent(btn, this.node, "Settings", "onBtnClicked");
    },

    refreshVolume: function refreshVolume() {

        this._btnYXClose.active = cc.vv.audioMgr.sfxVolume > 0;
        this._btnYXOpen.active = !this._btnYXClose.active;

        var yx = this.node.getChildByName("yinxiao");
        var width = 430 * cc.vv.audioMgr.sfxVolume;
        var progress = yx.getChildByName("progress");
        progress.getComponent(cc.Slider).progress = cc.vv.audioMgr.sfxVolume;
        progress.getChildByName("progress").width = width;
        //yx.getChildByName("btn_progress").x = progress.x + width;


        this._btnYYClose.active = cc.vv.audioMgr.bgmVolume > 0;
        this._btnYYOpen.active = !this._btnYYClose.active;
        var yy = this.node.getChildByName("yinyue");
        var width = 430 * cc.vv.audioMgr.bgmVolume;
        var progress = yy.getChildByName("progress");
        progress.getComponent(cc.Slider).progress = cc.vv.audioMgr.bgmVolume;

        progress.getChildByName("progress").width = width;
        //yy.getChildByName("btn_progress").x = progress.x + width;
    },

    onBtnClicked: function onBtnClicked(event) {
        if (event.target.name == "btn_close") {
            this.node.active = false;
        } else if (event.target.name == "btn_exit") {
            cc.sys.localStorage.removeItem("wx_account");
            cc.sys.localStorage.removeItem("wx_sign");
            cc.director.loadScene("login");
        } else if (event.target.name == "btn_yx_open") {
            cc.vv.audioMgr.setSFXVolume(1.0);
            this.refreshVolume();
        } else if (event.target.name == "btn_yx_close") {
            cc.vv.audioMgr.setSFXVolume(0);
            this.refreshVolume();
        } else if (event.target.name == "btn_yy_open") {
            cc.vv.audioMgr.setBGMVolume(1);
            this.refreshVolume();
        } else if (event.target.name == "btn_yy_close") {
            cc.vv.audioMgr.setBGMVolume(0);
            this.refreshVolume();
        }
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"TimePointer":[function(require,module,exports){
"use strict";
cc._RF.push(module, '5b586erPK1H5bFfrMKWs+Y6', 'TimePointer');
// scripts/components/TimePointer.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        _arrow: null,
        _pointer: null,
        _timeLabel: null,
        _time: -1,
        _alertTime: -1
    },

    // use this for initialization
    onLoad: function onLoad() {
        var gameChild = this.node.getChildByName("game");
        this._arrow = gameChild.getChildByName("arrow");
        this._pointer = this._arrow.getChildByName("pointer");
        this.initPointer();

        this._timeLabel = this._arrow.getChildByName("lblTime").getComponent(cc.Label);
        this._timeLabel.string = "00";

        var self = this;

        this.node.on('game_begin', function (data) {
            self.initPointer();
        });

        this.node.on('game_chupai', function (data) {
            self.initPointer();
            self._time = 10;
            self._alertTime = 3;
        });
    },

    initPointer: function initPointer() {
        if (cc.vv == null) {
            return;
        }
        this._arrow.active = cc.vv.gameNetMgr.gamestate == "playing";
        if (!this._arrow.active) {
            return;
        }
        var turn = cc.vv.gameNetMgr.turn;
        var localIndex = cc.vv.gameNetMgr.getLocalIndex(turn);
        for (var i = 0; i < this._pointer.children.length; ++i) {
            this._pointer.children[i].active = i == localIndex;
        }
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        if (this._time > 0) {
            this._time -= dt;
            if (this._alertTime > 0 && this._time < this._alertTime) {
                cc.vv.audioMgr.playSFX("timeup_alarm.mp3");
                this._alertTime = -1;
            }
            var pre = "";
            if (this._time < 0) {
                this._time = 0;
            }

            var t = Math.ceil(this._time);
            if (t < 10) {
                pre = "0";
            }
            this._timeLabel.string = pre + t;
        }
    }
});

cc._RF.pop();
},{}],"UserInfoShow":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'fe4f16CAmpBlZphnpsH1ETv', 'UserInfoShow');
// scripts/components/UserInfoShow.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _userinfo: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }

        this._userinfo = cc.find("Canvas/userinfo");
        this._userinfo.active = false;
        cc.vv.utils.addClickEvent(this._userinfo, this.node, "UserInfoShow", "onClicked");

        cc.vv.userinfoShow = this;
    },

    show: function show(name, userId, iconSprite, sex, ip) {
        if (userId != null && userId > 0) {
            this._userinfo.active = true;
            this._userinfo.getChildByName("icon").getComponent(cc.Sprite).spriteFrame = iconSprite.spriteFrame;
            this._userinfo.getChildByName("name").getComponent(cc.Label).string = name;
            this._userinfo.getChildByName("ip").getComponent(cc.Label).string = "IP: " + ip.replace("::ffff:", "");
            this._userinfo.getChildByName("id").getComponent(cc.Label).string = "ID: " + userId;

            var sex_female = this._userinfo.getChildByName("sex_female");
            sex_female.active = false;

            var sex_male = this._userinfo.getChildByName("sex_male");
            sex_male.active = false;

            if (sex == 1) {
                sex_male.active = true;
            } else if (sex == 2) {
                sex_female.active = true;
            }
        }
    },

    onClicked: function onClicked() {
        this._userinfo.active = false;
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"UserMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, '74d78JBqHdDKY6hckY2YuL+', 'UserMgr');
// scripts/UserMgr.js

"use strict";

cc.Class({
    extends: cc.Component,
    properties: {
        account: null,
        userId: null,
        userName: null,
        lv: 0,
        exp: 0,
        coins: 0,
        gems: 0,
        sign: 0,
        ip: "",
        sex: 0,
        roomData: null,

        oldRoomId: null
    },

    guestAuth: function guestAuth() {
        var account = cc.args["account"];
        if (account == null) {
            account = cc.sys.localStorage.getItem("account");
        }

        if (account == null) {
            account = Date.now();
            cc.sys.localStorage.setItem("account", account);
        }

        cc.vv.http.sendRequest("/guest", { account: account }, this.onAuth);
    },

    onAuth: function onAuth(ret) {
        var self = cc.vv.userMgr;
        if (ret.errcode !== 0) {
            console.log(ret.errmsg);
        } else {
            self.account = ret.account;
            self.sign = ret.sign;
            cc.vv.http.url = "http://" + cc.vv.SI.hall;
            self.login();
        }
    },

    login: function login() {
        var self = this;
        var onLogin = function onLogin(ret) {
            if (ret.errcode !== 0) {
                console.log(ret.errmsg);
            } else {
                if (!ret.userid) {
                    //jump to register user info.
                    cc.director.loadScene("createrole");
                } else {
                    console.log(ret);
                    self.account = ret.account;
                    self.userId = ret.userid;
                    self.userName = ret.name;
                    self.lv = ret.lv;
                    self.exp = ret.exp;
                    self.coins = ret.coins;
                    self.gems = ret.gems;
                    self.roomData = ret.roomid;
                    self.sex = ret.sex;
                    self.ip = ret.ip;
                    cc.director.loadScene("hall");
                }
            }
        };
        cc.vv.wc.show("正在登录游戏");
        cc.vv.http.sendRequest("/login", { account: this.account, sign: this.sign }, onLogin);
    },

    create: function create(name) {
        var self = this;
        var onCreate = function onCreate(ret) {
            if (ret.errcode !== 0) {
                console.log(ret.errmsg);
            } else {
                self.login();
            }
        };

        var data = {
            account: this.account,
            sign: this.sign,
            name: name
        };
        cc.vv.http.sendRequest("/create_user", data, onCreate);
    },

    enterRoom: function enterRoom(roomId, callback) {
        var self = this;
        var onEnter = function onEnter(ret) {
            if (ret.errcode !== 0) {
                if (ret.errcode == -1) {
                    setTimeout(function () {
                        self.enterRoom(roomId, callback);
                    }, 5000);
                } else {
                    cc.vv.wc.hide();
                    if (callback != null) {
                        callback(ret);
                    }
                }
            } else {
                if (callback != null) {
                    callback(ret);
                }
                cc.vv.gameNetMgr.connectGameServer(ret);
            }
        };

        var data = {
            account: cc.vv.userMgr.account,
            sign: cc.vv.userMgr.sign,
            roomid: roomId
        };
        cc.vv.wc.show("正在进入房间 " + roomId);
        cc.vv.http.sendRequest("/enter_private_room", data, onEnter);
    },
    getHistoryList: function getHistoryList(callback) {
        var self = this;
        var onGet = function onGet(ret) {
            if (ret.errcode !== 0) {
                console.log(ret.errmsg);
            } else {
                console.log(ret.history);
                if (callback != null) {
                    callback(ret.history);
                }
            }
        };

        var data = {
            account: cc.vv.userMgr.account,
            sign: cc.vv.userMgr.sign
        };
        cc.vv.http.sendRequest("/get_history_list", data, onGet);
    },
    getGamesOfRoom: function getGamesOfRoom(uuid, callback) {
        var self = this;
        var onGet = function onGet(ret) {
            if (ret.errcode !== 0) {
                console.log(ret.errmsg);
            } else {
                console.log(ret.data);
                callback(ret.data);
            }
        };

        var data = {
            account: cc.vv.userMgr.account,
            sign: cc.vv.userMgr.sign,
            uuid: uuid
        };
        cc.vv.http.sendRequest("/get_games_of_room", data, onGet);
    },

    getDetailOfGame: function getDetailOfGame(uuid, index, callback) {
        var self = this;
        var onGet = function onGet(ret) {
            if (ret.errcode !== 0) {
                console.log(ret.errmsg);
            } else {
                console.log(ret.data);
                callback(ret.data);
            }
        };

        var data = {
            account: cc.vv.userMgr.account,
            sign: cc.vv.userMgr.sign,
            uuid: uuid,
            index: index
        };
        cc.vv.http.sendRequest("/get_detail_of_game", data, onGet);
    }
});

cc._RF.pop();
},{}],"Utils":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'b717fzww0hNzIqvNbb1t9wx', 'Utils');
// scripts/Utils.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
    },

    addClickEvent: function addClickEvent(node, target, component, handler) {
        console.log(component + ":" + handler);
        var eventHandler = new cc.Component.EventHandler();
        eventHandler.target = target;
        eventHandler.component = component;
        eventHandler.handler = handler;

        var clickEvents = node.getComponent(cc.Button).clickEvents;
        clickEvents.push(eventHandler);
    },

    addSlideEvent: function addSlideEvent(node, target, component, handler) {
        var eventHandler = new cc.Component.EventHandler();
        eventHandler.target = target;
        eventHandler.component = component;
        eventHandler.handler = handler;

        var slideEvents = node.getComponent(cc.Slider).slideEvents;
        slideEvents.push(eventHandler);
    }

});

cc._RF.pop();
},{}],"VoiceMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, '1f066RbLAxKGJZtkDFO2kq/', 'VoiceMgr');
// scripts/VoiceMgr.js

"use strict";

var radix = 12;
var base = 128 - radix;
function crypto(value) {
    value -= base;
    var h = Math.floor(value / radix) + base;
    var l = value % radix + base;
    return String.fromCharCode(h) + String.fromCharCode(l);
}

var encodermap = {};
var decodermap = {};
for (var i = 0; i < 256; ++i) {
    var code = null;
    var v = i + 1;
    if (v >= base) {
        code = crypto(v);
    } else {
        code = String.fromCharCode(v);
    }

    encodermap[i] = code;
    decodermap[code] = i;
}

function encode(data) {
    var content = "";
    var len = data.length;
    var a = len >> 24 & 0xff;
    var b = len >> 16 & 0xff;
    var c = len >> 8 & 0xff;
    var d = len & 0xff;
    content += encodermap[a];
    content += encodermap[b];
    content += encodermap[c];
    content += encodermap[d];
    for (var i = 0; i < data.length; ++i) {
        content += encodermap[data[i]];
    }
    return content;
}

function getCode(content, index) {
    var c = content.charCodeAt(index);
    if (c >= base) {
        c = content.charAt(index) + content.charAt(index + 1);
    } else {
        c = content.charAt(index);
    }
    return c;
}
function decode(content) {
    var index = 0;
    var len = 0;
    for (var i = 0; i < 4; ++i) {
        var c = getCode(content, index);
        index += c.length;
        var v = decodermap[c];
        len |= v << (3 - i) * 8;
    }

    var newData = new Uint8Array(len);
    var cnt = 0;
    while (index < content.length) {
        var c = getCode(content, index);
        index += c.length;
        newData[cnt] = decodermap[c];
        cnt++;
    }
    return newData;
}

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        onPlayCallback: null,
        _voiceMediaPath: null
    },

    // use this for initialization
    init: function init() {
        /*
        var url = cc.url.raw("resources/test.amr");
        var fileData = jsb.fileUtils.getDataFromFile(url);
        var content = "";
        var sep = "";
        for(var i = 0; i < fileData.length; ++i){
            content += sep + fileData[i];
            sep = ",";
        }
        
        var url = cc.url.raw("resources/test.txt");
        jsb.fileUtils.writeStringToFile(content,url);
        
        var url = cc.url.raw("resources/test2.amrs");
        var content = encode(fileData);
        jsb.fileUtils.writeStringToFile(content,url);
        
        var url = cc.url.raw("resources/test2.amr");
        jsb.fileUtils.writeDataToFile(decode(content),url);
        */

        if (cc.sys.isNative) {
            this._voiceMediaPath = jsb.fileUtils.getWritablePath() + "/voicemsgs/";
            this.setStorageDir(this._voiceMediaPath);
        }
    },

    prepare: function prepare(filename) {
        if (!cc.sys.isNative) {
            return;
        }
        cc.vv.audioMgr.pauseAll();
        this.clearCache(filename);
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            jsb.reflection.callStaticMethod("com/vivigames/voicesdk/VoiceRecorder", "prepare", "(Ljava/lang/String;)V", filename);
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod("VoiceSDK", "prepareRecord:", filename);
        }
    },

    release: function release() {
        if (!cc.sys.isNative) {
            return;
        }
        cc.vv.audioMgr.resumeAll();
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            jsb.reflection.callStaticMethod("com/vivigames/voicesdk/VoiceRecorder", "release", "()V");
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod("VoiceSDK", "finishRecord");
        }
    },

    cancel: function cancel() {
        if (!cc.sys.isNative) {
            return;
        }
        cc.vv.audioMgr.resumeAll();
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            jsb.reflection.callStaticMethod("com/vivigames/voicesdk/VoiceRecorder", "cancel", "()V");
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod("VoiceSDK", "cancelRecord");
        }
    },

    writeVoice: function writeVoice(filename, voiceData) {
        if (!cc.sys.isNative) {
            return;
        }
        if (voiceData && voiceData.length > 0) {
            var fileData = decode(voiceData);
            var url = this._voiceMediaPath + filename;
            this.clearCache(filename);
            jsb.fileUtils.writeDataToFile(fileData, url);
        }
    },

    clearCache: function clearCache(filename) {
        if (cc.sys.isNative) {
            var url = this._voiceMediaPath + filename;
            //console.log("check file:" + url);
            if (jsb.fileUtils.isFileExist(url)) {
                //console.log("remove:" + url);
                jsb.fileUtils.removeFile(url);
            }
            if (jsb.fileUtils.isFileExist(url + ".wav")) {
                //console.log("remove:" + url + ".wav");
                jsb.fileUtils.removeFile(url + ".wav");
            }
        }
    },

    play: function play(filename) {
        if (!cc.sys.isNative) {
            return;
        }
        cc.vv.audioMgr.pauseAll();
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            jsb.reflection.callStaticMethod("com/vivigames/voicesdk/VoicePlayer", "play", "(Ljava/lang/String;)V", filename);
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod("VoiceSDK", "play:", filename);
        } else {}
    },

    stop: function stop() {
        if (!cc.sys.isNative) {
            return;
        }
        cc.vv.audioMgr.resumeAll();
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            jsb.reflection.callStaticMethod("com/vivigames/voicesdk/VoicePlayer", "stop", "()V");
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod("VoiceSDK", "stopPlay");
        } else {}
    },

    getVoiceLevel: function getVoiceLevel(maxLevel) {
        return Math.floor(Math.random() * maxLevel + 1);
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            return jsb.reflection.callStaticMethod("com/vivigames/voicesdk/VoiceRecorder", "getVoiceLevel", "(I)I", maxLevel);
        } else if (cc.sys.os == cc.sys.OS_IOS) {} else {
            return Math.floor(Math.random() * maxLevel + 1);
        }
    },

    getVoiceData: function getVoiceData(filename) {
        if (cc.sys.isNative) {
            var url = this._voiceMediaPath + filename;
            console.log("getVoiceData:" + url);
            var fileData = jsb.fileUtils.getDataFromFile(url);
            if (fileData) {
                var content = encode(fileData);
                return content;
            }
        }
        return "";
    },

    download: function download() {},
    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    setStorageDir: function setStorageDir(dir) {
        if (!cc.sys.isNative) {
            return;
        }
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            jsb.reflection.callStaticMethod("com/vivigames/voicesdk/VoiceRecorder", "setStorageDir", "(Ljava/lang/String;)V", dir);
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod("VoiceSDK", "setStorageDir:", dir);
            if (!jsb.fileUtils.isDirectoryExist(dir)) {
                jsb.fileUtils.createDirectory(dir);
            }
        }
    }
});

cc._RF.pop();
},{}],"Voice":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'f6db9z0CxdEzpRVgU569dDu', 'Voice');
// scripts/components/Voice.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _lastTouchTime: null,
        _voice: null,
        _volume: null,
        _voice_failed: null,
        _lastCheckTime: -1,
        _timeBar: null,
        MAX_TIME: 15000
    },

    // use this for initialization
    onLoad: function onLoad() {

        this._voice = cc.find("Canvas/voice");
        this._voice.active = false;

        this._voice_failed = cc.find("Canvas/voice/voice_failed");
        this._voice_failed.active = false;

        this._timeBar = cc.find("Canvas/voice/time");
        this._timeBar.scaleX = 0.0;

        this._volume = cc.find("Canvas/voice/volume");
        for (var i = 1; i < this._volume.children.length; ++i) {
            this._volume.children[i].active = false;
        }

        var btnVoice = cc.find("Canvas/voice/voice_failed/btn_ok");
        if (btnVoice) {
            cc.vv.utils.addClickEvent(btnVoice, this.node, "Voice", "onBtnOKClicked");
        }

        var self = this;
        var btnVoice = cc.find("Canvas/btn_voice");
        if (btnVoice) {
            btnVoice.on(cc.Node.EventType.TOUCH_START, function () {
                console.log("cc.Node.EventType.TOUCH_START");
                cc.vv.voiceMgr.prepare("record.amr");
                self._lastTouchTime = Date.now();
                self._voice.active = true;
                self._voice_failed.active = false;
            });

            btnVoice.on(cc.Node.EventType.TOUCH_MOVE, function () {
                console.log("cc.Node.EventType.TOUCH_MOVE");
            });

            btnVoice.on(cc.Node.EventType.TOUCH_END, function () {
                console.log("cc.Node.EventType.TOUCH_END");
                if (Date.now() - self._lastTouchTime < 1000) {
                    self._voice_failed.active = true;
                    cc.vv.voiceMgr.cancel();
                } else {
                    self.onVoiceOK();
                }
                self._lastTouchTime = null;
            });

            btnVoice.on(cc.Node.EventType.TOUCH_CANCEL, function () {
                console.log("cc.Node.EventType.TOUCH_CANCEL");
                cc.vv.voiceMgr.cancel();
                self._lastTouchTime = null;
                self._voice.active = false;
            });
        }
    },

    onVoiceOK: function onVoiceOK() {
        if (this._lastTouchTime != null) {
            cc.vv.voiceMgr.release();
            var time = Date.now() - this._lastTouchTime;
            var msg = cc.vv.voiceMgr.getVoiceData("record.amr");
            cc.vv.net.send("voice_msg", { msg: msg, time: time });
        }
        this._voice.active = false;
    },

    onBtnOKClicked: function onBtnOKClicked() {
        this._voice.active = false;
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        if (this._voice.active == true && this._voice_failed.active == false) {
            if (Date.now() - this._lastCheckTime > 300) {
                for (var i = 0; i < this._volume.children.length; ++i) {
                    this._volume.children[i].active = false;
                }
                var v = cc.vv.voiceMgr.getVoiceLevel(7);
                if (v >= 1 && v <= 7) {
                    this._volume.children[v - 1].active = true;
                }
                this._lastCheckTime = Date.now();
            }
        }

        if (this._lastTouchTime) {
            var time = Date.now() - this._lastTouchTime;
            if (time >= this.MAX_TIME) {
                this.onVoiceOK();
                this._lastTouchTime = null;
            } else {
                var percent = time / this.MAX_TIME;
                this._timeBar.scaleX = 1 - percent;
            }
        }
    }
});

cc._RF.pop();
},{}],"WaitingConnection":[function(require,module,exports){
"use strict";
cc._RF.push(module, '10e32jDstpLhIGHWrQEq2vN', 'WaitingConnection');
// scripts/components/WaitingConnection.js

"use strict";

cc.Class({
    extends: cc.Component,
    properties: {
        target: cc.Node,
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _isShow: false,
        lblContent: cc.Label
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return null;
        }

        cc.vv.wc = this;
        this.node.active = this._isShow;
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        this.target.rotation = this.target.rotation - dt * 45;
    },

    show: function show(content) {
        this._isShow = true;
        if (this.node) {
            this.node.active = this._isShow;
        }
        if (this.lblContent) {
            if (content == null) {
                content = "";
            }
            this.lblContent.string = content;
        }
    },
    hide: function hide() {
        this._isShow = false;
        if (this.node) {
            this.node.active = this._isShow;
        }
    }
});

cc._RF.pop();
},{}],"socket-io":[function(require,module,exports){
(function (global){
"use strict";
cc._RF.push(module, '393290vPc1IIYfh8FrmxcNZ', 'socket-io');
// scripts/3rdparty/socket-io.js

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (!CC_JSB && !cc.sys.isNative) {
	(function (f) {
		if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && typeof module !== "undefined") {
			module.exports = f();
		} else if (typeof define === "function" && define.amd) {
			define([], f);
		} else {
			var g;if (typeof window !== "undefined") {
				g = window;
			} else if (typeof global !== "undefined") {
				g = global;
			} else if (typeof self !== "undefined") {
				g = self;
			} else {
				g = this;
			}g.io = f();
		}
	})(function () {
		var define, module, exports;return function e(t, n, r) {
			function s(o, u) {
				if (!n[o]) {
					if (!t[o]) {
						var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
					}var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
						var n = t[o][1][e];return s(n ? n : e);
					}, l, l.exports, e, t, n, r);
				}return n[o].exports;
			}var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
				s(r[o]);
			}return s;
		}({ 1: [function (_dereq_, module, exports) {

				module.exports = _dereq_('./lib/');
			}, { "./lib/": 2 }], 2: [function (_dereq_, module, exports) {

				module.exports = _dereq_('./socket');

				/**
     * Exports parser
     *
     * @api public
     *
     */
				module.exports.parser = _dereq_('engine.io-parser');
			}, { "./socket": 3, "engine.io-parser": 19 }], 3: [function (_dereq_, module, exports) {
				(function (global) {
					/**
      * Module dependencies.
      */

					var transports = _dereq_('./transports');
					var Emitter = _dereq_('component-emitter');
					var debug = _dereq_('debug')('engine.io-client:socket');
					var index = _dereq_('indexof');
					var parser = _dereq_('engine.io-parser');
					var parseuri = _dereq_('parseuri');
					var parsejson = _dereq_('parsejson');
					var parseqs = _dereq_('parseqs');

					/**
      * Module exports.
      */

					module.exports = Socket;

					/**
      * Noop function.
      *
      * @api private
      */

					function noop() {}

					/**
      * Socket constructor.
      *
      * @param {String|Object} uri or options
      * @param {Object} options
      * @api public
      */

					function Socket(uri, opts) {
						if (!(this instanceof Socket)) return new Socket(uri, opts);

						opts = opts || {};

						if (uri && 'object' == (typeof uri === "undefined" ? "undefined" : _typeof(uri))) {
							opts = uri;
							uri = null;
						}

						if (uri) {
							uri = parseuri(uri);
							opts.hostname = uri.host;
							opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
							opts.port = uri.port;
							if (uri.query) opts.query = uri.query;
						} else if (opts.host) {
							opts.hostname = parseuri(opts.host).host;
						}

						this.secure = null != opts.secure ? opts.secure : global.location && 'https:' == location.protocol;

						if (opts.hostname && !opts.port) {
							// if no port is specified manually, use the protocol default
							opts.port = this.secure ? '443' : '80';
						}

						this.agent = opts.agent || false;
						this.hostname = opts.hostname || (global.location ? location.hostname : 'localhost');
						this.port = opts.port || (global.location && location.port ? location.port : this.secure ? 443 : 80);
						this.query = opts.query || {};
						if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
						this.upgrade = false !== opts.upgrade;
						this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
						this.forceJSONP = !!opts.forceJSONP;
						this.jsonp = false !== opts.jsonp;
						this.forceBase64 = !!opts.forceBase64;
						this.enablesXDR = !!opts.enablesXDR;
						this.timestampParam = opts.timestampParam || 't';
						this.timestampRequests = opts.timestampRequests;
						this.transports = opts.transports || ['polling', 'websocket'];
						this.readyState = '';
						this.writeBuffer = [];
						this.policyPort = opts.policyPort || 843;
						this.rememberUpgrade = opts.rememberUpgrade || false;
						this.binaryType = null;
						this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
						this.perMessageDeflate = false !== opts.perMessageDeflate ? opts.perMessageDeflate || {} : false;

						if (true === this.perMessageDeflate) this.perMessageDeflate = {};
						if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
							this.perMessageDeflate.threshold = 1024;
						}

						// SSL options for Node.js client
						this.pfx = opts.pfx || null;
						this.key = opts.key || null;
						this.passphrase = opts.passphrase || null;
						this.cert = opts.cert || null;
						this.ca = opts.ca || null;
						this.ciphers = opts.ciphers || null;
						this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;

						// other options for Node.js client
						var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global;
						if (freeGlobal.global === freeGlobal) {
							if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
								this.extraHeaders = opts.extraHeaders;
							}
						}

						this.open();
					}

					Socket.priorWebsocketSuccess = false;

					/**
      * Mix in `Emitter`.
      */

					Emitter(Socket.prototype);

					/**
      * Protocol version.
      *
      * @api public
      */

					Socket.protocol = parser.protocol; // this is an int

					/**
      * Expose deps for legacy compatibility
      * and standalone browser access.
      */

					Socket.Socket = Socket;
					Socket.Transport = _dereq_('./transport');
					Socket.transports = _dereq_('./transports');
					Socket.parser = _dereq_('engine.io-parser');

					/**
      * Creates transport of the given type.
      *
      * @param {String} transport name
      * @return {Transport}
      * @api private
      */

					Socket.prototype.createTransport = function (name) {
						debug('creating transport "%s"', name);
						var query = clone(this.query);

						// append engine.io protocol identifier
						query.EIO = parser.protocol;

						// transport name
						query.transport = name;

						// session id if we already have one
						if (this.id) query.sid = this.id;

						var transport = new transports[name]({
							agent: this.agent,
							hostname: this.hostname,
							port: this.port,
							secure: this.secure,
							path: this.path,
							query: query,
							forceJSONP: this.forceJSONP,
							jsonp: this.jsonp,
							forceBase64: this.forceBase64,
							enablesXDR: this.enablesXDR,
							timestampRequests: this.timestampRequests,
							timestampParam: this.timestampParam,
							policyPort: this.policyPort,
							socket: this,
							pfx: this.pfx,
							key: this.key,
							passphrase: this.passphrase,
							cert: this.cert,
							ca: this.ca,
							ciphers: this.ciphers,
							rejectUnauthorized: this.rejectUnauthorized,
							perMessageDeflate: this.perMessageDeflate,
							extraHeaders: this.extraHeaders
						});

						return transport;
					};

					function clone(obj) {
						var o = {};
						for (var i in obj) {
							if (obj.hasOwnProperty(i)) {
								o[i] = obj[i];
							}
						}
						return o;
					}

					/**
      * Initializes transport to use and starts probe.
      *
      * @api private
      */
					Socket.prototype.open = function () {
						var transport;
						if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
							transport = 'websocket';
						} else if (0 === this.transports.length) {
							// Emit error on next tick so it can be listened to
							var self = this;
							setTimeout(function () {
								self.emit('error', 'No transports available');
							}, 0);
							return;
						} else {
							transport = this.transports[0];
						}
						this.readyState = 'opening';

						// Retry with the next transport if the transport is disabled (jsonp: false)
						try {
							transport = this.createTransport(transport);
						} catch (e) {
							this.transports.shift();
							this.open();
							return;
						}

						transport.open();
						this.setTransport(transport);
					};

					/**
      * Sets the current transport. Disables the existing one (if any).
      *
      * @api private
      */

					Socket.prototype.setTransport = function (transport) {
						debug('setting transport %s', transport.name);
						var self = this;

						if (this.transport) {
							debug('clearing existing transport %s', this.transport.name);
							this.transport.removeAllListeners();
						}

						// set up transport
						this.transport = transport;

						// set up transport listeners
						transport.on('drain', function () {
							self.onDrain();
						}).on('packet', function (packet) {
							self.onPacket(packet);
						}).on('error', function (e) {
							self.onError(e);
						}).on('close', function () {
							self.onClose('transport close');
						});
					};

					/**
      * Probes a transport.
      *
      * @param {String} transport name
      * @api private
      */

					Socket.prototype.probe = function (name) {
						debug('probing transport "%s"', name);
						var transport = this.createTransport(name, { probe: 1 }),
						    failed = false,
						    self = this;

						Socket.priorWebsocketSuccess = false;

						function onTransportOpen() {
							if (self.onlyBinaryUpgrades) {
								var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
								failed = failed || upgradeLosesBinary;
							}
							if (failed) return;

							debug('probe transport "%s" opened', name);
							transport.send([{ type: 'ping', data: 'probe' }]);
							transport.once('packet', function (msg) {
								if (failed) return;
								if ('pong' == msg.type && 'probe' == msg.data) {
									debug('probe transport "%s" pong', name);
									self.upgrading = true;
									self.emit('upgrading', transport);
									if (!transport) return;
									Socket.priorWebsocketSuccess = 'websocket' == transport.name;

									debug('pausing current transport "%s"', self.transport.name);
									self.transport.pause(function () {
										if (failed) return;
										if ('closed' == self.readyState) return;
										debug('changing transport and sending upgrade packet');

										cleanup();

										self.setTransport(transport);
										transport.send([{ type: 'upgrade' }]);
										self.emit('upgrade', transport);
										transport = null;
										self.upgrading = false;
										self.flush();
									});
								} else {
									debug('probe transport "%s" failed', name);
									var err = new Error('probe error');
									err.transport = transport.name;
									self.emit('upgradeError', err);
								}
							});
						}

						function freezeTransport() {
							if (failed) return;

							// Any callback called by transport should be ignored since now
							failed = true;

							cleanup();

							transport.close();
							transport = null;
						}

						//Handle any error that happens while probing
						function onerror(err) {
							var error = new Error('probe error: ' + err);
							error.transport = transport.name;

							freezeTransport();

							debug('probe transport "%s" failed because of error: %s', name, err);

							self.emit('upgradeError', error);
						}

						function onTransportClose() {
							onerror("transport closed");
						}

						//When the socket is closed while we're probing
						function onclose() {
							onerror("socket closed");
						}

						//When the socket is upgraded while we're probing
						function onupgrade(to) {
							if (transport && to.name != transport.name) {
								debug('"%s" works - aborting "%s"', to.name, transport.name);
								freezeTransport();
							}
						}

						//Remove all listeners on the transport and on self
						function cleanup() {
							transport.removeListener('open', onTransportOpen);
							transport.removeListener('error', onerror);
							transport.removeListener('close', onTransportClose);
							self.removeListener('close', onclose);
							self.removeListener('upgrading', onupgrade);
						}

						transport.once('open', onTransportOpen);
						transport.once('error', onerror);
						transport.once('close', onTransportClose);

						this.once('close', onclose);
						this.once('upgrading', onupgrade);

						transport.open();
					};

					/**
      * Called when connection is deemed open.
      *
      * @api public
      */

					Socket.prototype.onOpen = function () {
						debug('socket open');
						this.readyState = 'open';
						Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
						this.emit('open');
						this.flush();

						// we check for `readyState` in case an `open`
						// listener already closed the socket
						if ('open' == this.readyState && this.upgrade && this.transport.pause) {
							debug('starting upgrade probes');
							for (var i = 0, l = this.upgrades.length; i < l; i++) {
								this.probe(this.upgrades[i]);
							}
						}
					};

					/**
      * Handles a packet.
      *
      * @api private
      */

					Socket.prototype.onPacket = function (packet) {
						if ('opening' == this.readyState || 'open' == this.readyState) {
							debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

							this.emit('packet', packet);

							// Socket is live - any packet counts
							this.emit('heartbeat');

							switch (packet.type) {
								case 'open':
									this.onHandshake(parsejson(packet.data));
									break;

								case 'pong':
									this.setPing();
									this.emit('pong');
									break;

								case 'error':
									var err = new Error('server error');
									err.code = packet.data;
									this.onError(err);
									break;

								case 'message':
									this.emit('data', packet.data);
									this.emit('message', packet.data);
									break;
							}
						} else {
							debug('packet received with socket readyState "%s"', this.readyState);
						}
					};

					/**
      * Called upon handshake completion.
      *
      * @param {Object} handshake obj
      * @api private
      */

					Socket.prototype.onHandshake = function (data) {
						this.emit('handshake', data);
						this.id = data.sid;
						this.transport.query.sid = data.sid;
						this.upgrades = this.filterUpgrades(data.upgrades);
						this.pingInterval = data.pingInterval;
						this.pingTimeout = data.pingTimeout;
						this.onOpen();
						// In case open handler closes socket
						if ('closed' == this.readyState) return;
						this.setPing();

						// Prolong liveness of socket on heartbeat
						this.removeListener('heartbeat', this.onHeartbeat);
						this.on('heartbeat', this.onHeartbeat);
					};

					/**
      * Resets ping timeout.
      *
      * @api private
      */

					Socket.prototype.onHeartbeat = function (timeout) {
						clearTimeout(this.pingTimeoutTimer);
						var self = this;
						self.pingTimeoutTimer = setTimeout(function () {
							if ('closed' == self.readyState) return;
							self.onClose('ping timeout');
						}, timeout || self.pingInterval + self.pingTimeout);
					};

					/**
      * Pings server every `this.pingInterval` and expects response
      * within `this.pingTimeout` or closes connection.
      *
      * @api private
      */

					Socket.prototype.setPing = function () {
						var self = this;
						clearTimeout(self.pingIntervalTimer);
						self.pingIntervalTimer = setTimeout(function () {
							debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
							self.ping();
							self.onHeartbeat(self.pingTimeout);
						}, self.pingInterval);
					};

					/**
     * Sends a ping packet.
     *
     * @api private
     */

					Socket.prototype.ping = function () {
						var self = this;
						this.sendPacket('ping', function () {
							self.emit('ping');
						});
					};

					/**
      * Called on `drain` event
      *
      * @api private
      */

					Socket.prototype.onDrain = function () {
						this.writeBuffer.splice(0, this.prevBufferLen);

						// setting prevBufferLen = 0 is very important
						// for example, when upgrading, upgrade packet is sent over,
						// and a nonzero prevBufferLen could cause problems on `drain`
						this.prevBufferLen = 0;

						if (0 === this.writeBuffer.length) {
							this.emit('drain');
						} else {
							this.flush();
						}
					};

					/**
      * Flush write buffers.
      *
      * @api private
      */

					Socket.prototype.flush = function () {
						if ('closed' != this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
							debug('flushing %d packets in socket', this.writeBuffer.length);
							this.transport.send(this.writeBuffer);
							// keep track of current length of writeBuffer
							// splice writeBuffer and callbackBuffer on `drain`
							this.prevBufferLen = this.writeBuffer.length;
							this.emit('flush');
						}
					};

					/**
      * Sends a message.
      *
      * @param {String} message.
      * @param {Function} callback function.
      * @param {Object} options.
      * @return {Socket} for chaining.
      * @api public
      */

					Socket.prototype.write = Socket.prototype.send = function (msg, options, fn) {
						this.sendPacket('message', msg, options, fn);
						return this;
					};

					/**
      * Sends a packet.
      *
      * @param {String} packet type.
      * @param {String} data.
      * @param {Object} options.
      * @param {Function} callback function.
      * @api private
      */

					Socket.prototype.sendPacket = function (type, data, options, fn) {
						if ('function' == typeof data) {
							fn = data;
							data = undefined;
						}

						if ('function' == typeof options) {
							fn = options;
							options = null;
						}

						if ('closing' == this.readyState || 'closed' == this.readyState) {
							return;
						}

						options = options || {};
						options.compress = false !== options.compress;

						var packet = {
							type: type,
							data: data,
							options: options
						};
						this.emit('packetCreate', packet);
						this.writeBuffer.push(packet);
						if (fn) this.once('flush', fn);
						this.flush();
					};

					/**
      * Closes the connection.
      *
      * @api private
      */

					Socket.prototype.close = function () {
						if ('opening' == this.readyState || 'open' == this.readyState) {
							this.readyState = 'closing';

							var self = this;

							if (this.writeBuffer.length) {
								this.once('drain', function () {
									if (this.upgrading) {
										waitForUpgrade();
									} else {
										close();
									}
								});
							} else if (this.upgrading) {
								waitForUpgrade();
							} else {
								close();
							}
						}

						function close() {
							self.onClose('forced close');
							debug('socket closing - telling transport to close');
							self.transport.close();
						}

						function cleanupAndClose() {
							self.removeListener('upgrade', cleanupAndClose);
							self.removeListener('upgradeError', cleanupAndClose);
							close();
						}

						function waitForUpgrade() {
							// wait for upgrade to finish since we can't send packets while pausing a transport
							self.once('upgrade', cleanupAndClose);
							self.once('upgradeError', cleanupAndClose);
						}

						return this;
					};

					/**
      * Called upon transport error
      *
      * @api private
      */

					Socket.prototype.onError = function (err) {
						debug('socket error %j', err);
						Socket.priorWebsocketSuccess = false;
						this.emit('error', err);
						this.onClose('transport error', err);
					};

					/**
      * Called upon transport close.
      *
      * @api private
      */

					Socket.prototype.onClose = function (reason, desc) {
						if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
							debug('socket close with reason: "%s"', reason);
							var self = this;

							// clear timers
							clearTimeout(this.pingIntervalTimer);
							clearTimeout(this.pingTimeoutTimer);

							// stop event from firing again for transport
							this.transport.removeAllListeners('close');

							// ensure transport won't stay open
							this.transport.close();

							// ignore further transport communication
							this.transport.removeAllListeners();

							// set ready state
							this.readyState = 'closed';

							// clear session id
							this.id = null;

							// emit close event
							this.emit('close', reason, desc);

							// clean buffers after, so users can still
							// grab the buffers on `close` event
							self.writeBuffer = [];
							self.prevBufferLen = 0;
						}
					};

					/**
      * Filters upgrades, returning only those matching client transports.
      *
      * @param {Array} server upgrades
      * @api private
      *
      */

					Socket.prototype.filterUpgrades = function (upgrades) {
						var filteredUpgrades = [];
						for (var i = 0, j = upgrades.length; i < j; i++) {
							if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
						}
						return filteredUpgrades;
					};
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "./transport": 4, "./transports": 5, "component-emitter": 15, "debug": 17, "engine.io-parser": 19, "indexof": 23, "parsejson": 26, "parseqs": 27, "parseuri": 28 }], 4: [function (_dereq_, module, exports) {
				/**
     * Module dependencies.
     */

				var parser = _dereq_('engine.io-parser');
				var Emitter = _dereq_('component-emitter');

				/**
     * Module exports.
     */

				module.exports = Transport;

				/**
     * Transport abstract constructor.
     *
     * @param {Object} options.
     * @api private
     */

				function Transport(opts) {
					this.path = opts.path;
					this.hostname = opts.hostname;
					this.port = opts.port;
					this.secure = opts.secure;
					this.query = opts.query;
					this.timestampParam = opts.timestampParam;
					this.timestampRequests = opts.timestampRequests;
					this.readyState = '';
					this.agent = opts.agent || false;
					this.socket = opts.socket;
					this.enablesXDR = opts.enablesXDR;

					// SSL options for Node.js client
					this.pfx = opts.pfx;
					this.key = opts.key;
					this.passphrase = opts.passphrase;
					this.cert = opts.cert;
					this.ca = opts.ca;
					this.ciphers = opts.ciphers;
					this.rejectUnauthorized = opts.rejectUnauthorized;

					// other options for Node.js client
					this.extraHeaders = opts.extraHeaders;
				}

				/**
     * Mix in `Emitter`.
     */

				Emitter(Transport.prototype);

				/**
     * Emits an error.
     *
     * @param {String} str
     * @return {Transport} for chaining
     * @api public
     */

				Transport.prototype.onError = function (msg, desc) {
					var err = new Error(msg);
					err.type = 'TransportError';
					err.description = desc;
					this.emit('error', err);
					return this;
				};

				/**
     * Opens the transport.
     *
     * @api public
     */

				Transport.prototype.open = function () {
					if ('closed' == this.readyState || '' == this.readyState) {
						this.readyState = 'opening';
						this.doOpen();
					}

					return this;
				};

				/**
     * Closes the transport.
     *
     * @api private
     */

				Transport.prototype.close = function () {
					if ('opening' == this.readyState || 'open' == this.readyState) {
						this.doClose();
						this.onClose();
					}

					return this;
				};

				/**
     * Sends multiple packets.
     *
     * @param {Array} packets
     * @api private
     */

				Transport.prototype.send = function (packets) {
					if ('open' == this.readyState) {
						this.write(packets);
					} else {
						throw new Error('Transport not open');
					}
				};

				/**
     * Called upon open
     *
     * @api private
     */

				Transport.prototype.onOpen = function () {
					this.readyState = 'open';
					this.writable = true;
					this.emit('open');
				};

				/**
     * Called with data.
     *
     * @param {String} data
     * @api private
     */

				Transport.prototype.onData = function (data) {
					var packet = parser.decodePacket(data, this.socket.binaryType);
					this.onPacket(packet);
				};

				/**
     * Called with a decoded packet.
     */

				Transport.prototype.onPacket = function (packet) {
					this.emit('packet', packet);
				};

				/**
     * Called upon close.
     *
     * @api private
     */

				Transport.prototype.onClose = function () {
					this.readyState = 'closed';
					this.emit('close');
				};
			}, { "component-emitter": 15, "engine.io-parser": 19 }], 5: [function (_dereq_, module, exports) {
				(function (global) {
					/**
      * Module dependencies
      */

					var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
					var XHR = _dereq_('./polling-xhr');
					var JSONP = _dereq_('./polling-jsonp');
					var websocket = _dereq_('./websocket');

					/**
      * Export transports.
      */

					exports.polling = polling;
					exports.websocket = websocket;

					/**
      * Polling transport polymorphic constructor.
      * Decides on xhr vs jsonp based on feature detection.
      *
      * @api private
      */

					function polling(opts) {
						var xhr;
						var xd = false;
						var xs = false;
						var jsonp = false !== opts.jsonp;

						if (global.location) {
							var isSSL = 'https:' == location.protocol;
							var port = location.port;

							// some user agents have empty `location.port`
							if (!port) {
								port = isSSL ? 443 : 80;
							}

							xd = opts.hostname != location.hostname || port != opts.port;
							xs = opts.secure != isSSL;
						}

						opts.xdomain = xd;
						opts.xscheme = xs;
						xhr = new XMLHttpRequest(opts);

						if ('open' in xhr && !opts.forceJSONP) {
							return new XHR(opts);
						} else {
							if (!jsonp) throw new Error('JSONP disabled');
							return new JSONP(opts);
						}
					}
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "./polling-jsonp": 6, "./polling-xhr": 7, "./websocket": 9, "xmlhttprequest-ssl": 10 }], 6: [function (_dereq_, module, exports) {
				(function (global) {

					/**
      * Module requirements.
      */

					var Polling = _dereq_('./polling');
					var inherit = _dereq_('component-inherit');

					/**
      * Module exports.
      */

					module.exports = JSONPPolling;

					/**
      * Cached regular expressions.
      */

					var rNewline = /\n/g;
					var rEscapedNewline = /\\n/g;

					/**
      * Global JSONP callbacks.
      */

					var callbacks;

					/**
      * Callbacks count.
      */

					var index = 0;

					/**
      * Noop.
      */

					function empty() {}

					/**
      * JSONP Polling constructor.
      *
      * @param {Object} opts.
      * @api public
      */

					function JSONPPolling(opts) {
						Polling.call(this, opts);

						this.query = this.query || {};

						// define global callbacks array if not present
						// we do this here (lazily) to avoid unneeded global pollution
						if (!callbacks) {
							// we need to consider multiple engines in the same page
							if (!global.___eio) global.___eio = [];
							callbacks = global.___eio;
						}

						// callback identifier
						this.index = callbacks.length;

						// add callback to jsonp global
						var self = this;
						callbacks.push(function (msg) {
							self.onData(msg);
						});

						// append to query string
						this.query.j = this.index;

						// prevent spurious errors from being emitted when the window is unloaded
						if (global.document && global.addEventListener) {
							global.addEventListener('beforeunload', function () {
								if (self.script) self.script.onerror = empty;
							}, false);
						}
					}

					/**
      * Inherits from Polling.
      */

					inherit(JSONPPolling, Polling);

					/*
      * JSONP only supports binary as base64 encoded strings
      */

					JSONPPolling.prototype.supportsBinary = false;

					/**
      * Closes the socket.
      *
      * @api private
      */

					JSONPPolling.prototype.doClose = function () {
						if (this.script) {
							this.script.parentNode.removeChild(this.script);
							this.script = null;
						}

						if (this.form) {
							this.form.parentNode.removeChild(this.form);
							this.form = null;
							this.iframe = null;
						}

						Polling.prototype.doClose.call(this);
					};

					/**
      * Starts a poll cycle.
      *
      * @api private
      */

					JSONPPolling.prototype.doPoll = function () {
						var self = this;
						var script = document.createElement('script');

						if (this.script) {
							this.script.parentNode.removeChild(this.script);
							this.script = null;
						}

						script.async = true;
						script.src = this.uri();
						script.onerror = function (e) {
							self.onError('jsonp poll error', e);
						};

						var insertAt = document.getElementsByTagName('script')[0];
						if (insertAt) {
							insertAt.parentNode.insertBefore(script, insertAt);
						} else {
							(document.head || document.body).appendChild(script);
						}
						this.script = script;

						var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);

						if (isUAgecko) {
							setTimeout(function () {
								var iframe = document.createElement('iframe');
								document.body.appendChild(iframe);
								document.body.removeChild(iframe);
							}, 100);
						}
					};

					/**
      * Writes with a hidden iframe.
      *
      * @param {String} data to send
      * @param {Function} called upon flush.
      * @api private
      */

					JSONPPolling.prototype.doWrite = function (data, fn) {
						var self = this;

						if (!this.form) {
							var form = document.createElement('form');
							var area = document.createElement('textarea');
							var id = this.iframeId = 'eio_iframe_' + this.index;
							var iframe;

							form.className = 'socketio';
							form.style.position = 'absolute';
							form.style.top = '-1000px';
							form.style.left = '-1000px';
							form.target = id;
							form.method = 'POST';
							form.setAttribute('accept-charset', 'utf-8');
							area.name = 'd';
							form.appendChild(area);
							document.body.appendChild(form);

							this.form = form;
							this.area = area;
						}

						this.form.action = this.uri();

						function complete() {
							initIframe();
							fn();
						}

						function initIframe() {
							if (self.iframe) {
								try {
									self.form.removeChild(self.iframe);
								} catch (e) {
									self.onError('jsonp polling iframe removal error', e);
								}
							}

							try {
								// ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
								var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
								iframe = document.createElement(html);
							} catch (e) {
								iframe = document.createElement('iframe');
								iframe.name = self.iframeId;
								iframe.src = 'javascript:0';
							}

							iframe.id = self.iframeId;

							self.form.appendChild(iframe);
							self.iframe = iframe;
						}

						initIframe();

						// escape \n to prevent it from being converted into \r\n by some UAs
						// double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
						data = data.replace(rEscapedNewline, '\\\n');
						this.area.value = data.replace(rNewline, '\\n');

						try {
							this.form.submit();
						} catch (e) {}

						if (this.iframe.attachEvent) {
							this.iframe.onreadystatechange = function () {
								if (self.iframe.readyState == 'complete') {
									complete();
								}
							};
						} else {
							this.iframe.onload = complete;
						}
					};
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "./polling": 8, "component-inherit": 16 }], 7: [function (_dereq_, module, exports) {
				(function (global) {
					/**
      * Module requirements.
      */

					var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
					var Polling = _dereq_('./polling');
					var Emitter = _dereq_('component-emitter');
					var inherit = _dereq_('component-inherit');
					var debug = _dereq_('debug')('engine.io-client:polling-xhr');

					/**
      * Module exports.
      */

					module.exports = XHR;
					module.exports.Request = Request;

					/**
      * Empty function
      */

					function empty() {}

					/**
      * XHR Polling constructor.
      *
      * @param {Object} opts
      * @api public
      */

					function XHR(opts) {
						Polling.call(this, opts);

						if (global.location) {
							var isSSL = 'https:' == location.protocol;
							var port = location.port;

							// some user agents have empty `location.port`
							if (!port) {
								port = isSSL ? 443 : 80;
							}

							this.xd = opts.hostname != global.location.hostname || port != opts.port;
							this.xs = opts.secure != isSSL;
						} else {
							this.extraHeaders = opts.extraHeaders;
						}
					}

					/**
      * Inherits from Polling.
      */

					inherit(XHR, Polling);

					/**
      * XHR supports binary
      */

					XHR.prototype.supportsBinary = true;

					/**
      * Creates a request.
      *
      * @param {String} method
      * @api private
      */

					XHR.prototype.request = function (opts) {
						opts = opts || {};
						opts.uri = this.uri();
						opts.xd = this.xd;
						opts.xs = this.xs;
						opts.agent = this.agent || false;
						opts.supportsBinary = this.supportsBinary;
						opts.enablesXDR = this.enablesXDR;

						// SSL options for Node.js client
						opts.pfx = this.pfx;
						opts.key = this.key;
						opts.passphrase = this.passphrase;
						opts.cert = this.cert;
						opts.ca = this.ca;
						opts.ciphers = this.ciphers;
						opts.rejectUnauthorized = this.rejectUnauthorized;

						// other options for Node.js client
						opts.extraHeaders = this.extraHeaders;

						return new Request(opts);
					};

					/**
      * Sends data.
      *
      * @param {String} data to send.
      * @param {Function} called upon flush.
      * @api private
      */

					XHR.prototype.doWrite = function (data, fn) {
						var isBinary = typeof data !== 'string' && data !== undefined;
						var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
						var self = this;
						req.on('success', fn);
						req.on('error', function (err) {
							self.onError('xhr post error', err);
						});
						this.sendXhr = req;
					};

					/**
      * Starts a poll cycle.
      *
      * @api private
      */

					XHR.prototype.doPoll = function () {
						debug('xhr poll');
						var req = this.request();
						var self = this;
						req.on('data', function (data) {
							self.onData(data);
						});
						req.on('error', function (err) {
							self.onError('xhr poll error', err);
						});
						this.pollXhr = req;
					};

					/**
      * Request constructor
      *
      * @param {Object} options
      * @api public
      */

					function Request(opts) {
						this.method = opts.method || 'GET';
						this.uri = opts.uri;
						this.xd = !!opts.xd;
						this.xs = !!opts.xs;
						this.async = false !== opts.async;
						this.data = undefined != opts.data ? opts.data : null;
						this.agent = opts.agent;
						this.isBinary = opts.isBinary;
						this.supportsBinary = opts.supportsBinary;
						this.enablesXDR = opts.enablesXDR;

						// SSL options for Node.js client
						this.pfx = opts.pfx;
						this.key = opts.key;
						this.passphrase = opts.passphrase;
						this.cert = opts.cert;
						this.ca = opts.ca;
						this.ciphers = opts.ciphers;
						this.rejectUnauthorized = opts.rejectUnauthorized;

						// other options for Node.js client
						this.extraHeaders = opts.extraHeaders;

						this.create();
					}

					/**
      * Mix in `Emitter`.
      */

					Emitter(Request.prototype);

					/**
      * Creates the XHR object and sends the request.
      *
      * @api private
      */

					Request.prototype.create = function () {
						var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

						// SSL options for Node.js client
						opts.pfx = this.pfx;
						opts.key = this.key;
						opts.passphrase = this.passphrase;
						opts.cert = this.cert;
						opts.ca = this.ca;
						opts.ciphers = this.ciphers;
						opts.rejectUnauthorized = this.rejectUnauthorized;

						var xhr = this.xhr = new XMLHttpRequest(opts);
						var self = this;

						try {
							debug('xhr open %s: %s', this.method, this.uri);
							xhr.open(this.method, this.uri, this.async);
							try {
								if (this.extraHeaders) {
									xhr.setDisableHeaderCheck(true);
									for (var i in this.extraHeaders) {
										if (this.extraHeaders.hasOwnProperty(i)) {
											xhr.setRequestHeader(i, this.extraHeaders[i]);
										}
									}
								}
							} catch (e) {}
							if (this.supportsBinary) {
								// This has to be done after open because Firefox is stupid
								// http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
								xhr.responseType = 'arraybuffer';
							}

							if ('POST' == this.method) {
								try {
									if (this.isBinary) {
										xhr.setRequestHeader('Content-type', 'application/octet-stream');
									} else {
										xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
									}
								} catch (e) {}
							}

							// ie6 check
							if ('withCredentials' in xhr) {
								xhr.withCredentials = true;
							}

							if (this.hasXDR()) {
								xhr.onload = function () {
									self.onLoad();
								};
								xhr.onerror = function () {
									self.onError(xhr.responseText);
								};
							} else {
								xhr.onreadystatechange = function () {
									if (4 != xhr.readyState) return;
									if (200 == xhr.status || 1223 == xhr.status) {
										self.onLoad();
									} else {
										// make sure the `error` event handler that's user-set
										// does not throw in the same tick and gets caught here
										setTimeout(function () {
											self.onError(xhr.status);
										}, 0);
									}
								};
							}

							debug('xhr data %s', this.data);
							xhr.send(this.data);
						} catch (e) {
							// Need to defer since .create() is called directly fhrom the constructor
							// and thus the 'error' event can only be only bound *after* this exception
							// occurs.  Therefore, also, we cannot throw here at all.
							setTimeout(function () {
								self.onError(e);
							}, 0);
							return;
						}

						if (global.document) {
							this.index = Request.requestsCount++;
							Request.requests[this.index] = this;
						}
					};

					/**
      * Called upon successful response.
      *
      * @api private
      */

					Request.prototype.onSuccess = function () {
						this.emit('success');
						this.cleanup();
					};

					/**
      * Called if we have data.
      *
      * @api private
      */

					Request.prototype.onData = function (data) {
						this.emit('data', data);
						this.onSuccess();
					};

					/**
      * Called upon error.
      *
      * @api private
      */

					Request.prototype.onError = function (err) {
						this.emit('error', err);
						this.cleanup(true);
					};

					/**
      * Cleans up house.
      *
      * @api private
      */

					Request.prototype.cleanup = function (fromError) {
						if ('undefined' == typeof this.xhr || null === this.xhr) {
							return;
						}
						// xmlhttprequest
						if (this.hasXDR()) {
							this.xhr.onload = this.xhr.onerror = empty;
						} else {
							this.xhr.onreadystatechange = empty;
						}

						if (fromError) {
							try {
								this.xhr.abort();
							} catch (e) {}
						}

						if (global.document) {
							delete Request.requests[this.index];
						}

						this.xhr = null;
					};

					/**
      * Called upon load.
      *
      * @api private
      */

					Request.prototype.onLoad = function () {
						var data;
						try {
							var contentType;
							try {
								contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
							} catch (e) {}
							if (contentType === 'application/octet-stream') {
								data = this.xhr.response;
							} else {
								if (!this.supportsBinary) {
									data = this.xhr.responseText;
								} else {
									try {
										data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
									} catch (e) {
										var ui8Arr = new Uint8Array(this.xhr.response);
										var dataArray = [];
										for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
											dataArray.push(ui8Arr[idx]);
										}

										data = String.fromCharCode.apply(null, dataArray);
									}
								}
							}
						} catch (e) {
							this.onError(e);
						}
						if (null != data) {
							this.onData(data);
						}
					};

					/**
      * Check if it has XDomainRequest.
      *
      * @api private
      */

					Request.prototype.hasXDR = function () {
						return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
					};

					/**
      * Aborts the request.
      *
      * @api public
      */

					Request.prototype.abort = function () {
						this.cleanup();
					};

					/**
      * Aborts pending requests when unloading the window. This is needed to prevent
      * memory leaks (e.g. when using IE) and to ensure that no spurious error is
      * emitted.
      */

					if (global.document) {
						Request.requestsCount = 0;
						Request.requests = {};
						if (global.attachEvent) {
							global.attachEvent('onunload', unloadHandler);
						} else if (global.addEventListener) {
							global.addEventListener('beforeunload', unloadHandler, false);
						}
					}

					function unloadHandler() {
						for (var i in Request.requests) {
							if (Request.requests.hasOwnProperty(i)) {
								Request.requests[i].abort();
							}
						}
					}
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "./polling": 8, "component-emitter": 15, "component-inherit": 16, "debug": 17, "xmlhttprequest-ssl": 10 }], 8: [function (_dereq_, module, exports) {
				/**
     * Module dependencies.
     */

				var Transport = _dereq_('../transport');
				var parseqs = _dereq_('parseqs');
				var parser = _dereq_('engine.io-parser');
				var inherit = _dereq_('component-inherit');
				var yeast = _dereq_('yeast');
				var debug = _dereq_('debug')('engine.io-client:polling');

				/**
     * Module exports.
     */

				module.exports = Polling;

				/**
     * Is XHR2 supported?
     */

				var hasXHR2 = function () {
					var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
					var xhr = new XMLHttpRequest({ xdomain: false });
					return null != xhr.responseType;
				}();

				/**
     * Polling interface.
     *
     * @param {Object} opts
     * @api private
     */

				function Polling(opts) {
					var forceBase64 = opts && opts.forceBase64;
					if (!hasXHR2 || forceBase64) {
						this.supportsBinary = false;
					}
					Transport.call(this, opts);
				}

				/**
     * Inherits from Transport.
     */

				inherit(Polling, Transport);

				/**
     * Transport name.
     */

				Polling.prototype.name = 'polling';

				/**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @api private
     */

				Polling.prototype.doOpen = function () {
					this.poll();
				};

				/**
     * Pauses polling.
     *
     * @param {Function} callback upon buffers are flushed and transport is paused
     * @api private
     */

				Polling.prototype.pause = function (onPause) {
					var pending = 0;
					var self = this;

					this.readyState = 'pausing';

					function pause() {
						debug('paused');
						self.readyState = 'paused';
						onPause();
					}

					if (this.polling || !this.writable) {
						var total = 0;

						if (this.polling) {
							debug('we are currently polling - waiting to pause');
							total++;
							this.once('pollComplete', function () {
								debug('pre-pause polling complete');
								--total || pause();
							});
						}

						if (!this.writable) {
							debug('we are currently writing - waiting to pause');
							total++;
							this.once('drain', function () {
								debug('pre-pause writing complete');
								--total || pause();
							});
						}
					} else {
						pause();
					}
				};

				/**
     * Starts polling cycle.
     *
     * @api public
     */

				Polling.prototype.poll = function () {
					debug('polling');
					this.polling = true;
					this.doPoll();
					this.emit('poll');
				};

				/**
     * Overloads onData to detect payloads.
     *
     * @api private
     */

				Polling.prototype.onData = function (data) {
					var self = this;
					debug('polling got data %s', data);
					var callback = function callback(packet, index, total) {
						// if its the first message we consider the transport open
						if ('opening' == self.readyState) {
							self.onOpen();
						}

						// if its a close packet, we close the ongoing requests
						if ('close' == packet.type) {
							self.onClose();
							return false;
						}

						// otherwise bypass onData and handle the message
						self.onPacket(packet);
					};

					// decode payload
					parser.decodePayload(data, this.socket.binaryType, callback);

					// if an event did not trigger closing
					if ('closed' != this.readyState) {
						// if we got data we're not polling
						this.polling = false;
						this.emit('pollComplete');

						if ('open' == this.readyState) {
							this.poll();
						} else {
							debug('ignoring poll - transport state "%s"', this.readyState);
						}
					}
				};

				/**
     * For polling, send a close packet.
     *
     * @api private
     */

				Polling.prototype.doClose = function () {
					var self = this;

					function close() {
						debug('writing close packet');
						self.write([{ type: 'close' }]);
					}

					if ('open' == this.readyState) {
						debug('transport open - closing');
						close();
					} else {
						// in case we're trying to close while
						// handshaking is in progress (GH-164)
						debug('transport not open - deferring close');
						this.once('open', close);
					}
				};

				/**
     * Writes a packets payload.
     *
     * @param {Array} data packets
     * @param {Function} drain callback
     * @api private
     */

				Polling.prototype.write = function (packets) {
					var self = this;
					this.writable = false;
					var callbackfn = function callbackfn() {
						self.writable = true;
						self.emit('drain');
					};

					var self = this;
					parser.encodePayload(packets, this.supportsBinary, function (data) {
						self.doWrite(data, callbackfn);
					});
				};

				/**
     * Generates uri for connection.
     *
     * @api private
     */

				Polling.prototype.uri = function () {
					var query = this.query || {};
					var schema = this.secure ? 'https' : 'http';
					var port = '';

					// cache busting is forced
					if (false !== this.timestampRequests) {
						query[this.timestampParam] = yeast();
					}

					if (!this.supportsBinary && !query.sid) {
						query.b64 = 1;
					}

					query = parseqs.encode(query);

					// avoid port if default for schema
					if (this.port && ('https' == schema && this.port != 443 || 'http' == schema && this.port != 80)) {
						port = ':' + this.port;
					}

					// prepend ? to query
					if (query.length) {
						query = '?' + query;
					}

					var ipv6 = this.hostname.indexOf(':') !== -1;
					return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
				};
			}, { "../transport": 4, "component-inherit": 16, "debug": 17, "engine.io-parser": 19, "parseqs": 27, "xmlhttprequest-ssl": 10, "yeast": 30 }], 9: [function (_dereq_, module, exports) {
				(function (global) {
					/**
      * Module dependencies.
      */

					var Transport = _dereq_('../transport');
					var parser = _dereq_('engine.io-parser');
					var parseqs = _dereq_('parseqs');
					var inherit = _dereq_('component-inherit');
					var yeast = _dereq_('yeast');
					var debug = _dereq_('debug')('engine.io-client:websocket');
					var BrowserWebSocket = global.WebSocket || global.MozWebSocket;

					/**
      * Get either the `WebSocket` or `MozWebSocket` globals
      * in the browser or try to resolve WebSocket-compatible
      * interface exposed by `ws` for Node-like environment.
      */

					var WebSocket = BrowserWebSocket;
					if (!WebSocket && typeof window === 'undefined') {
						try {
							WebSocket = _dereq_('ws');
						} catch (e) {}
					}

					/**
      * Module exports.
      */

					module.exports = WS;

					/**
      * WebSocket transport constructor.
      *
      * @api {Object} connection options
      * @api public
      */

					function WS(opts) {
						var forceBase64 = opts && opts.forceBase64;
						if (forceBase64) {
							this.supportsBinary = false;
						}
						this.perMessageDeflate = opts.perMessageDeflate;
						Transport.call(this, opts);
					}

					/**
      * Inherits from Transport.
      */

					inherit(WS, Transport);

					/**
      * Transport name.
      *
      * @api public
      */

					WS.prototype.name = 'websocket';

					/*
      * WebSockets support binary
      */

					WS.prototype.supportsBinary = true;

					/**
      * Opens socket.
      *
      * @api private
      */

					WS.prototype.doOpen = function () {
						if (!this.check()) {
							// let probe timeout
							return;
						}

						var self = this;
						var uri = this.uri();
						var protocols = void 0;
						var opts = {
							agent: this.agent,
							perMessageDeflate: this.perMessageDeflate
						};

						// SSL options for Node.js client
						opts.pfx = this.pfx;
						opts.key = this.key;
						opts.passphrase = this.passphrase;
						opts.cert = this.cert;
						opts.ca = this.ca;
						opts.ciphers = this.ciphers;
						opts.rejectUnauthorized = this.rejectUnauthorized;
						if (this.extraHeaders) {
							opts.headers = this.extraHeaders;
						}

						this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);

						if (this.ws.binaryType === undefined) {
							this.supportsBinary = false;
						}

						if (this.ws.supports && this.ws.supports.binary) {
							this.supportsBinary = true;
							this.ws.binaryType = 'buffer';
						} else {
							this.ws.binaryType = 'arraybuffer';
						}

						this.addEventListeners();
					};

					/**
      * Adds event listeners to the socket
      *
      * @api private
      */

					WS.prototype.addEventListeners = function () {
						var self = this;

						this.ws.onopen = function () {
							self.onOpen();
						};
						this.ws.onclose = function () {
							self.onClose();
						};
						this.ws.onmessage = function (ev) {
							self.onData(ev.data);
						};
						this.ws.onerror = function (e) {
							self.onError('websocket error', e);
						};
					};

					/**
      * Override `onData` to use a timer on iOS.
      * See: https://gist.github.com/mloughran/2052006
      *
      * @api private
      */

					if ('undefined' != typeof navigator && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
						WS.prototype.onData = function (data) {
							var self = this;
							setTimeout(function () {
								Transport.prototype.onData.call(self, data);
							}, 0);
						};
					}

					/**
      * Writes data to socket.
      *
      * @param {Array} array of packets.
      * @api private
      */

					WS.prototype.write = function (packets) {
						var self = this;
						this.writable = false;

						// encodePacket efficient as it uses WS framing
						// no need for encodePayload
						var total = packets.length;
						for (var i = 0, l = total; i < l; i++) {
							(function (packet) {
								parser.encodePacket(packet, self.supportsBinary, function (data) {
									if (!BrowserWebSocket) {
										// always create a new object (GH-437)
										var opts = {};
										if (packet.options) {
											opts.compress = packet.options.compress;
										}

										if (self.perMessageDeflate) {
											var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;
											if (len < self.perMessageDeflate.threshold) {
												opts.compress = false;
											}
										}
									}

									//Sometimes the websocket has already been closed but the browser didn't
									//have a chance of informing us about it yet, in that case send will
									//throw an error
									try {
										if (BrowserWebSocket) {
											// TypeError is thrown when passing the second argument on Safari
											self.ws.send(data);
										} else {
											self.ws.send(data, opts);
										}
									} catch (e) {
										debug('websocket closed before onclose event');
									}

									--total || done();
								});
							})(packets[i]);
						}

						function done() {
							self.emit('flush');

							// fake drain
							// defer to next tick to allow Socket to clear writeBuffer
							setTimeout(function () {
								self.writable = true;
								self.emit('drain');
							}, 0);
						}
					};

					/**
      * Called upon close
      *
      * @api private
      */

					WS.prototype.onClose = function () {
						Transport.prototype.onClose.call(this);
					};

					/**
      * Closes socket.
      *
      * @api private
      */

					WS.prototype.doClose = function () {
						if (typeof this.ws !== 'undefined') {
							this.ws.close();
						}
					};

					/**
      * Generates uri for connection.
      *
      * @api private
      */

					WS.prototype.uri = function () {
						var query = this.query || {};
						var schema = this.secure ? 'wss' : 'ws';
						var port = '';

						// avoid port if default for schema
						if (this.port && ('wss' == schema && this.port != 443 || 'ws' == schema && this.port != 80)) {
							port = ':' + this.port;
						}

						// append timestamp to URI
						if (this.timestampRequests) {
							query[this.timestampParam] = yeast();
						}

						// communicate binary support capabilities
						if (!this.supportsBinary) {
							query.b64 = 1;
						}

						query = parseqs.encode(query);

						// prepend ? to query
						if (query.length) {
							query = '?' + query;
						}

						var ipv6 = this.hostname.indexOf(':') !== -1;
						return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
					};

					/**
      * Feature detection for WebSocket.
      *
      * @return {Boolean} whether this transport is available.
      * @api public
      */

					WS.prototype.check = function () {
						return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
					};
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "../transport": 4, "component-inherit": 16, "debug": 17, "engine.io-parser": 19, "parseqs": 27, "ws": undefined, "yeast": 30 }], 10: [function (_dereq_, module, exports) {
				// browser shim for xmlhttprequest module
				var hasCORS = _dereq_('has-cors');

				module.exports = function (opts) {
					var xdomain = opts.xdomain;

					// scheme must be same when usign XDomainRequest
					// http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
					var xscheme = opts.xscheme;

					// XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
					// https://github.com/Automattic/engine.io-client/pull/217
					var enablesXDR = opts.enablesXDR;

					// XMLHttpRequest can be disabled on IE
					try {
						if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
							return new XMLHttpRequest();
						}
					} catch (e) {}

					// Use XDomainRequest for IE8 if enablesXDR is true
					// because loading bar keeps flashing when using jsonp-polling
					// https://github.com/yujiosaka/socke.io-ie8-loading-example
					try {
						if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
							return new XDomainRequest();
						}
					} catch (e) {}

					if (!xdomain) {
						try {
							return new ActiveXObject('Microsoft.XMLHTTP');
						} catch (e) {}
					}
				};
			}, { "has-cors": 22 }], 11: [function (_dereq_, module, exports) {
				module.exports = after;

				function after(count, callback, err_cb) {
					var bail = false;
					err_cb = err_cb || noop;
					proxy.count = count;

					return count === 0 ? callback() : proxy;

					function proxy(err, result) {
						if (proxy.count <= 0) {
							throw new Error('after called too many times');
						}
						--proxy.count;

						// after first error, rest are passed to err_cb
						if (err) {
							bail = true;
							callback(err);
							// future error callbacks will go to error handler
							callback = err_cb;
						} else if (proxy.count === 0 && !bail) {
							callback(null, result);
						}
					}
				}

				function noop() {}
			}, {}], 12: [function (_dereq_, module, exports) {
				/**
     * An abstraction for slicing an arraybuffer even when
     * ArrayBuffer.prototype.slice is not supported
     *
     * @api public
     */

				module.exports = function (arraybuffer, start, end) {
					var bytes = arraybuffer.byteLength;
					start = start || 0;
					end = end || bytes;

					if (arraybuffer.slice) {
						return arraybuffer.slice(start, end);
					}

					if (start < 0) {
						start += bytes;
					}
					if (end < 0) {
						end += bytes;
					}
					if (end > bytes) {
						end = bytes;
					}

					if (start >= bytes || start >= end || bytes === 0) {
						return new ArrayBuffer(0);
					}

					var abv = new Uint8Array(arraybuffer);
					var result = new Uint8Array(end - start);
					for (var i = start, ii = 0; i < end; i++, ii++) {
						result[ii] = abv[i];
					}
					return result.buffer;
				};
			}, {}], 13: [function (_dereq_, module, exports) {
				/*
     * base64-arraybuffer
     * https://github.com/niklasvh/base64-arraybuffer
     *
     * Copyright (c) 2012 Niklas von Hertzen
     * Licensed under the MIT license.
     */
				(function (chars) {
					"use strict";

					exports.encode = function (arraybuffer) {
						var bytes = new Uint8Array(arraybuffer),
						    i,
						    len = bytes.length,
						    base64 = "";

						for (i = 0; i < len; i += 3) {
							base64 += chars[bytes[i] >> 2];
							base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
							base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
							base64 += chars[bytes[i + 2] & 63];
						}

						if (len % 3 === 2) {
							base64 = base64.substring(0, base64.length - 1) + "=";
						} else if (len % 3 === 1) {
							base64 = base64.substring(0, base64.length - 2) + "==";
						}

						return base64;
					};

					exports.decode = function (base64) {
						var bufferLength = base64.length * 0.75,
						    len = base64.length,
						    i,
						    p = 0,
						    encoded1,
						    encoded2,
						    encoded3,
						    encoded4;

						if (base64[base64.length - 1] === "=") {
							bufferLength--;
							if (base64[base64.length - 2] === "=") {
								bufferLength--;
							}
						}

						var arraybuffer = new ArrayBuffer(bufferLength),
						    bytes = new Uint8Array(arraybuffer);

						for (i = 0; i < len; i += 4) {
							encoded1 = chars.indexOf(base64[i]);
							encoded2 = chars.indexOf(base64[i + 1]);
							encoded3 = chars.indexOf(base64[i + 2]);
							encoded4 = chars.indexOf(base64[i + 3]);

							bytes[p++] = encoded1 << 2 | encoded2 >> 4;
							bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
							bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
						}

						return arraybuffer;
					};
				})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
			}, {}], 14: [function (_dereq_, module, exports) {
				(function (global) {
					/**
      * Create a blob builder even when vendor prefixes exist
      */

					var BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder || global.MSBlobBuilder || global.MozBlobBuilder;

					/**
      * Check if Blob constructor is supported
      */

					var blobSupported = function () {
						try {
							var a = new Blob(['hi']);
							return a.size === 2;
						} catch (e) {
							return false;
						}
					}();

					/**
      * Check if Blob constructor supports ArrayBufferViews
      * Fails in Safari 6, so we need to map to ArrayBuffers there.
      */

					var blobSupportsArrayBufferView = blobSupported && function () {
						try {
							var b = new Blob([new Uint8Array([1, 2])]);
							return b.size === 2;
						} catch (e) {
							return false;
						}
					}();

					/**
      * Check if BlobBuilder is supported
      */

					var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;

					/**
      * Helper function that maps ArrayBufferViews to ArrayBuffers
      * Used by BlobBuilder constructor and old browsers that didn't
      * support it in the Blob constructor.
      */

					function mapArrayBufferViews(ary) {
						for (var i = 0; i < ary.length; i++) {
							var chunk = ary[i];
							if (chunk.buffer instanceof ArrayBuffer) {
								var buf = chunk.buffer;

								// if this is a subarray, make a copy so we only
								// include the subarray region from the underlying buffer
								if (chunk.byteLength !== buf.byteLength) {
									var copy = new Uint8Array(chunk.byteLength);
									copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
									buf = copy.buffer;
								}

								ary[i] = buf;
							}
						}
					}

					function BlobBuilderConstructor(ary, options) {
						options = options || {};

						var bb = new BlobBuilder();
						mapArrayBufferViews(ary);

						for (var i = 0; i < ary.length; i++) {
							bb.append(ary[i]);
						}

						return options.type ? bb.getBlob(options.type) : bb.getBlob();
					};

					function BlobConstructor(ary, options) {
						mapArrayBufferViews(ary);
						return new Blob(ary, options || {});
					};

					module.exports = function () {
						if (blobSupported) {
							return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
						} else if (blobBuilderSupported) {
							return BlobBuilderConstructor;
						} else {
							return undefined;
						}
					}();
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, {}], 15: [function (_dereq_, module, exports) {

				/**
     * Expose `Emitter`.
     */

				module.exports = Emitter;

				/**
     * Initialize a new `Emitter`.
     *
     * @api public
     */

				function Emitter(obj) {
					if (obj) return mixin(obj);
				};

				/**
     * Mixin the emitter properties.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */

				function mixin(obj) {
					for (var key in Emitter.prototype) {
						obj[key] = Emitter.prototype[key];
					}
					return obj;
				}

				/**
     * Listen on the given `event` with `fn`.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

				Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
					this._callbacks = this._callbacks || {};
					(this._callbacks[event] = this._callbacks[event] || []).push(fn);
					return this;
				};

				/**
     * Adds an `event` listener that will be invoked a single
     * time then automatically removed.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

				Emitter.prototype.once = function (event, fn) {
					var self = this;
					this._callbacks = this._callbacks || {};

					function on() {
						self.off(event, on);
						fn.apply(this, arguments);
					}

					on.fn = fn;
					this.on(event, on);
					return this;
				};

				/**
     * Remove the given callback for `event` or all
     * registered callbacks.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

				Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
					this._callbacks = this._callbacks || {};

					// all
					if (0 == arguments.length) {
						this._callbacks = {};
						return this;
					}

					// specific event
					var callbacks = this._callbacks[event];
					if (!callbacks) return this;

					// remove all handlers
					if (1 == arguments.length) {
						delete this._callbacks[event];
						return this;
					}

					// remove specific handler
					var cb;
					for (var i = 0; i < callbacks.length; i++) {
						cb = callbacks[i];
						if (cb === fn || cb.fn === fn) {
							callbacks.splice(i, 1);
							break;
						}
					}
					return this;
				};

				/**
     * Emit `event` with the given args.
     *
     * @param {String} event
     * @param {Mixed} ...
     * @return {Emitter}
     */

				Emitter.prototype.emit = function (event) {
					this._callbacks = this._callbacks || {};
					var args = [].slice.call(arguments, 1),
					    callbacks = this._callbacks[event];

					if (callbacks) {
						callbacks = callbacks.slice(0);
						for (var i = 0, len = callbacks.length; i < len; ++i) {
							callbacks[i].apply(this, args);
						}
					}

					return this;
				};

				/**
     * Return array of callbacks for `event`.
     *
     * @param {String} event
     * @return {Array}
     * @api public
     */

				Emitter.prototype.listeners = function (event) {
					this._callbacks = this._callbacks || {};
					return this._callbacks[event] || [];
				};

				/**
     * Check if this emitter has `event` handlers.
     *
     * @param {String} event
     * @return {Boolean}
     * @api public
     */

				Emitter.prototype.hasListeners = function (event) {
					return !!this.listeners(event).length;
				};
			}, {}], 16: [function (_dereq_, module, exports) {

				module.exports = function (a, b) {
					var fn = function fn() {};
					fn.prototype = b.prototype;
					a.prototype = new fn();
					a.prototype.constructor = a;
				};
			}, {}], 17: [function (_dereq_, module, exports) {

				/**
     * This is the web browser implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */

				exports = module.exports = _dereq_('./debug');
				exports.log = log;
				exports.formatArgs = formatArgs;
				exports.save = save;
				exports.load = load;
				exports.useColors = useColors;
				exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

				/**
     * Colors.
     */

				exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

				/**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

				function useColors() {
					// is webkit? http://stackoverflow.com/a/16459606/376773
					return 'WebkitAppearance' in document.documentElement.style ||
					// is firebug? http://stackoverflow.com/a/398120/376773
					window.console && (console.firebug || console.exception && console.table) ||
					// is firefox >= v31?
					// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
					navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
				}

				/**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

				exports.formatters.j = function (v) {
					return JSON.stringify(v);
				};

				/**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

				function formatArgs() {
					var args = arguments;
					var useColors = this.useColors;

					args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

					if (!useColors) return args;

					var c = 'color: ' + this.color;
					args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

					// the final "%c" is somewhat tricky, because there could be other
					// arguments passed either before or after the %c, so we need to
					// figure out the correct index to insert the CSS into
					var index = 0;
					var lastC = 0;
					args[0].replace(/%[a-z%]/g, function (match) {
						if ('%%' === match) return;
						index++;
						if ('%c' === match) {
							// we only are interested in the *last* %c
							// (the user may have provided their own)
							lastC = index;
						}
					});

					args.splice(lastC, 0, c);
					return args;
				}

				/**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */

				function log() {
					// this hackery is required for IE8/9, where
					// the `console.log` function doesn't have 'apply'
					return 'object' === (typeof console === "undefined" ? "undefined" : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
				}

				/**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

				function save(namespaces) {
					try {
						if (null == namespaces) {
							exports.storage.removeItem('debug');
						} else {
							exports.storage.debug = namespaces;
						}
					} catch (e) {}
				}

				/**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

				function load() {
					var r;
					try {
						r = exports.storage.debug;
					} catch (e) {}
					return r;
				}

				/**
     * Enable namespaces listed in `localStorage.debug` initially.
     */

				exports.enable(load());

				/**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

				function localstorage() {
					try {
						return window.localStorage;
					} catch (e) {}
				}
			}, { "./debug": 18 }], 18: [function (_dereq_, module, exports) {

				/**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     *
     * Expose `debug()` as the module.
     */

				exports = module.exports = debug;
				exports.coerce = coerce;
				exports.disable = disable;
				exports.enable = enable;
				exports.enabled = enabled;
				exports.humanize = _dereq_('ms');

				/**
     * The currently active debug mode names, and names to skip.
     */

				exports.names = [];
				exports.skips = [];

				/**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lowercased letter, i.e. "n".
     */

				exports.formatters = {};

				/**
     * Previously assigned color.
     */

				var prevColor = 0;

				/**
     * Previous log timestamp.
     */

				var prevTime;

				/**
     * Select a color.
     *
     * @return {Number}
     * @api private
     */

				function selectColor() {
					return exports.colors[prevColor++ % exports.colors.length];
				}

				/**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */

				function debug(namespace) {

					// define the `disabled` version
					function disabled() {}
					disabled.enabled = false;

					// define the `enabled` version
					function enabled() {

						var self = enabled;

						// set `diff` timestamp
						var curr = +new Date();
						var ms = curr - (prevTime || curr);
						self.diff = ms;
						self.prev = prevTime;
						self.curr = curr;
						prevTime = curr;

						// add the `color` if not set
						if (null == self.useColors) self.useColors = exports.useColors();
						if (null == self.color && self.useColors) self.color = selectColor();

						var args = Array.prototype.slice.call(arguments);

						args[0] = exports.coerce(args[0]);

						if ('string' !== typeof args[0]) {
							// anything else let's inspect with %o
							args = ['%o'].concat(args);
						}

						// apply any `formatters` transformations
						var index = 0;
						args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
							// if we encounter an escaped % then don't increase the array index
							if (match === '%%') return match;
							index++;
							var formatter = exports.formatters[format];
							if ('function' === typeof formatter) {
								var val = args[index];
								match = formatter.call(self, val);

								// now we need to remove `args[index]` since it's inlined in the `format`
								args.splice(index, 1);
								index--;
							}
							return match;
						});

						if ('function' === typeof exports.formatArgs) {
							args = exports.formatArgs.apply(self, args);
						}
						var logFn = enabled.log || exports.log || console.log.bind(console);
						logFn.apply(self, args);
					}
					enabled.enabled = true;

					var fn = exports.enabled(namespace) ? enabled : disabled;

					fn.namespace = namespace;

					return fn;
				}

				/**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */

				function enable(namespaces) {
					exports.save(namespaces);

					var split = (namespaces || '').split(/[\s,]+/);
					var len = split.length;

					for (var i = 0; i < len; i++) {
						if (!split[i]) continue; // ignore empty strings
						namespaces = split[i].replace(/\*/g, '.*?');
						if (namespaces[0] === '-') {
							exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
						} else {
							exports.names.push(new RegExp('^' + namespaces + '$'));
						}
					}
				}

				/**
     * Disable debug output.
     *
     * @api public
     */

				function disable() {
					exports.enable('');
				}

				/**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */

				function enabled(name) {
					var i, len;
					for (i = 0, len = exports.skips.length; i < len; i++) {
						if (exports.skips[i].test(name)) {
							return false;
						}
					}
					for (i = 0, len = exports.names.length; i < len; i++) {
						if (exports.names[i].test(name)) {
							return true;
						}
					}
					return false;
				}

				/**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */

				function coerce(val) {
					if (val instanceof Error) return val.stack || val.message;
					return val;
				}
			}, { "ms": 25 }], 19: [function (_dereq_, module, exports) {
				(function (global) {
					/**
      * Module dependencies.
      */

					var keys = _dereq_('./keys');
					var hasBinary = _dereq_('has-binary');
					var sliceBuffer = _dereq_('arraybuffer.slice');
					var base64encoder = _dereq_('base64-arraybuffer');
					var after = _dereq_('after');
					var utf8 = _dereq_('utf8');

					/**
      * Check if we are running an android browser. That requires us to use
      * ArrayBuffer with polling transports...
      *
      * http://ghinda.net/jpeg-blob-ajax-android/
      */

					var isAndroid = navigator.userAgent.match(/Android/i);

					/**
      * Check if we are running in PhantomJS.
      * Uploading a Blob with PhantomJS does not work correctly, as reported here:
      * https://github.com/ariya/phantomjs/issues/11395
      * @type boolean
      */
					var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

					/**
      * When true, avoids using Blobs to encode payloads.
      * @type boolean
      */
					var dontSendBlobs = isAndroid || isPhantomJS;

					/**
      * Current protocol version.
      */

					exports.protocol = 3;

					/**
      * Packet types.
      */

					var packets = exports.packets = {
						open: 0 // non-ws
						, close: 1 // non-ws
						, ping: 2,
						pong: 3,
						message: 4,
						upgrade: 5,
						noop: 6
					};

					var packetslist = keys(packets);

					/**
      * Premade error packet.
      */

					var err = { type: 'error', data: 'parser error' };

					/**
      * Create a blob api even for blob builder when vendor prefixes exist
      */

					var Blob = _dereq_('blob');

					/**
      * Encodes a packet.
      *
      *     <packet type id> [ <data> ]
      *
      * Example:
      *
      *     5hello world
      *     3
      *     4
      *
      * Binary is encoded in an identical principle
      *
      * @api private
      */

					exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
						if ('function' == typeof supportsBinary) {
							callback = supportsBinary;
							supportsBinary = false;
						}

						if ('function' == typeof utf8encode) {
							callback = utf8encode;
							utf8encode = null;
						}

						var data = packet.data === undefined ? undefined : packet.data.buffer || packet.data;

						if (global.ArrayBuffer && data instanceof ArrayBuffer) {
							return encodeArrayBuffer(packet, supportsBinary, callback);
						} else if (Blob && data instanceof global.Blob) {
							return encodeBlob(packet, supportsBinary, callback);
						}

						// might be an object with { base64: true, data: dataAsBase64String }
						if (data && data.base64) {
							return encodeBase64Object(packet, callback);
						}

						// Sending data as a utf-8 string
						var encoded = packets[packet.type];

						// data fragment is optional
						if (undefined !== packet.data) {
							encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
						}

						return callback('' + encoded);
					};

					function encodeBase64Object(packet, callback) {
						// packet data is an object { base64: true, data: dataAsBase64String }
						var message = 'b' + exports.packets[packet.type] + packet.data.data;
						return callback(message);
					}

					/**
      * Encode packet helpers for binary types
      */

					function encodeArrayBuffer(packet, supportsBinary, callback) {
						if (!supportsBinary) {
							return exports.encodeBase64Packet(packet, callback);
						}

						var data = packet.data;
						var contentArray = new Uint8Array(data);
						var resultBuffer = new Uint8Array(1 + data.byteLength);

						resultBuffer[0] = packets[packet.type];
						for (var i = 0; i < contentArray.length; i++) {
							resultBuffer[i + 1] = contentArray[i];
						}

						return callback(resultBuffer.buffer);
					}

					function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
						if (!supportsBinary) {
							return exports.encodeBase64Packet(packet, callback);
						}

						var fr = new FileReader();
						fr.onload = function () {
							packet.data = fr.result;
							exports.encodePacket(packet, supportsBinary, true, callback);
						};
						return fr.readAsArrayBuffer(packet.data);
					}

					function encodeBlob(packet, supportsBinary, callback) {
						if (!supportsBinary) {
							return exports.encodeBase64Packet(packet, callback);
						}

						if (dontSendBlobs) {
							return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
						}

						var length = new Uint8Array(1);
						length[0] = packets[packet.type];
						var blob = new Blob([length.buffer, packet.data]);

						return callback(blob);
					}

					/**
      * Encodes a packet with binary data in a base64 string
      *
      * @param {Object} packet, has `type` and `data`
      * @return {String} base64 encoded message
      */

					exports.encodeBase64Packet = function (packet, callback) {
						var message = 'b' + exports.packets[packet.type];
						if (Blob && packet.data instanceof global.Blob) {
							var fr = new FileReader();
							fr.onload = function () {
								var b64 = fr.result.split(',')[1];
								callback(message + b64);
							};
							return fr.readAsDataURL(packet.data);
						}

						var b64data;
						try {
							b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
						} catch (e) {
							// iPhone Safari doesn't let you apply with typed arrays
							var typed = new Uint8Array(packet.data);
							var basic = new Array(typed.length);
							for (var i = 0; i < typed.length; i++) {
								basic[i] = typed[i];
							}
							b64data = String.fromCharCode.apply(null, basic);
						}
						message += global.btoa(b64data);
						return callback(message);
					};

					/**
      * Decodes a packet. Changes format to Blob if requested.
      *
      * @return {Object} with `type` and `data` (if any)
      * @api private
      */

					exports.decodePacket = function (data, binaryType, utf8decode) {
						// String data
						if (typeof data == 'string' || data === undefined) {
							if (data.charAt(0) == 'b') {
								return exports.decodeBase64Packet(data.substr(1), binaryType);
							}

							if (utf8decode) {
								try {
									data = utf8.decode(data);
								} catch (e) {
									return err;
								}
							}
							var type = data.charAt(0);

							if (Number(type) != type || !packetslist[type]) {
								return err;
							}

							if (data.length > 1) {
								return { type: packetslist[type], data: data.substring(1) };
							} else {
								return { type: packetslist[type] };
							}
						}

						var asArray = new Uint8Array(data);
						var type = asArray[0];
						var rest = sliceBuffer(data, 1);
						if (Blob && binaryType === 'blob') {
							rest = new Blob([rest]);
						}
						return { type: packetslist[type], data: rest };
					};

					/**
      * Decodes a packet encoded in a base64 string
      *
      * @param {String} base64 encoded message
      * @return {Object} with `type` and `data` (if any)
      */

					exports.decodeBase64Packet = function (msg, binaryType) {
						var type = packetslist[msg.charAt(0)];
						if (!global.ArrayBuffer) {
							return { type: type, data: { base64: true, data: msg.substr(1) } };
						}

						var data = base64encoder.decode(msg.substr(1));

						if (binaryType === 'blob' && Blob) {
							data = new Blob([data]);
						}

						return { type: type, data: data };
					};

					/**
      * Encodes multiple messages (payload).
      *
      *     <length>:data
      *
      * Example:
      *
      *     11:hello world2:hi
      *
      * If any contents are binary, they will be encoded as base64 strings. Base64
      * encoded strings are marked with a b before the length specifier
      *
      * @param {Array} packets
      * @api private
      */

					exports.encodePayload = function (packets, supportsBinary, callback) {
						if (typeof supportsBinary == 'function') {
							callback = supportsBinary;
							supportsBinary = null;
						}

						var isBinary = hasBinary(packets);

						if (supportsBinary && isBinary) {
							if (Blob && !dontSendBlobs) {
								return exports.encodePayloadAsBlob(packets, callback);
							}

							return exports.encodePayloadAsArrayBuffer(packets, callback);
						}

						if (!packets.length) {
							return callback('0:');
						}

						function setLengthHeader(message) {
							return message.length + ':' + message;
						}

						function encodeOne(packet, doneCallback) {
							exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function (message) {
								doneCallback(null, setLengthHeader(message));
							});
						}

						map(packets, encodeOne, function (err, results) {
							return callback(results.join(''));
						});
					};

					/**
      * Async array map using after
      */

					function map(ary, each, done) {
						var result = new Array(ary.length);
						var next = after(ary.length, done);

						var eachWithIndex = function eachWithIndex(i, el, cb) {
							each(el, function (error, msg) {
								result[i] = msg;
								cb(error, result);
							});
						};

						for (var i = 0; i < ary.length; i++) {
							eachWithIndex(i, ary[i], next);
						}
					}

					/*
      * Decodes data when a payload is maybe expected. Possible binary contents are
      * decoded from their base64 representation
      *
      * @param {String} data, callback method
      * @api public
      */

					exports.decodePayload = function (data, binaryType, callback) {
						if (typeof data != 'string') {
							return exports.decodePayloadAsBinary(data, binaryType, callback);
						}

						if (typeof binaryType === 'function') {
							callback = binaryType;
							binaryType = null;
						}

						var packet;
						if (data == '') {
							// parser error - ignoring payload
							return callback(err, 0, 1);
						}

						var length = '',
						    n,
						    msg;

						for (var i = 0, l = data.length; i < l; i++) {
							var chr = data.charAt(i);

							if (':' != chr) {
								length += chr;
							} else {
								if ('' == length || length != (n = Number(length))) {
									// parser error - ignoring payload
									return callback(err, 0, 1);
								}

								msg = data.substr(i + 1, n);

								if (length != msg.length) {
									// parser error - ignoring payload
									return callback(err, 0, 1);
								}

								if (msg.length) {
									packet = exports.decodePacket(msg, binaryType, true);

									if (err.type == packet.type && err.data == packet.data) {
										// parser error in individual packet - ignoring payload
										return callback(err, 0, 1);
									}

									var ret = callback(packet, i + n, l);
									if (false === ret) return;
								}

								// advance cursor
								i += n;
								length = '';
							}
						}

						if (length != '') {
							// parser error - ignoring payload
							return callback(err, 0, 1);
						}
					};

					/**
      * Encodes multiple messages (payload) as binary.
      *
      * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
      * 255><data>
      *
      * Example:
      * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
      *
      * @param {Array} packets
      * @return {ArrayBuffer} encoded payload
      * @api private
      */

					exports.encodePayloadAsArrayBuffer = function (packets, callback) {
						if (!packets.length) {
							return callback(new ArrayBuffer(0));
						}

						function encodeOne(packet, doneCallback) {
							exports.encodePacket(packet, true, true, function (data) {
								return doneCallback(null, data);
							});
						}

						map(packets, encodeOne, function (err, encodedPackets) {
							var totalLength = encodedPackets.reduce(function (acc, p) {
								var len;
								if (typeof p === 'string') {
									len = p.length;
								} else {
									len = p.byteLength;
								}
								return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
							}, 0);

							var resultArray = new Uint8Array(totalLength);

							var bufferIndex = 0;
							encodedPackets.forEach(function (p) {
								var isString = typeof p === 'string';
								var ab = p;
								if (isString) {
									var view = new Uint8Array(p.length);
									for (var i = 0; i < p.length; i++) {
										view[i] = p.charCodeAt(i);
									}
									ab = view.buffer;
								}

								if (isString) {
									// not true binary
									resultArray[bufferIndex++] = 0;
								} else {
									// true binary
									resultArray[bufferIndex++] = 1;
								}

								var lenStr = ab.byteLength.toString();
								for (var i = 0; i < lenStr.length; i++) {
									resultArray[bufferIndex++] = parseInt(lenStr[i]);
								}
								resultArray[bufferIndex++] = 255;

								var view = new Uint8Array(ab);
								for (var i = 0; i < view.length; i++) {
									resultArray[bufferIndex++] = view[i];
								}
							});

							return callback(resultArray.buffer);
						});
					};

					/**
      * Encode as Blob
      */

					exports.encodePayloadAsBlob = function (packets, callback) {
						function encodeOne(packet, doneCallback) {
							exports.encodePacket(packet, true, true, function (encoded) {
								var binaryIdentifier = new Uint8Array(1);
								binaryIdentifier[0] = 1;
								if (typeof encoded === 'string') {
									var view = new Uint8Array(encoded.length);
									for (var i = 0; i < encoded.length; i++) {
										view[i] = encoded.charCodeAt(i);
									}
									encoded = view.buffer;
									binaryIdentifier[0] = 0;
								}

								var len = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size;

								var lenStr = len.toString();
								var lengthAry = new Uint8Array(lenStr.length + 1);
								for (var i = 0; i < lenStr.length; i++) {
									lengthAry[i] = parseInt(lenStr[i]);
								}
								lengthAry[lenStr.length] = 255;

								if (Blob) {
									var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
									doneCallback(null, blob);
								}
							});
						}

						map(packets, encodeOne, function (err, results) {
							return callback(new Blob(results));
						});
					};

					/*
      * Decodes data when a payload is maybe expected. Strings are decoded by
      * interpreting each byte as a key code for entries marked to start with 0. See
      * description of encodePayloadAsBinary
      *
      * @param {ArrayBuffer} data, callback method
      * @api public
      */

					exports.decodePayloadAsBinary = function (data, binaryType, callback) {
						if (typeof binaryType === 'function') {
							callback = binaryType;
							binaryType = null;
						}

						var bufferTail = data;
						var buffers = [];

						var numberTooLong = false;
						while (bufferTail.byteLength > 0) {
							var tailArray = new Uint8Array(bufferTail);
							var isString = tailArray[0] === 0;
							var msgLength = '';

							for (var i = 1;; i++) {
								if (tailArray[i] == 255) break;

								if (msgLength.length > 310) {
									numberTooLong = true;
									break;
								}

								msgLength += tailArray[i];
							}

							if (numberTooLong) return callback(err, 0, 1);

							bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
							msgLength = parseInt(msgLength);

							var msg = sliceBuffer(bufferTail, 0, msgLength);
							if (isString) {
								try {
									msg = String.fromCharCode.apply(null, new Uint8Array(msg));
								} catch (e) {
									// iPhone Safari doesn't let you apply to typed arrays
									var typed = new Uint8Array(msg);
									msg = '';
									for (var i = 0; i < typed.length; i++) {
										msg += String.fromCharCode(typed[i]);
									}
								}
							}

							buffers.push(msg);
							bufferTail = sliceBuffer(bufferTail, msgLength);
						}

						var total = buffers.length;
						buffers.forEach(function (buffer, i) {
							callback(exports.decodePacket(buffer, binaryType, true), i, total);
						});
					};
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "./keys": 20, "after": 11, "arraybuffer.slice": 12, "base64-arraybuffer": 13, "blob": 14, "has-binary": 21, "utf8": 29 }], 20: [function (_dereq_, module, exports) {

				/**
     * Gets the keys for an object.
     *
     * @return {Array} keys
     * @api private
     */

				module.exports = Object.keys || function keys(obj) {
					var arr = [];
					var has = Object.prototype.hasOwnProperty;

					for (var i in obj) {
						if (has.call(obj, i)) {
							arr.push(i);
						}
					}
					return arr;
				};
			}, {}], 21: [function (_dereq_, module, exports) {
				(function (global) {

					/*
      * Module requirements.
      */

					var isArray = _dereq_('isarray');

					/**
      * Module exports.
      */

					module.exports = hasBinary;

					/**
      * Checks for binary data.
      *
      * Right now only Buffer and ArrayBuffer are supported..
      *
      * @param {Object} anything
      * @api public
      */

					function hasBinary(data) {

						function _hasBinary(obj) {
							if (!obj) return false;

							if (global.Buffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer || global.Blob && obj instanceof Blob || global.File && obj instanceof File) {
								return true;
							}

							if (isArray(obj)) {
								for (var i = 0; i < obj.length; i++) {
									if (_hasBinary(obj[i])) {
										return true;
									}
								}
							} else if (obj && 'object' == (typeof obj === "undefined" ? "undefined" : _typeof(obj))) {
								if (obj.toJSON) {
									obj = obj.toJSON();
								}

								for (var key in obj) {
									if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
										return true;
									}
								}
							}

							return false;
						}

						return _hasBinary(data);
					}
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "isarray": 24 }], 22: [function (_dereq_, module, exports) {

				/**
     * Module exports.
     *
     * Logic borrowed from Modernizr:
     *
     *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
     */

				try {
					module.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
				} catch (err) {
					// if XMLHttp support is disabled in IE then it will throw
					// when trying to create
					module.exports = false;
				}
			}, {}], 23: [function (_dereq_, module, exports) {

				var indexOf = [].indexOf;

				module.exports = function (arr, obj) {
					if (indexOf) return arr.indexOf(obj);
					for (var i = 0; i < arr.length; ++i) {
						if (arr[i] === obj) return i;
					}
					return -1;
				};
			}, {}], 24: [function (_dereq_, module, exports) {
				module.exports = Array.isArray || function (arr) {
					return Object.prototype.toString.call(arr) == '[object Array]';
				};
			}, {}], 25: [function (_dereq_, module, exports) {
				/**
     * Helpers.
     */

				var s = 1000;
				var m = s * 60;
				var h = m * 60;
				var d = h * 24;
				var y = d * 365.25;

				/**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} options
     * @return {String|Number}
     * @api public
     */

				module.exports = function (val, options) {
					options = options || {};
					if ('string' == typeof val) return parse(val);
					return options.long ? long(val) : short(val);
				};

				/**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */

				function parse(str) {
					str = '' + str;
					if (str.length > 10000) return;
					var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
					if (!match) return;
					var n = parseFloat(match[1]);
					var type = (match[2] || 'ms').toLowerCase();
					switch (type) {
						case 'years':
						case 'year':
						case 'yrs':
						case 'yr':
						case 'y':
							return n * y;
						case 'days':
						case 'day':
						case 'd':
							return n * d;
						case 'hours':
						case 'hour':
						case 'hrs':
						case 'hr':
						case 'h':
							return n * h;
						case 'minutes':
						case 'minute':
						case 'mins':
						case 'min':
						case 'm':
							return n * m;
						case 'seconds':
						case 'second':
						case 'secs':
						case 'sec':
						case 's':
							return n * s;
						case 'milliseconds':
						case 'millisecond':
						case 'msecs':
						case 'msec':
						case 'ms':
							return n;
					}
				}

				/**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

				function short(ms) {
					if (ms >= d) return Math.round(ms / d) + 'd';
					if (ms >= h) return Math.round(ms / h) + 'h';
					if (ms >= m) return Math.round(ms / m) + 'm';
					if (ms >= s) return Math.round(ms / s) + 's';
					return ms + 'ms';
				}

				/**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

				function long(ms) {
					return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
				}

				/**
     * Pluralization helper.
     */

				function plural(ms, n, name) {
					if (ms < n) return;
					if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
					return Math.ceil(ms / n) + ' ' + name + 's';
				}
			}, {}], 26: [function (_dereq_, module, exports) {
				(function (global) {
					/**
      * JSON parse.
      *
      * @see Based on jQuery#parseJSON (MIT) and JSON2
      * @api private
      */

					var rvalidchars = /^[\],:{}\s]*$/;
					var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
					var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
					var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
					var rtrimLeft = /^\s+/;
					var rtrimRight = /\s+$/;

					module.exports = function parsejson(data) {
						if ('string' != typeof data || !data) {
							return null;
						}

						data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

						// Attempt to parse using the native JSON parser first
						if (global.JSON && JSON.parse) {
							return JSON.parse(data);
						}

						if (rvalidchars.test(data.replace(rvalidescape, '@').replace(rvalidtokens, ']').replace(rvalidbraces, ''))) {
							return new Function('return ' + data)();
						}
					};
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, {}], 27: [function (_dereq_, module, exports) {
				/**
     * Compiles a querystring
     * Returns string representation of the object
     *
     * @param {Object}
     * @api private
     */

				exports.encode = function (obj) {
					var str = '';

					for (var i in obj) {
						if (obj.hasOwnProperty(i)) {
							if (str.length) str += '&';
							str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
						}
					}

					return str;
				};

				/**
     * Parses a simple querystring into an object
     *
     * @param {String} qs
     * @api private
     */

				exports.decode = function (qs) {
					var qry = {};
					var pairs = qs.split('&');
					for (var i = 0, l = pairs.length; i < l; i++) {
						var pair = pairs[i].split('=');
						qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
					}
					return qry;
				};
			}, {}], 28: [function (_dereq_, module, exports) {
				/**
     * Parses an URI
     *
     * @author Steven Levithan <stevenlevithan.com> (MIT license)
     * @api private
     */

				var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

				var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];

				module.exports = function parseuri(str) {
					var src = str,
					    b = str.indexOf('['),
					    e = str.indexOf(']');

					if (b != -1 && e != -1) {
						str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
					}

					var m = re.exec(str || ''),
					    uri = {},
					    i = 14;

					while (i--) {
						uri[parts[i]] = m[i] || '';
					}

					if (b != -1 && e != -1) {
						uri.source = src;
						uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
						uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
						uri.ipv6uri = true;
					}

					return uri;
				};
			}, {}], 29: [function (_dereq_, module, exports) {
				(function (global) {
					/*! https://mths.be/utf8js v2.0.0 by @mathias */
					;(function (root) {

						// Detect free variables `exports`
						var freeExports = (typeof exports === "undefined" ? "undefined" : _typeof(exports)) == 'object' && exports;

						// Detect free variable `module`
						var freeModule = (typeof module === "undefined" ? "undefined" : _typeof(module)) == 'object' && module && module.exports == freeExports && module;

						// Detect free variable `global`, from Node.js or Browserified code,
						// and use it as `root`
						var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global;
						if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
							root = freeGlobal;
						}

						/*--------------------------------------------------------------------------*/

						var stringFromCharCode = String.fromCharCode;

						// Taken from https://mths.be/punycode
						function ucs2decode(string) {
							var output = [];
							var counter = 0;
							var length = string.length;
							var value;
							var extra;
							while (counter < length) {
								value = string.charCodeAt(counter++);
								if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
									// high surrogate, and there is a next character
									extra = string.charCodeAt(counter++);
									if ((extra & 0xFC00) == 0xDC00) {
										// low surrogate
										output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
									} else {
										// unmatched surrogate; only append this code unit, in case the next
										// code unit is the high surrogate of a surrogate pair
										output.push(value);
										counter--;
									}
								} else {
									output.push(value);
								}
							}
							return output;
						}

						// Taken from https://mths.be/punycode
						function ucs2encode(array) {
							var length = array.length;
							var index = -1;
							var value;
							var output = '';
							while (++index < length) {
								value = array[index];
								if (value > 0xFFFF) {
									value -= 0x10000;
									output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
									value = 0xDC00 | value & 0x3FF;
								}
								output += stringFromCharCode(value);
							}
							return output;
						}

						function checkScalarValue(codePoint) {
							if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
								throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
							}
						}
						/*--------------------------------------------------------------------------*/

						function createByte(codePoint, shift) {
							return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);
						}

						function encodeCodePoint(codePoint) {
							if ((codePoint & 0xFFFFFF80) == 0) {
								// 1-byte sequence
								return stringFromCharCode(codePoint);
							}
							var symbol = '';
							if ((codePoint & 0xFFFFF800) == 0) {
								// 2-byte sequence
								symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);
							} else if ((codePoint & 0xFFFF0000) == 0) {
								// 3-byte sequence
								checkScalarValue(codePoint);
								symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);
								symbol += createByte(codePoint, 6);
							} else if ((codePoint & 0xFFE00000) == 0) {
								// 4-byte sequence
								symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);
								symbol += createByte(codePoint, 12);
								symbol += createByte(codePoint, 6);
							}
							symbol += stringFromCharCode(codePoint & 0x3F | 0x80);
							return symbol;
						}

						function utf8encode(string) {
							var codePoints = ucs2decode(string);
							var length = codePoints.length;
							var index = -1;
							var codePoint;
							var byteString = '';
							while (++index < length) {
								codePoint = codePoints[index];
								byteString += encodeCodePoint(codePoint);
							}
							return byteString;
						}

						/*--------------------------------------------------------------------------*/

						function readContinuationByte() {
							if (byteIndex >= byteCount) {
								throw Error('Invalid byte index');
							}

							var continuationByte = byteArray[byteIndex] & 0xFF;
							byteIndex++;

							if ((continuationByte & 0xC0) == 0x80) {
								return continuationByte & 0x3F;
							}

							// If we end up here, it’s not a continuation byte
							throw Error('Invalid continuation byte');
						}

						function decodeSymbol() {
							var byte1;
							var byte2;
							var byte3;
							var byte4;
							var codePoint;

							if (byteIndex > byteCount) {
								throw Error('Invalid byte index');
							}

							if (byteIndex == byteCount) {
								return false;
							}

							// Read first byte
							byte1 = byteArray[byteIndex] & 0xFF;
							byteIndex++;

							// 1-byte sequence (no continuation bytes)
							if ((byte1 & 0x80) == 0) {
								return byte1;
							}

							// 2-byte sequence
							if ((byte1 & 0xE0) == 0xC0) {
								var byte2 = readContinuationByte();
								codePoint = (byte1 & 0x1F) << 6 | byte2;
								if (codePoint >= 0x80) {
									return codePoint;
								} else {
									throw Error('Invalid continuation byte');
								}
							}

							// 3-byte sequence (may include unpaired surrogates)
							if ((byte1 & 0xF0) == 0xE0) {
								byte2 = readContinuationByte();
								byte3 = readContinuationByte();
								codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;
								if (codePoint >= 0x0800) {
									checkScalarValue(codePoint);
									return codePoint;
								} else {
									throw Error('Invalid continuation byte');
								}
							}

							// 4-byte sequence
							if ((byte1 & 0xF8) == 0xF0) {
								byte2 = readContinuationByte();
								byte3 = readContinuationByte();
								byte4 = readContinuationByte();
								codePoint = (byte1 & 0x0F) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;
								if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
									return codePoint;
								}
							}

							throw Error('Invalid UTF-8 detected');
						}

						var byteArray;
						var byteCount;
						var byteIndex;
						function utf8decode(byteString) {
							byteArray = ucs2decode(byteString);
							byteCount = byteArray.length;
							byteIndex = 0;
							var codePoints = [];
							var tmp;
							while ((tmp = decodeSymbol()) !== false) {
								codePoints.push(tmp);
							}
							return ucs2encode(codePoints);
						}

						/*--------------------------------------------------------------------------*/

						var utf8 = {
							'version': '2.0.0',
							'encode': utf8encode,
							'decode': utf8decode
						};

						// Some AMD build optimizers, like r.js, check for specific condition patterns
						// like the following:
						if (typeof define == 'function' && _typeof(define.amd) == 'object' && define.amd) {
							define(function () {
								return utf8;
							});
						} else if (freeExports && !freeExports.nodeType) {
							if (freeModule) {
								// in Node.js or RingoJS v0.8.0+
								freeModule.exports = utf8;
							} else {
								// in Narwhal or RingoJS v0.7.0-
								var object = {};
								var hasOwnProperty = object.hasOwnProperty;
								for (var key in utf8) {
									hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
								}
							}
						} else {
							// in Rhino or a web browser
							root.utf8 = utf8;
						}
					})(this);
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, {}], 30: [function (_dereq_, module, exports) {
				'use strict';

				var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
				    length = 64,
				    map = {},
				    seed = 0,
				    i = 0,
				    prev;

				/**
     * Return a string representing the specified number.
     *
     * @param {Number} num The number to convert.
     * @returns {String} The string representation of the number.
     * @api public
     */
				function encode(num) {
					var encoded = '';

					do {
						encoded = alphabet[num % length] + encoded;
						num = Math.floor(num / length);
					} while (num > 0);

					return encoded;
				}

				/**
     * Return the integer value specified by the given string.
     *
     * @param {String} str The string to convert.
     * @returns {Number} The integer value represented by the string.
     * @api public
     */
				function decode(str) {
					var decoded = 0;

					for (i = 0; i < str.length; i++) {
						decoded = decoded * length + map[str.charAt(i)];
					}

					return decoded;
				}

				/**
     * Yeast: A tiny growing id generator.
     *
     * @returns {String} A unique id.
     * @api public
     */
				function yeast() {
					var now = encode(+new Date());

					if (now !== prev) return seed = 0, prev = now;
					return now + '.' + encode(seed++);
				}

				//
				// Map each character to its index.
				//
				for (; i < length; i++) {
					map[alphabet[i]] = i;
				} //
				// Expose the `yeast`, `encode` and `decode` functions.
				//
				yeast.encode = encode;
				yeast.decode = decode;
				module.exports = yeast;
			}, {}], 31: [function (_dereq_, module, exports) {

				/**
     * Module dependencies.
     */

				var url = _dereq_('./url');
				var parser = _dereq_('socket.io-parser');
				var Manager = _dereq_('./manager');
				var debug = _dereq_('debug')('socket.io-client');

				/**
     * Module exports.
     */

				module.exports = exports = lookup;

				/**
     * Managers cache.
     */

				var cache = exports.managers = {};

				/**
     * Looks up an existing `Manager` for multiplexing.
     * If the user summons:
     *
     *   `io('http://localhost/a');`
     *   `io('http://localhost/b');`
     *
     * We reuse the existing instance based on same scheme/port/host,
     * and we initialize sockets for each namespace.
     *
     * @api public
     */

				function lookup(uri, opts) {
					if ((typeof uri === "undefined" ? "undefined" : _typeof(uri)) == 'object') {
						opts = uri;
						uri = undefined;
					}

					opts = opts || {};

					var parsed = url(uri);
					var source = parsed.source;
					var id = parsed.id;
					var path = parsed.path;
					var sameNamespace = cache[id] && path in cache[id].nsps;
					var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;

					var io;

					if (newConnection) {
						debug('ignoring socket cache for %s', source);
						io = Manager(source, opts);
					} else {
						if (!cache[id]) {
							debug('new io instance for %s', source);
							cache[id] = Manager(source, opts);
						}
						io = cache[id];
					}

					return io.socket(parsed.path);
				}

				/**
     * Protocol version.
     *
     * @api public
     */

				exports.protocol = parser.protocol;

				/**
     * `connect`.
     *
     * @param {String} uri
     * @api public
     */

				exports.connect = lookup;

				/**
     * Expose constructors for standalone build.
     *
     * @api public
     */

				exports.Manager = _dereq_('./manager');
				exports.Socket = _dereq_('./socket');
			}, { "./manager": 32, "./socket": 34, "./url": 35, "debug": 39, "socket.io-parser": 47 }], 32: [function (_dereq_, module, exports) {

				/**
     * Module dependencies.
     */

				var eio = _dereq_('engine.io-client');
				var Socket = _dereq_('./socket');
				var Emitter = _dereq_('component-emitter');
				var parser = _dereq_('socket.io-parser');
				var on = _dereq_('./on');
				var bind = _dereq_('component-bind');
				var debug = _dereq_('debug')('socket.io-client:manager');
				var indexOf = _dereq_('indexof');
				var Backoff = _dereq_('backo2');

				/**
     * IE6+ hasOwnProperty
     */

				var has = Object.prototype.hasOwnProperty;

				/**
     * Module exports
     */

				module.exports = Manager;

				/**
     * `Manager` constructor.
     *
     * @param {String} engine instance or engine uri/opts
     * @param {Object} options
     * @api public
     */

				function Manager(uri, opts) {
					if (!(this instanceof Manager)) return new Manager(uri, opts);
					if (uri && 'object' == (typeof uri === "undefined" ? "undefined" : _typeof(uri))) {
						opts = uri;
						uri = undefined;
					}
					opts = opts || {};

					opts.path = opts.path || '/socket.io';
					this.nsps = {};
					this.subs = [];
					this.opts = opts;
					this.reconnection(opts.reconnection !== false);
					this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
					this.reconnectionDelay(opts.reconnectionDelay || 1000);
					this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
					this.randomizationFactor(opts.randomizationFactor || 0.5);
					this.backoff = new Backoff({
						min: this.reconnectionDelay(),
						max: this.reconnectionDelayMax(),
						jitter: this.randomizationFactor()
					});
					this.timeout(null == opts.timeout ? 20000 : opts.timeout);
					this.readyState = 'closed';
					this.uri = uri;
					this.connecting = [];
					this.lastPing = null;
					this.encoding = false;
					this.packetBuffer = [];
					this.encoder = new parser.Encoder();
					this.decoder = new parser.Decoder();
					this.autoConnect = opts.autoConnect !== false;
					if (this.autoConnect) this.open();
				}

				/**
     * Propagate given event to sockets and emit on `this`
     *
     * @api private
     */

				Manager.prototype.emitAll = function () {
					this.emit.apply(this, arguments);
					for (var nsp in this.nsps) {
						if (has.call(this.nsps, nsp)) {
							this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
						}
					}
				};

				/**
     * Update `socket.id` of all sockets
     *
     * @api private
     */

				Manager.prototype.updateSocketIds = function () {
					for (var nsp in this.nsps) {
						if (has.call(this.nsps, nsp)) {
							this.nsps[nsp].id = this.engine.id;
						}
					}
				};

				/**
     * Mix in `Emitter`.
     */

				Emitter(Manager.prototype);

				/**
     * Sets the `reconnection` config.
     *
     * @param {Boolean} true/false if it should automatically reconnect
     * @return {Manager} self or value
     * @api public
     */

				Manager.prototype.reconnection = function (v) {
					if (!arguments.length) return this._reconnection;
					this._reconnection = !!v;
					return this;
				};

				/**
     * Sets the reconnection attempts config.
     *
     * @param {Number} max reconnection attempts before giving up
     * @return {Manager} self or value
     * @api public
     */

				Manager.prototype.reconnectionAttempts = function (v) {
					if (!arguments.length) return this._reconnectionAttempts;
					this._reconnectionAttempts = v;
					return this;
				};

				/**
     * Sets the delay between reconnections.
     *
     * @param {Number} delay
     * @return {Manager} self or value
     * @api public
     */

				Manager.prototype.reconnectionDelay = function (v) {
					if (!arguments.length) return this._reconnectionDelay;
					this._reconnectionDelay = v;
					this.backoff && this.backoff.setMin(v);
					return this;
				};

				Manager.prototype.randomizationFactor = function (v) {
					if (!arguments.length) return this._randomizationFactor;
					this._randomizationFactor = v;
					this.backoff && this.backoff.setJitter(v);
					return this;
				};

				/**
     * Sets the maximum delay between reconnections.
     *
     * @param {Number} delay
     * @return {Manager} self or value
     * @api public
     */

				Manager.prototype.reconnectionDelayMax = function (v) {
					if (!arguments.length) return this._reconnectionDelayMax;
					this._reconnectionDelayMax = v;
					this.backoff && this.backoff.setMax(v);
					return this;
				};

				/**
     * Sets the connection timeout. `false` to disable
     *
     * @return {Manager} self or value
     * @api public
     */

				Manager.prototype.timeout = function (v) {
					if (!arguments.length) return this._timeout;
					this._timeout = v;
					return this;
				};

				/**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @api private
     */

				Manager.prototype.maybeReconnectOnOpen = function () {
					// Only try to reconnect if it's the first time we're connecting
					if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
						// keeps reconnection from firing twice for the same reconnection loop
						this.reconnect();
					}
				};

				/**
     * Sets the current transport `socket`.
     *
     * @param {Function} optional, callback
     * @return {Manager} self
     * @api public
     */

				Manager.prototype.open = Manager.prototype.connect = function (fn) {
					debug('readyState %s', this.readyState);
					if (~this.readyState.indexOf('open')) return this;

					debug('opening %s', this.uri);
					this.engine = eio(this.uri, this.opts);
					var socket = this.engine;
					var self = this;
					this.readyState = 'opening';
					this.skipReconnect = false;

					// emit `open`
					var openSub = on(socket, 'open', function () {
						self.onopen();
						fn && fn();
					});

					// emit `connect_error`
					var errorSub = on(socket, 'error', function (data) {
						debug('connect_error');
						self.cleanup();
						self.readyState = 'closed';
						self.emitAll('connect_error', data);
						if (fn) {
							var err = new Error('Connection error');
							err.data = data;
							fn(err);
						} else {
							// Only do this if there is no fn to handle the error
							self.maybeReconnectOnOpen();
						}
					});

					// emit `connect_timeout`
					if (false !== this._timeout) {
						var timeout = this._timeout;
						debug('connect attempt will timeout after %d', timeout);

						// set timer
						var timer = setTimeout(function () {
							debug('connect attempt timed out after %d', timeout);
							openSub.destroy();
							socket.close();
							socket.emit('error', 'timeout');
							self.emitAll('connect_timeout', timeout);
						}, timeout);

						this.subs.push({
							destroy: function destroy() {
								clearTimeout(timer);
							}
						});
					}

					this.subs.push(openSub);
					this.subs.push(errorSub);

					return this;
				};

				/**
     * Called upon transport open.
     *
     * @api private
     */

				Manager.prototype.onopen = function () {
					debug('open');

					// clear old subs
					this.cleanup();

					// mark as open
					this.readyState = 'open';
					this.emit('open');

					// add new subs
					var socket = this.engine;
					this.subs.push(on(socket, 'data', bind(this, 'ondata')));
					this.subs.push(on(socket, 'ping', bind(this, 'onping')));
					this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
					this.subs.push(on(socket, 'error', bind(this, 'onerror')));
					this.subs.push(on(socket, 'close', bind(this, 'onclose')));
					this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
				};

				/**
     * Called upon a ping.
     *
     * @api private
     */

				Manager.prototype.onping = function () {
					this.lastPing = new Date();
					this.emitAll('ping');
				};

				/**
     * Called upon a packet.
     *
     * @api private
     */

				Manager.prototype.onpong = function () {
					this.emitAll('pong', new Date() - this.lastPing);
				};

				/**
     * Called with data.
     *
     * @api private
     */

				Manager.prototype.ondata = function (data) {
					this.decoder.add(data);
				};

				/**
     * Called when parser fully decodes a packet.
     *
     * @api private
     */

				Manager.prototype.ondecoded = function (packet) {
					this.emit('packet', packet);
				};

				/**
     * Called upon socket error.
     *
     * @api private
     */

				Manager.prototype.onerror = function (err) {
					debug('error', err);
					this.emitAll('error', err);
				};

				/**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @api public
     */

				Manager.prototype.socket = function (nsp) {
					var socket = this.nsps[nsp];
					if (!socket) {
						socket = new Socket(this, nsp);
						this.nsps[nsp] = socket;
						var self = this;
						socket.on('connecting', onConnecting);
						socket.on('connect', function () {
							socket.id = self.engine.id;
						});

						if (this.autoConnect) {
							// manually call here since connecting evnet is fired before listening
							onConnecting();
						}
					}

					function onConnecting() {
						if (!~indexOf(self.connecting, socket)) {
							self.connecting.push(socket);
						}
					}

					return socket;
				};

				/**
     * Called upon a socket close.
     *
     * @param {Socket} socket
     */

				Manager.prototype.destroy = function (socket) {
					var index = indexOf(this.connecting, socket);
					if (~index) this.connecting.splice(index, 1);
					if (this.connecting.length) return;

					this.close();
				};

				/**
     * Writes a packet.
     *
     * @param {Object} packet
     * @api private
     */

				Manager.prototype.packet = function (packet) {
					debug('writing packet %j', packet);
					var self = this;

					if (!self.encoding) {
						// encode, then write to engine with result
						self.encoding = true;
						this.encoder.encode(packet, function (encodedPackets) {
							for (var i = 0; i < encodedPackets.length; i++) {
								self.engine.write(encodedPackets[i], packet.options);
							}
							self.encoding = false;
							self.processPacketQueue();
						});
					} else {
						// add packet to the queue
						self.packetBuffer.push(packet);
					}
				};

				/**
     * If packet buffer is non-empty, begins encoding the
     * next packet in line.
     *
     * @api private
     */

				Manager.prototype.processPacketQueue = function () {
					if (this.packetBuffer.length > 0 && !this.encoding) {
						var pack = this.packetBuffer.shift();
						this.packet(pack);
					}
				};

				/**
     * Clean up transport subscriptions and packet buffer.
     *
     * @api private
     */

				Manager.prototype.cleanup = function () {
					debug('cleanup');

					var sub;
					while (sub = this.subs.shift()) {
						sub.destroy();
					}this.packetBuffer = [];
					this.encoding = false;
					this.lastPing = null;

					this.decoder.destroy();
				};

				/**
     * Close the current socket.
     *
     * @api private
     */

				Manager.prototype.close = Manager.prototype.disconnect = function () {
					debug('disconnect');
					this.skipReconnect = true;
					this.reconnecting = false;
					if ('opening' == this.readyState) {
						// `onclose` will not fire because
						// an open event never happened
						this.cleanup();
					}
					this.backoff.reset();
					this.readyState = 'closed';
					if (this.engine) this.engine.close();
				};

				/**
     * Called upon engine close.
     *
     * @api private
     */

				Manager.prototype.onclose = function (reason) {
					debug('onclose');

					this.cleanup();
					this.backoff.reset();
					this.readyState = 'closed';
					this.emit('close', reason);

					if (this._reconnection && !this.skipReconnect) {
						this.reconnect();
					}
				};

				/**
     * Attempt a reconnection.
     *
     * @api private
     */

				Manager.prototype.reconnect = function () {
					if (this.reconnecting || this.skipReconnect) return this;

					var self = this;

					if (this.backoff.attempts >= this._reconnectionAttempts) {
						debug('reconnect failed');
						this.backoff.reset();
						this.emitAll('reconnect_failed');
						this.reconnecting = false;
					} else {
						var delay = this.backoff.duration();
						debug('will wait %dms before reconnect attempt', delay);

						this.reconnecting = true;
						var timer = setTimeout(function () {
							if (self.skipReconnect) return;

							debug('attempting reconnect');
							self.emitAll('reconnect_attempt', self.backoff.attempts);
							self.emitAll('reconnecting', self.backoff.attempts);

							// check again for the case socket closed in above events
							if (self.skipReconnect) return;

							self.open(function (err) {
								if (err) {
									debug('reconnect attempt error');
									self.reconnecting = false;
									self.reconnect();
									self.emitAll('reconnect_error', err.data);
								} else {
									debug('reconnect success');
									self.onreconnect();
								}
							});
						}, delay);

						this.subs.push({
							destroy: function destroy() {
								clearTimeout(timer);
							}
						});
					}
				};

				/**
     * Called upon successful reconnect.
     *
     * @api private
     */

				Manager.prototype.onreconnect = function () {
					var attempt = this.backoff.attempts;
					this.reconnecting = false;
					this.backoff.reset();
					this.updateSocketIds();
					this.emitAll('reconnect', attempt);
				};
			}, { "./on": 33, "./socket": 34, "backo2": 36, "component-bind": 37, "component-emitter": 38, "debug": 39, "engine.io-client": 1, "indexof": 42, "socket.io-parser": 47 }], 33: [function (_dereq_, module, exports) {

				/**
     * Module exports.
     */

				module.exports = on;

				/**
     * Helper for subscriptions.
     *
     * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
     * @param {String} event name
     * @param {Function} callback
     * @api public
     */

				function on(obj, ev, fn) {
					obj.on(ev, fn);
					return {
						destroy: function destroy() {
							obj.removeListener(ev, fn);
						}
					};
				}
			}, {}], 34: [function (_dereq_, module, exports) {

				/**
     * Module dependencies.
     */

				var parser = _dereq_('socket.io-parser');
				var Emitter = _dereq_('component-emitter');
				var toArray = _dereq_('to-array');
				var on = _dereq_('./on');
				var bind = _dereq_('component-bind');
				var debug = _dereq_('debug')('socket.io-client:socket');
				var hasBin = _dereq_('has-binary');

				/**
     * Module exports.
     */

				module.exports = exports = Socket;

				/**
     * Internal events (blacklisted).
     * These events can't be emitted by the user.
     *
     * @api private
     */

				var events = {
					connect: 1,
					connect_error: 1,
					connect_timeout: 1,
					connecting: 1,
					disconnect: 1,
					error: 1,
					reconnect: 1,
					reconnect_attempt: 1,
					reconnect_failed: 1,
					reconnect_error: 1,
					reconnecting: 1,
					ping: 1,
					pong: 1
				};

				/**
     * Shortcut to `Emitter#emit`.
     */

				var emit = Emitter.prototype.emit;

				/**
     * `Socket` constructor.
     *
     * @api public
     */

				function Socket(io, nsp) {
					this.io = io;
					this.nsp = nsp;
					this.json = this; // compat
					this.ids = 0;
					this.acks = {};
					this.receiveBuffer = [];
					this.sendBuffer = [];
					this.connected = false;
					this.disconnected = true;
					if (this.io.autoConnect) this.open();
				}

				/**
     * Mix in `Emitter`.
     */

				Emitter(Socket.prototype);

				/**
     * Subscribe to open, close and packet events
     *
     * @api private
     */

				Socket.prototype.subEvents = function () {
					if (this.subs) return;

					var io = this.io;
					this.subs = [on(io, 'open', bind(this, 'onopen')), on(io, 'packet', bind(this, 'onpacket')), on(io, 'close', bind(this, 'onclose'))];
				};

				/**
     * "Opens" the socket.
     *
     * @api public
     */

				Socket.prototype.open = Socket.prototype.connect = function () {
					if (this.connected) return this;

					this.subEvents();
					this.io.open(); // ensure open
					if ('open' == this.io.readyState) this.onopen();
					this.emit('connecting');
					return this;
				};

				/**
     * Sends a `message` event.
     *
     * @return {Socket} self
     * @api public
     */

				Socket.prototype.send = function () {
					var args = toArray(arguments);
					args.unshift('message');
					this.emit.apply(this, args);
					return this;
				};

				/**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @param {String} event name
     * @return {Socket} self
     * @api public
     */

				Socket.prototype.emit = function (ev) {
					if (events.hasOwnProperty(ev)) {
						emit.apply(this, arguments);
						return this;
					}

					var args = toArray(arguments);
					var parserType = parser.EVENT; // default
					if (hasBin(args)) {
						parserType = parser.BINARY_EVENT;
					} // binary
					var packet = { type: parserType, data: args };

					packet.options = {};
					packet.options.compress = !this.flags || false !== this.flags.compress;

					// event ack callback
					if ('function' == typeof args[args.length - 1]) {
						debug('emitting packet with ack id %d', this.ids);
						this.acks[this.ids] = args.pop();
						packet.id = this.ids++;
					}

					if (this.connected) {
						this.packet(packet);
					} else {
						this.sendBuffer.push(packet);
					}

					delete this.flags;

					return this;
				};

				/**
     * Sends a packet.
     *
     * @param {Object} packet
     * @api private
     */

				Socket.prototype.packet = function (packet) {
					packet.nsp = this.nsp;
					this.io.packet(packet);
				};

				/**
     * Called upon engine `open`.
     *
     * @api private
     */

				Socket.prototype.onopen = function () {
					debug('transport is open - connecting');

					// write connect packet if necessary
					if ('/' != this.nsp) {
						this.packet({ type: parser.CONNECT });
					}
				};

				/**
     * Called upon engine `close`.
     *
     * @param {String} reason
     * @api private
     */

				Socket.prototype.onclose = function (reason) {
					debug('close (%s)', reason);
					this.connected = false;
					this.disconnected = true;
					delete this.id;
					this.emit('disconnect', reason);
				};

				/**
     * Called with socket packet.
     *
     * @param {Object} packet
     * @api private
     */

				Socket.prototype.onpacket = function (packet) {
					if (packet.nsp != this.nsp) return;

					switch (packet.type) {
						case parser.CONNECT:
							this.onconnect();
							break;

						case parser.EVENT:
							this.onevent(packet);
							break;

						case parser.BINARY_EVENT:
							this.onevent(packet);
							break;

						case parser.ACK:
							this.onack(packet);
							break;

						case parser.BINARY_ACK:
							this.onack(packet);
							break;

						case parser.DISCONNECT:
							this.ondisconnect();
							break;

						case parser.ERROR:
							this.emit('error', packet.data);
							break;
					}
				};

				/**
     * Called upon a server event.
     *
     * @param {Object} packet
     * @api private
     */

				Socket.prototype.onevent = function (packet) {
					var args = packet.data || [];
					debug('emitting event %j', args);

					if (null != packet.id) {
						debug('attaching ack callback to event');
						args.push(this.ack(packet.id));
					}

					if (this.connected) {
						emit.apply(this, args);
					} else {
						this.receiveBuffer.push(args);
					}
				};

				/**
     * Produces an ack callback to emit with an event.
     *
     * @api private
     */

				Socket.prototype.ack = function (id) {
					var self = this;
					var sent = false;
					return function () {
						// prevent double callbacks
						if (sent) return;
						sent = true;
						var args = toArray(arguments);
						debug('sending ack %j', args);

						var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
						self.packet({
							type: type,
							id: id,
							data: args
						});
					};
				};

				/**
     * Called upon a server acknowlegement.
     *
     * @param {Object} packet
     * @api private
     */

				Socket.prototype.onack = function (packet) {
					var ack = this.acks[packet.id];
					if ('function' == typeof ack) {
						debug('calling ack %s with %j', packet.id, packet.data);
						ack.apply(this, packet.data);
						delete this.acks[packet.id];
					} else {
						debug('bad ack %s', packet.id);
					}
				};

				/**
     * Called upon server connect.
     *
     * @api private
     */

				Socket.prototype.onconnect = function () {
					this.connected = true;
					this.disconnected = false;
					this.emit('connect');
					this.emitBuffered();
				};

				/**
     * Emit buffered events (received and emitted).
     *
     * @api private
     */

				Socket.prototype.emitBuffered = function () {
					var i;
					for (i = 0; i < this.receiveBuffer.length; i++) {
						emit.apply(this, this.receiveBuffer[i]);
					}
					this.receiveBuffer = [];

					for (i = 0; i < this.sendBuffer.length; i++) {
						this.packet(this.sendBuffer[i]);
					}
					this.sendBuffer = [];
				};

				/**
     * Called upon server disconnect.
     *
     * @api private
     */

				Socket.prototype.ondisconnect = function () {
					debug('server disconnect (%s)', this.nsp);
					this.destroy();
					this.onclose('io server disconnect');
				};

				/**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @api private.
     */

				Socket.prototype.destroy = function () {
					if (this.subs) {
						// clean subscriptions to avoid reconnections
						for (var i = 0; i < this.subs.length; i++) {
							this.subs[i].destroy();
						}
						this.subs = null;
					}

					this.io.destroy(this);
				};

				/**
     * Disconnects the socket manually.
     *
     * @return {Socket} self
     * @api public
     */

				Socket.prototype.close = Socket.prototype.disconnect = function () {
					if (this.connected) {
						debug('performing disconnect (%s)', this.nsp);
						this.packet({ type: parser.DISCONNECT });
					}

					// remove socket from pool
					this.destroy();

					if (this.connected) {
						// fire events
						this.onclose('io client disconnect');
					}
					return this;
				};

				/**
     * Sets the compress flag.
     *
     * @param {Boolean} if `true`, compresses the sending data
     * @return {Socket} self
     * @api public
     */

				Socket.prototype.compress = function (compress) {
					this.flags = this.flags || {};
					this.flags.compress = compress;
					return this;
				};
			}, { "./on": 33, "component-bind": 37, "component-emitter": 38, "debug": 39, "has-binary": 41, "socket.io-parser": 47, "to-array": 51 }], 35: [function (_dereq_, module, exports) {
				(function (global) {

					/**
      * Module dependencies.
      */

					var parseuri = _dereq_('parseuri');
					var debug = _dereq_('debug')('socket.io-client:url');

					/**
      * Module exports.
      */

					module.exports = url;

					/**
      * URL parser.
      *
      * @param {String} url
      * @param {Object} An object meant to mimic window.location.
      *                 Defaults to window.location.
      * @api public
      */

					function url(uri, loc) {
						var obj = uri;

						// default to window.location
						var loc = loc || global.location;
						if (null == uri) uri = loc.protocol + '//' + loc.host;

						// relative path support
						if ('string' == typeof uri) {
							if ('/' == uri.charAt(0)) {
								if ('/' == uri.charAt(1)) {
									uri = loc.protocol + uri;
								} else {
									uri = loc.host + uri;
								}
							}

							if (!/^(https?|wss?):\/\//.test(uri)) {
								debug('protocol-less url %s', uri);
								if ('undefined' != typeof loc) {
									uri = loc.protocol + '//' + uri;
								} else {
									uri = 'https://' + uri;
								}
							}

							// parse
							debug('parse %s', uri);
							obj = parseuri(uri);
						}

						// make sure we treat `localhost:80` and `localhost` equally
						if (!obj.port) {
							if (/^(http|ws)$/.test(obj.protocol)) {
								obj.port = '80';
							} else if (/^(http|ws)s$/.test(obj.protocol)) {
								obj.port = '443';
							}
						}

						obj.path = obj.path || '/';

						var ipv6 = obj.host.indexOf(':') !== -1;
						var host = ipv6 ? '[' + obj.host + ']' : obj.host;

						// define unique id
						obj.id = obj.protocol + '://' + host + ':' + obj.port;
						// define href
						obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : ':' + obj.port);

						return obj;
					}
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "debug": 39, "parseuri": 45 }], 36: [function (_dereq_, module, exports) {

				/**
     * Expose `Backoff`.
     */

				module.exports = Backoff;

				/**
     * Initialize backoff timer with `opts`.
     *
     * - `min` initial timeout in milliseconds [100]
     * - `max` max timeout [10000]
     * - `jitter` [0]
     * - `factor` [2]
     *
     * @param {Object} opts
     * @api public
     */

				function Backoff(opts) {
					opts = opts || {};
					this.ms = opts.min || 100;
					this.max = opts.max || 10000;
					this.factor = opts.factor || 2;
					this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
					this.attempts = 0;
				}

				/**
     * Return the backoff duration.
     *
     * @return {Number}
     * @api public
     */

				Backoff.prototype.duration = function () {
					var ms = this.ms * Math.pow(this.factor, this.attempts++);
					if (this.jitter) {
						var rand = Math.random();
						var deviation = Math.floor(rand * this.jitter * ms);
						ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
					}
					return Math.min(ms, this.max) | 0;
				};

				/**
     * Reset the number of attempts.
     *
     * @api public
     */

				Backoff.prototype.reset = function () {
					this.attempts = 0;
				};

				/**
     * Set the minimum duration
     *
     * @api public
     */

				Backoff.prototype.setMin = function (min) {
					this.ms = min;
				};

				/**
     * Set the maximum duration
     *
     * @api public
     */

				Backoff.prototype.setMax = function (max) {
					this.max = max;
				};

				/**
     * Set the jitter
     *
     * @api public
     */

				Backoff.prototype.setJitter = function (jitter) {
					this.jitter = jitter;
				};
			}, {}], 37: [function (_dereq_, module, exports) {
				/**
     * Slice reference.
     */

				var slice = [].slice;

				/**
     * Bind `obj` to `fn`.
     *
     * @param {Object} obj
     * @param {Function|String} fn or string
     * @return {Function}
     * @api public
     */

				module.exports = function (obj, fn) {
					if ('string' == typeof fn) fn = obj[fn];
					if ('function' != typeof fn) throw new Error('bind() requires a function');
					var args = slice.call(arguments, 2);
					return function () {
						return fn.apply(obj, args.concat(slice.call(arguments)));
					};
				};
			}, {}], 38: [function (_dereq_, module, exports) {

				/**
     * Expose `Emitter`.
     */

				module.exports = Emitter;

				/**
     * Initialize a new `Emitter`.
     *
     * @api public
     */

				function Emitter(obj) {
					if (obj) return mixin(obj);
				};

				/**
     * Mixin the emitter properties.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */

				function mixin(obj) {
					for (var key in Emitter.prototype) {
						obj[key] = Emitter.prototype[key];
					}
					return obj;
				}

				/**
     * Listen on the given `event` with `fn`.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

				Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
					this._callbacks = this._callbacks || {};
					(this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
					return this;
				};

				/**
     * Adds an `event` listener that will be invoked a single
     * time then automatically removed.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

				Emitter.prototype.once = function (event, fn) {
					function on() {
						this.off(event, on);
						fn.apply(this, arguments);
					}

					on.fn = fn;
					this.on(event, on);
					return this;
				};

				/**
     * Remove the given callback for `event` or all
     * registered callbacks.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

				Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
					this._callbacks = this._callbacks || {};

					// all
					if (0 == arguments.length) {
						this._callbacks = {};
						return this;
					}

					// specific event
					var callbacks = this._callbacks['$' + event];
					if (!callbacks) return this;

					// remove all handlers
					if (1 == arguments.length) {
						delete this._callbacks['$' + event];
						return this;
					}

					// remove specific handler
					var cb;
					for (var i = 0; i < callbacks.length; i++) {
						cb = callbacks[i];
						if (cb === fn || cb.fn === fn) {
							callbacks.splice(i, 1);
							break;
						}
					}
					return this;
				};

				/**
     * Emit `event` with the given args.
     *
     * @param {String} event
     * @param {Mixed} ...
     * @return {Emitter}
     */

				Emitter.prototype.emit = function (event) {
					this._callbacks = this._callbacks || {};
					var args = [].slice.call(arguments, 1),
					    callbacks = this._callbacks['$' + event];

					if (callbacks) {
						callbacks = callbacks.slice(0);
						for (var i = 0, len = callbacks.length; i < len; ++i) {
							callbacks[i].apply(this, args);
						}
					}

					return this;
				};

				/**
     * Return array of callbacks for `event`.
     *
     * @param {String} event
     * @return {Array}
     * @api public
     */

				Emitter.prototype.listeners = function (event) {
					this._callbacks = this._callbacks || {};
					return this._callbacks['$' + event] || [];
				};

				/**
     * Check if this emitter has `event` handlers.
     *
     * @param {String} event
     * @return {Boolean}
     * @api public
     */

				Emitter.prototype.hasListeners = function (event) {
					return !!this.listeners(event).length;
				};
			}, {}], 39: [function (_dereq_, module, exports) {
				arguments[4][17][0].apply(exports, arguments);
			}, { "./debug": 40, "dup": 17 }], 40: [function (_dereq_, module, exports) {
				arguments[4][18][0].apply(exports, arguments);
			}, { "dup": 18, "ms": 44 }], 41: [function (_dereq_, module, exports) {
				(function (global) {

					/*
      * Module requirements.
      */

					var isArray = _dereq_('isarray');

					/**
      * Module exports.
      */

					module.exports = hasBinary;

					/**
      * Checks for binary data.
      *
      * Right now only Buffer and ArrayBuffer are supported..
      *
      * @param {Object} anything
      * @api public
      */

					function hasBinary(data) {

						function _hasBinary(obj) {
							if (!obj) return false;

							if (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer || global.Blob && obj instanceof Blob || global.File && obj instanceof File) {
								return true;
							}

							if (isArray(obj)) {
								for (var i = 0; i < obj.length; i++) {
									if (_hasBinary(obj[i])) {
										return true;
									}
								}
							} else if (obj && 'object' == (typeof obj === "undefined" ? "undefined" : _typeof(obj))) {
								// see: https://github.com/Automattic/has-binary/pull/4
								if (obj.toJSON && 'function' == typeof obj.toJSON) {
									obj = obj.toJSON();
								}

								for (var key in obj) {
									if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
										return true;
									}
								}
							}

							return false;
						}

						return _hasBinary(data);
					}
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "isarray": 43 }], 42: [function (_dereq_, module, exports) {
				arguments[4][23][0].apply(exports, arguments);
			}, { "dup": 23 }], 43: [function (_dereq_, module, exports) {
				arguments[4][24][0].apply(exports, arguments);
			}, { "dup": 24 }], 44: [function (_dereq_, module, exports) {
				arguments[4][25][0].apply(exports, arguments);
			}, { "dup": 25 }], 45: [function (_dereq_, module, exports) {
				arguments[4][28][0].apply(exports, arguments);
			}, { "dup": 28 }], 46: [function (_dereq_, module, exports) {
				(function (global) {
					/*global Blob,File*/

					/**
      * Module requirements
      */

					var isArray = _dereq_('isarray');
					var isBuf = _dereq_('./is-buffer');

					/**
      * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
      * Anything with blobs or files should be fed through removeBlobs before coming
      * here.
      *
      * @param {Object} packet - socket.io event packet
      * @return {Object} with deconstructed packet and list of buffers
      * @api public
      */

					exports.deconstructPacket = function (packet) {
						var buffers = [];
						var packetData = packet.data;

						function _deconstructPacket(data) {
							if (!data) return data;

							if (isBuf(data)) {
								var placeholder = { _placeholder: true, num: buffers.length };
								buffers.push(data);
								return placeholder;
							} else if (isArray(data)) {
								var newData = new Array(data.length);
								for (var i = 0; i < data.length; i++) {
									newData[i] = _deconstructPacket(data[i]);
								}
								return newData;
							} else if ('object' == (typeof data === "undefined" ? "undefined" : _typeof(data)) && !(data instanceof Date)) {
								var newData = {};
								for (var key in data) {
									newData[key] = _deconstructPacket(data[key]);
								}
								return newData;
							}
							return data;
						}

						var pack = packet;
						pack.data = _deconstructPacket(packetData);
						pack.attachments = buffers.length; // number of binary 'attachments'
						return { packet: pack, buffers: buffers };
					};

					/**
      * Reconstructs a binary packet from its placeholder packet and buffers
      *
      * @param {Object} packet - event packet with placeholders
      * @param {Array} buffers - binary buffers to put in placeholder positions
      * @return {Object} reconstructed packet
      * @api public
      */

					exports.reconstructPacket = function (packet, buffers) {
						var curPlaceHolder = 0;

						function _reconstructPacket(data) {
							if (data && data._placeholder) {
								var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
								return buf;
							} else if (isArray(data)) {
								for (var i = 0; i < data.length; i++) {
									data[i] = _reconstructPacket(data[i]);
								}
								return data;
							} else if (data && 'object' == (typeof data === "undefined" ? "undefined" : _typeof(data))) {
								for (var key in data) {
									data[key] = _reconstructPacket(data[key]);
								}
								return data;
							}
							return data;
						}

						packet.data = _reconstructPacket(packet.data);
						packet.attachments = undefined; // no longer useful
						return packet;
					};

					/**
      * Asynchronously removes Blobs or Files from data via
      * FileReader's readAsArrayBuffer method. Used before encoding
      * data as msgpack. Calls callback with the blobless data.
      *
      * @param {Object} data
      * @param {Function} callback
      * @api private
      */

					exports.removeBlobs = function (data, callback) {
						function _removeBlobs(obj, curKey, containingObject) {
							if (!obj) return obj;

							// convert any blob
							if (global.Blob && obj instanceof Blob || global.File && obj instanceof File) {
								pendingBlobs++;

								// async filereader
								var fileReader = new FileReader();
								fileReader.onload = function () {
									// this.result == arraybuffer
									if (containingObject) {
										containingObject[curKey] = this.result;
									} else {
										bloblessData = this.result;
									}

									// if nothing pending its callback time
									if (! --pendingBlobs) {
										callback(bloblessData);
									}
								};

								fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
							} else if (isArray(obj)) {
								// handle array
								for (var i = 0; i < obj.length; i++) {
									_removeBlobs(obj[i], i, obj);
								}
							} else if (obj && 'object' == (typeof obj === "undefined" ? "undefined" : _typeof(obj)) && !isBuf(obj)) {
								// and object
								for (var key in obj) {
									_removeBlobs(obj[key], key, obj);
								}
							}
						}

						var pendingBlobs = 0;
						var bloblessData = data;
						_removeBlobs(bloblessData);
						if (!pendingBlobs) {
							callback(bloblessData);
						}
					};
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "./is-buffer": 48, "isarray": 43 }], 47: [function (_dereq_, module, exports) {

				/**
     * Module dependencies.
     */

				var debug = _dereq_('debug')('socket.io-parser');
				var json = _dereq_('json3');
				var isArray = _dereq_('isarray');
				var Emitter = _dereq_('component-emitter');
				var binary = _dereq_('./binary');
				var isBuf = _dereq_('./is-buffer');

				/**
     * Protocol version.
     *
     * @api public
     */

				exports.protocol = 4;

				/**
     * Packet types.
     *
     * @api public
     */

				exports.types = ['CONNECT', 'DISCONNECT', 'EVENT', 'BINARY_EVENT', 'ACK', 'BINARY_ACK', 'ERROR'];

				/**
     * Packet type `connect`.
     *
     * @api public
     */

				exports.CONNECT = 0;

				/**
     * Packet type `disconnect`.
     *
     * @api public
     */

				exports.DISCONNECT = 1;

				/**
     * Packet type `event`.
     *
     * @api public
     */

				exports.EVENT = 2;

				/**
     * Packet type `ack`.
     *
     * @api public
     */

				exports.ACK = 3;

				/**
     * Packet type `error`.
     *
     * @api public
     */

				exports.ERROR = 4;

				/**
     * Packet type 'binary event'
     *
     * @api public
     */

				exports.BINARY_EVENT = 5;

				/**
     * Packet type `binary ack`. For acks with binary arguments.
     *
     * @api public
     */

				exports.BINARY_ACK = 6;

				/**
     * Encoder constructor.
     *
     * @api public
     */

				exports.Encoder = Encoder;

				/**
     * Decoder constructor.
     *
     * @api public
     */

				exports.Decoder = Decoder;

				/**
     * A socket.io Encoder instance
     *
     * @api public
     */

				function Encoder() {}

				/**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     * @param {Function} callback - function to handle encodings (likely engine.write)
     * @return Calls callback with Array of encodings
     * @api public
     */

				Encoder.prototype.encode = function (obj, callback) {
					debug('encoding packet %j', obj);

					if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
						encodeAsBinary(obj, callback);
					} else {
						var encoding = encodeAsString(obj);
						callback([encoding]);
					}
				};

				/**
     * Encode packet as string.
     *
     * @param {Object} packet
     * @return {String} encoded
     * @api private
     */

				function encodeAsString(obj) {
					var str = '';
					var nsp = false;

					// first is type
					str += obj.type;

					// attachments if we have them
					if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
						str += obj.attachments;
						str += '-';
					}

					// if we have a namespace other than `/`
					// we append it followed by a comma `,`
					if (obj.nsp && '/' != obj.nsp) {
						nsp = true;
						str += obj.nsp;
					}

					// immediately followed by the id
					if (null != obj.id) {
						if (nsp) {
							str += ',';
							nsp = false;
						}
						str += obj.id;
					}

					// json data
					if (null != obj.data) {
						if (nsp) str += ',';
						str += json.stringify(obj.data);
					}

					debug('encoded %j as %s', obj, str);
					return str;
				}

				/**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     *
     * @param {Object} packet
     * @return {Buffer} encoded
     * @api private
     */

				function encodeAsBinary(obj, callback) {

					function writeEncoding(bloblessData) {
						var deconstruction = binary.deconstructPacket(bloblessData);
						var pack = encodeAsString(deconstruction.packet);
						var buffers = deconstruction.buffers;

						buffers.unshift(pack); // add packet info to beginning of data list
						callback(buffers); // write all the buffers
					}

					binary.removeBlobs(obj, writeEncoding);
				}

				/**
     * A socket.io Decoder instance
     *
     * @return {Object} decoder
     * @api public
     */

				function Decoder() {
					this.reconstructor = null;
				}

				/**
     * Mix in `Emitter` with Decoder.
     */

				Emitter(Decoder.prototype);

				/**
     * Decodes an ecoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     * @return {Object} packet
     * @api public
     */

				Decoder.prototype.add = function (obj) {
					var packet;
					if ('string' == typeof obj) {
						packet = decodeString(obj);
						if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) {
							// binary packet's json
							this.reconstructor = new BinaryReconstructor(packet);

							// no attachments, labeled binary but no binary data to follow
							if (this.reconstructor.reconPack.attachments === 0) {
								this.emit('decoded', packet);
							}
						} else {
							// non-binary full packet
							this.emit('decoded', packet);
						}
					} else if (isBuf(obj) || obj.base64) {
						// raw binary data
						if (!this.reconstructor) {
							throw new Error('got binary data when not reconstructing a packet');
						} else {
							packet = this.reconstructor.takeBinaryData(obj);
							if (packet) {
								// received final buffer
								this.reconstructor = null;
								this.emit('decoded', packet);
							}
						}
					} else {
						throw new Error('Unknown type: ' + obj);
					}
				};

				/**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     * @api private
     */

				function decodeString(str) {
					var p = {};
					var i = 0;

					// look up type
					p.type = Number(str.charAt(0));
					if (null == exports.types[p.type]) return error();

					// look up attachments if type binary
					if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
						var buf = '';
						while (str.charAt(++i) != '-') {
							buf += str.charAt(i);
							if (i == str.length) break;
						}
						if (buf != Number(buf) || str.charAt(i) != '-') {
							throw new Error('Illegal attachments');
						}
						p.attachments = Number(buf);
					}

					// look up namespace (if any)
					if ('/' == str.charAt(i + 1)) {
						p.nsp = '';
						while (++i) {
							var c = str.charAt(i);
							if (',' == c) break;
							p.nsp += c;
							if (i == str.length) break;
						}
					} else {
						p.nsp = '/';
					}

					// look up id
					var next = str.charAt(i + 1);
					if ('' !== next && Number(next) == next) {
						p.id = '';
						while (++i) {
							var c = str.charAt(i);
							if (null == c || Number(c) != c) {
								--i;
								break;
							}
							p.id += str.charAt(i);
							if (i == str.length) break;
						}
						p.id = Number(p.id);
					}

					// look up json data
					if (str.charAt(++i)) {
						try {
							p.data = json.parse(str.substr(i));
						} catch (e) {
							return error();
						}
					}

					debug('decoded %s as %j', str, p);
					return p;
				}

				/**
     * Deallocates a parser's resources
     *
     * @api public
     */

				Decoder.prototype.destroy = function () {
					if (this.reconstructor) {
						this.reconstructor.finishedReconstruction();
					}
				};

				/**
     * A manager of a binary event's 'buffer sequence'. Should
     * be constructed whenever a packet of type BINARY_EVENT is
     * decoded.
     *
     * @param {Object} packet
     * @return {BinaryReconstructor} initialized reconstructor
     * @api private
     */

				function BinaryReconstructor(packet) {
					this.reconPack = packet;
					this.buffers = [];
				}

				/**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     * @api private
     */

				BinaryReconstructor.prototype.takeBinaryData = function (binData) {
					this.buffers.push(binData);
					if (this.buffers.length == this.reconPack.attachments) {
						// done with buffer list
						var packet = binary.reconstructPacket(this.reconPack, this.buffers);
						this.finishedReconstruction();
						return packet;
					}
					return null;
				};

				/**
     * Cleans up binary packet reconstruction variables.
     *
     * @api private
     */

				BinaryReconstructor.prototype.finishedReconstruction = function () {
					this.reconPack = null;
					this.buffers = [];
				};

				function error(data) {
					return {
						type: exports.ERROR,
						data: 'parser error'
					};
				}
			}, { "./binary": 46, "./is-buffer": 48, "component-emitter": 49, "debug": 39, "isarray": 43, "json3": 50 }], 48: [function (_dereq_, module, exports) {
				(function (global) {

					module.exports = isBuf;

					/**
      * Returns true if obj is a buffer or an arraybuffer.
      *
      * @api private
      */

					function isBuf(obj) {
						return global.Buffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer;
					}
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, {}], 49: [function (_dereq_, module, exports) {
				arguments[4][15][0].apply(exports, arguments);
			}, { "dup": 15 }], 50: [function (_dereq_, module, exports) {
				(function (global) {
					/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
					;(function () {
						// Detect the `define` function exposed by asynchronous module loaders. The
						// strict `define` check is necessary for compatibility with `r.js`.
						var isLoader = typeof define === "function" && define.amd;

						// A set of types used to distinguish objects from primitives.
						var objectTypes = {
							"function": true,
							"object": true
						};

						// Detect the `exports` object exposed by CommonJS implementations.
						var freeExports = objectTypes[typeof exports === "undefined" ? "undefined" : _typeof(exports)] && exports && !exports.nodeType && exports;

						// Use the `global` object exposed by Node (including Browserify via
						// `insert-module-globals`), Narwhal, and Ringo as the default context,
						// and the `window` object in browsers. Rhino exports a `global` function
						// instead.
						var root = objectTypes[typeof window === "undefined" ? "undefined" : _typeof(window)] && window || this,
						    freeGlobal = freeExports && objectTypes[typeof module === "undefined" ? "undefined" : _typeof(module)] && module && !module.nodeType && (typeof global === "undefined" ? "undefined" : _typeof(global)) == "object" && global;

						if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
							root = freeGlobal;
						}

						// Public: Initializes JSON 3 using the given `context` object, attaching the
						// `stringify` and `parse` functions to the specified `exports` object.
						function runInContext(context, exports) {
							context || (context = root["Object"]());
							exports || (exports = root["Object"]());

							// Native constructor aliases.
							var Number = context["Number"] || root["Number"],
							    String = context["String"] || root["String"],
							    Object = context["Object"] || root["Object"],
							    Date = context["Date"] || root["Date"],
							    SyntaxError = context["SyntaxError"] || root["SyntaxError"],
							    TypeError = context["TypeError"] || root["TypeError"],
							    Math = context["Math"] || root["Math"],
							    nativeJSON = context["JSON"] || root["JSON"];

							// Delegate to the native `stringify` and `parse` implementations.
							if ((typeof nativeJSON === "undefined" ? "undefined" : _typeof(nativeJSON)) == "object" && nativeJSON) {
								exports.stringify = nativeJSON.stringify;
								exports.parse = nativeJSON.parse;
							}

							// Convenience aliases.
							var objectProto = Object.prototype,
							    getClass = objectProto.toString,
							    _isProperty,
							    _forEach,
							    undef;

							// Test the `Date#getUTC*` methods. Based on work by @Yaffle.
							var isExtended = new Date(-3509827334573292);
							try {
								// The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
								// results for certain dates in Opera >= 10.53.
								isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
								// Safari < 2.0.2 stores the internal millisecond time value correctly,
								// but clips the values returned by the date methods to the range of
								// signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
								isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
							} catch (exception) {}

							// Internal: Determines whether the native `JSON.stringify` and `parse`
							// implementations are spec-compliant. Based on work by Ken Snyder.
							function has(name) {
								if (has[name] !== undef) {
									// Return cached feature test result.
									return has[name];
								}
								var isSupported;
								if (name == "bug-string-char-index") {
									// IE <= 7 doesn't support accessing string characters using square
									// bracket notation. IE 8 only supports this for primitives.
									isSupported = "a"[0] != "a";
								} else if (name == "json") {
									// Indicates whether both `JSON.stringify` and `JSON.parse` are
									// supported.
									isSupported = has("json-stringify") && has("json-parse");
								} else {
									var value,
									    serialized = "{\"a\":[1,true,false,null,\"\\u0000\\b\\n\\f\\r\\t\"]}";
									// Test `JSON.stringify`.
									if (name == "json-stringify") {
										var stringify = exports.stringify,
										    stringifySupported = typeof stringify == "function" && isExtended;
										if (stringifySupported) {
											// A test function object with a custom `toJSON` method.
											(value = function value() {
												return 1;
											}).toJSON = value;
											try {
												stringifySupported =
												// Firefox 3.1b1 and b2 serialize string, number, and boolean
												// primitives as object literals.
												stringify(0) === "0" &&
												// FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
												// literals.
												stringify(new Number()) === "0" && stringify(new String()) == '""' &&
												// FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
												// does not define a canonical JSON representation (this applies to
												// objects with `toJSON` properties as well, *unless* they are nested
												// within an object or array).
												stringify(getClass) === undef &&
												// IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
												// FF 3.1b3 pass this test.
												stringify(undef) === undef &&
												// Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
												// respectively, if the value is omitted entirely.
												stringify() === undef &&
												// FF 3.1b1, 2 throw an error if the given value is not a number,
												// string, array, object, Boolean, or `null` literal. This applies to
												// objects with custom `toJSON` methods as well, unless they are nested
												// inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
												// methods entirely.
												stringify(value) === "1" && stringify([value]) == "[1]" &&
												// Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
												// `"[null]"`.
												stringify([undef]) == "[null]" &&
												// YUI 3.0.0b1 fails to serialize `null` literals.
												stringify(null) == "null" &&
												// FF 3.1b1, 2 halts serialization if an array contains a function:
												// `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
												// elides non-JSON values from objects and arrays, unless they
												// define custom `toJSON` methods.
												stringify([undef, getClass, null]) == "[null,null,null]" &&
												// Simple serialization test. FF 3.1b1 uses Unicode escape sequences
												// where character escape codes are expected (e.g., `\b` => `\u0008`).
												stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
												// FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
												stringify(null, value) === "1" && stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
												// JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
												// serialize extended years.
												stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
												// The milliseconds are optional in ES 5, but required in 5.1.
												stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
												// Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
												// four-digit years instead of six-digit years. Credits: @Yaffle.
												stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
												// Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
												// values less than 1000. Credits: @Yaffle.
												stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
											} catch (exception) {
												stringifySupported = false;
											}
										}
										isSupported = stringifySupported;
									}
									// Test `JSON.parse`.
									if (name == "json-parse") {
										var parse = exports.parse;
										if (typeof parse == "function") {
											try {
												// FF 3.1b1, b2 will throw an exception if a bare literal is provided.
												// Conforming implementations should also coerce the initial argument to
												// a string prior to parsing.
												if (parse("0") === 0 && !parse(false)) {
													// Simple parsing test.
													value = parse(serialized);
													var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
													if (parseSupported) {
														try {
															// Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
															parseSupported = !parse('"\t"');
														} catch (exception) {}
														if (parseSupported) {
															try {
																// FF 4.0 and 4.0.1 allow leading `+` signs and leading
																// decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
																// certain octal literals.
																parseSupported = parse("01") !== 1;
															} catch (exception) {}
														}
														if (parseSupported) {
															try {
																// FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
																// points. These environments, along with FF 3.1b1 and 2,
																// also allow trailing commas in JSON objects and arrays.
																parseSupported = parse("1.") !== 1;
															} catch (exception) {}
														}
													}
												}
											} catch (exception) {
												parseSupported = false;
											}
										}
										isSupported = parseSupported;
									}
								}
								return has[name] = !!isSupported;
							}

							if (!has("json")) {
								// Common `[[Class]]` name aliases.
								var functionClass = "[object Function]",
								    dateClass = "[object Date]",
								    numberClass = "[object Number]",
								    stringClass = "[object String]",
								    arrayClass = "[object Array]",
								    booleanClass = "[object Boolean]";

								// Detect incomplete support for accessing string characters by index.
								var charIndexBuggy = has("bug-string-char-index");

								// Define additional utility methods if the `Date` methods are buggy.
								if (!isExtended) {
									var floor = Math.floor;
									// A mapping between the months of the year and the number of days between
									// January 1st and the first of the respective month.
									var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
									// Internal: Calculates the number of days between the Unix epoch and the
									// first day of the given month.
									var getDay = function getDay(year, month) {
										return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
									};
								}

								// Internal: Determines if a property is a direct property of the given
								// object. Delegates to the native `Object#hasOwnProperty` method.
								if (!(_isProperty = objectProto.hasOwnProperty)) {
									_isProperty = function isProperty(property) {
										var members = {},
										    constructor;
										if ((members.__proto__ = null, members.__proto__ = {
											// The *proto* property cannot be set multiple times in recent
											// versions of Firefox and SeaMonkey.
											"toString": 1
										}, members).toString != getClass) {
											// Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
											// supports the mutable *proto* property.
											_isProperty = function isProperty(property) {
												// Capture and break the object's prototype chain (see section 8.6.2
												// of the ES 5.1 spec). The parenthesized expression prevents an
												// unsafe transformation by the Closure Compiler.
												var original = this.__proto__,
												    result = property in (this.__proto__ = null, this);
												// Restore the original prototype chain.
												this.__proto__ = original;
												return result;
											};
										} else {
											// Capture a reference to the top-level `Object` constructor.
											constructor = members.constructor;
											// Use the `constructor` property to simulate `Object#hasOwnProperty` in
											// other environments.
											_isProperty = function isProperty(property) {
												var parent = (this.constructor || constructor).prototype;
												return property in this && !(property in parent && this[property] === parent[property]);
											};
										}
										members = null;
										return _isProperty.call(this, property);
									};
								}

								// Internal: Normalizes the `for...in` iteration algorithm across
								// environments. Each enumerated key is yielded to a `callback` function.
								_forEach = function forEach(object, callback) {
									var size = 0,
									    Properties,
									    members,
									    property;

									// Tests for bugs in the current environment's `for...in` algorithm. The
									// `valueOf` property inherits the non-enumerable flag from
									// `Object.prototype` in older versions of IE, Netscape, and Mozilla.
									(Properties = function Properties() {
										this.valueOf = 0;
									}).prototype.valueOf = 0;

									// Iterate over a new instance of the `Properties` class.
									members = new Properties();
									for (property in members) {
										// Ignore all properties inherited from `Object.prototype`.
										if (_isProperty.call(members, property)) {
											size++;
										}
									}
									Properties = members = null;

									// Normalize the iteration algorithm.
									if (!size) {
										// A list of non-enumerable properties inherited from `Object.prototype`.
										members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
										// IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
										// properties.
										_forEach = function forEach(object, callback) {
											var isFunction = getClass.call(object) == functionClass,
											    property,
											    length;
											var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[_typeof(object.hasOwnProperty)] && object.hasOwnProperty || _isProperty;
											for (property in object) {
												// Gecko <= 1.0 enumerates the `prototype` property of functions under
												// certain conditions; IE does not.
												if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
													callback(property);
												}
											}
											// Manually invoke the callback for each non-enumerable property.
											for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property)) {}
										};
									} else if (size == 2) {
										// Safari <= 2.0.4 enumerates shadowed properties twice.
										_forEach = function forEach(object, callback) {
											// Create a set of iterated properties.
											var members = {},
											    isFunction = getClass.call(object) == functionClass,
											    property;
											for (property in object) {
												// Store each property name to prevent double enumeration. The
												// `prototype` property of functions is not enumerated due to cross-
												// environment inconsistencies.
												if (!(isFunction && property == "prototype") && !_isProperty.call(members, property) && (members[property] = 1) && _isProperty.call(object, property)) {
													callback(property);
												}
											}
										};
									} else {
										// No bugs detected; use the standard `for...in` algorithm.
										_forEach = function forEach(object, callback) {
											var isFunction = getClass.call(object) == functionClass,
											    property,
											    isConstructor;
											for (property in object) {
												if (!(isFunction && property == "prototype") && _isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
													callback(property);
												}
											}
											// Manually invoke the callback for the `constructor` property due to
											// cross-environment inconsistencies.
											if (isConstructor || _isProperty.call(object, property = "constructor")) {
												callback(property);
											}
										};
									}
									return _forEach(object, callback);
								};

								// Public: Serializes a JavaScript `value` as a JSON string. The optional
								// `filter` argument may specify either a function that alters how object and
								// array members are serialized, or an array of strings and numbers that
								// indicates which properties should be serialized. The optional `width`
								// argument may be either a string or number that specifies the indentation
								// level of the output.
								if (!has("json-stringify")) {
									// Internal: A map of control characters and their escaped equivalents.
									var Escapes = {
										92: "\\\\",
										34: '\\"',
										8: "\\b",
										12: "\\f",
										10: "\\n",
										13: "\\r",
										9: "\\t"
									};

									// Internal: Converts `value` into a zero-padded string such that its
									// length is at least equal to `width`. The `width` must be <= 6.
									var leadingZeroes = "000000";
									var toPaddedString = function toPaddedString(width, value) {
										// The `|| 0` expression is necessary to work around a bug in
										// Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
										return (leadingZeroes + (value || 0)).slice(-width);
									};

									// Internal: Double-quotes a string `value`, replacing all ASCII control
									// characters (characters with code unit values between 0 and 31) with
									// their escaped equivalents. This is an implementation of the
									// `Quote(value)` operation defined in ES 5.1 section 15.12.3.
									var unicodePrefix = "\\u00";
									var quote = function quote(value) {
										var result = '"',
										    index = 0,
										    length = value.length,
										    useCharIndex = !charIndexBuggy || length > 10;
										var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
										for (; index < length; index++) {
											var charCode = value.charCodeAt(index);
											// If the character is a control character, append its Unicode or
											// shorthand escape sequence; otherwise, append the character as-is.
											switch (charCode) {
												case 8:case 9:case 10:case 12:case 13:case 34:case 92:
													result += Escapes[charCode];
													break;
												default:
													if (charCode < 32) {
														result += unicodePrefix + toPaddedString(2, charCode.toString(16));
														break;
													}
													result += useCharIndex ? symbols[index] : value.charAt(index);
											}
										}
										return result + '"';
									};

									// Internal: Recursively serializes an object. Implements the
									// `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
									var serialize = function serialize(property, object, callback, properties, whitespace, indentation, stack) {
										var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
										try {
											// Necessary for host object support.
											value = object[property];
										} catch (exception) {}
										if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && value) {
											className = getClass.call(value);
											if (className == dateClass && !_isProperty.call(value, "toJSON")) {
												if (value > -1 / 0 && value < 1 / 0) {
													// Dates are serialized according to the `Date#toJSON` method
													// specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
													// for the ISO 8601 date time string format.
													if (getDay) {
														// Manually compute the year, month, date, hours, minutes,
														// seconds, and milliseconds if the `getUTC*` methods are
														// buggy. Adapted from @Yaffle's `date-shim` project.
														date = floor(value / 864e5);
														for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++) {}
														for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++) {}
														date = 1 + date - getDay(year, month);
														// The `time` value specifies the time within the day (see ES
														// 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
														// to compute `A modulo B`, as the `%` operator does not
														// correspond to the `modulo` operation for negative numbers.
														time = (value % 864e5 + 864e5) % 864e5;
														// The hours, minutes, seconds, and milliseconds are obtained by
														// decomposing the time within the day. See section 15.9.1.10.
														hours = floor(time / 36e5) % 24;
														minutes = floor(time / 6e4) % 60;
														seconds = floor(time / 1e3) % 60;
														milliseconds = time % 1e3;
													} else {
														year = value.getUTCFullYear();
														month = value.getUTCMonth();
														date = value.getUTCDate();
														hours = value.getUTCHours();
														minutes = value.getUTCMinutes();
														seconds = value.getUTCSeconds();
														milliseconds = value.getUTCMilliseconds();
													}
													// Serialize extended years correctly.
													value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
													// Months, dates, hours, minutes, and seconds should have two
													// digits; milliseconds should have three.
													"T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
													// Milliseconds are optional in ES 5.0, but required in 5.1.
													"." + toPaddedString(3, milliseconds) + "Z";
												} else {
													value = null;
												}
											} else if (typeof value.toJSON == "function" && (className != numberClass && className != stringClass && className != arrayClass || _isProperty.call(value, "toJSON"))) {
												// Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
												// `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
												// ignores all `toJSON` methods on these objects unless they are
												// defined directly on an instance.
												value = value.toJSON(property);
											}
										}
										if (callback) {
											// If a replacement function was provided, call it to obtain the value
											// for serialization.
											value = callback.call(object, property, value);
										}
										if (value === null) {
											return "null";
										}
										className = getClass.call(value);
										if (className == booleanClass) {
											// Booleans are represented literally.
											return "" + value;
										} else if (className == numberClass) {
											// JSON numbers must be finite. `Infinity` and `NaN` are serialized as
											// `"null"`.
											return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
										} else if (className == stringClass) {
											// Strings are double-quoted and escaped.
											return quote("" + value);
										}
										// Recursively serialize objects and arrays.
										if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object") {
											// Check for cyclic structures. This is a linear search; performance
											// is inversely proportional to the number of unique nested objects.
											for (length = stack.length; length--;) {
												if (stack[length] === value) {
													// Cyclic structures cannot be serialized by `JSON.stringify`.
													throw TypeError();
												}
											}
											// Add the object to the stack of traversed objects.
											stack.push(value);
											results = [];
											// Save the current indentation level and indent one additional level.
											prefix = indentation;
											indentation += whitespace;
											if (className == arrayClass) {
												// Recursively serialize array elements.
												for (index = 0, length = value.length; index < length; index++) {
													element = serialize(index, value, callback, properties, whitespace, indentation, stack);
													results.push(element === undef ? "null" : element);
												}
												result = results.length ? whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : "[" + results.join(",") + "]" : "[]";
											} else {
												// Recursively serialize object members. Members are selected from
												// either a user-specified list of property names, or the object
												// itself.
												_forEach(properties || value, function (property) {
													var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
													if (element !== undef) {
														// According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
														// is not the empty string, let `member` {quote(property) + ":"}
														// be the concatenation of `member` and the `space` character."
														// The "`space` character" refers to the literal space
														// character, not the `space` {width} argument provided to
														// `JSON.stringify`.
														results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
													}
												});
												result = results.length ? whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : "{" + results.join(",") + "}" : "{}";
											}
											// Remove the object from the traversed object stack.
											stack.pop();
											return result;
										}
									};

									// Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
									exports.stringify = function (source, filter, width) {
										var whitespace, callback, properties, className;
										if (objectTypes[typeof filter === "undefined" ? "undefined" : _typeof(filter)] && filter) {
											if ((className = getClass.call(filter)) == functionClass) {
												callback = filter;
											} else if (className == arrayClass) {
												// Convert the property names array into a makeshift set.
												properties = {};
												for (var index = 0, length = filter.length, value; index < length; value = filter[index++], (className = getClass.call(value), className == stringClass || className == numberClass) && (properties[value] = 1)) {}
											}
										}
										if (width) {
											if ((className = getClass.call(width)) == numberClass) {
												// Convert the `width` to an integer and create a string containing
												// `width` number of space characters.
												if ((width -= width % 1) > 0) {
													for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ") {}
												}
											} else if (className == stringClass) {
												whitespace = width.length <= 10 ? width : width.slice(0, 10);
											}
										}
										// Opera <= 7.54u2 discards the values associated with empty string keys
										// (`""`) only if they are used directly within an object member list
										// (e.g., `!("" in { "": 1})`).
										return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
									};
								}

								// Public: Parses a JSON source string.
								if (!has("json-parse")) {
									var fromCharCode = String.fromCharCode;

									// Internal: A map of escaped control characters and their unescaped
									// equivalents.
									var Unescapes = {
										92: "\\",
										34: '"',
										47: "/",
										98: "\b",
										116: "\t",
										110: "\n",
										102: "\f",
										114: "\r"
									};

									// Internal: Stores the parser state.
									var Index, Source;

									// Internal: Resets the parser state and throws a `SyntaxError`.
									var abort = function abort() {
										Index = Source = null;
										throw SyntaxError();
									};

									// Internal: Returns the next token, or `"$"` if the parser has reached
									// the end of the source string. A token may be a string, number, `null`
									// literal, or Boolean literal.
									var lex = function lex() {
										var source = Source,
										    length = source.length,
										    value,
										    begin,
										    position,
										    isSigned,
										    charCode;
										while (Index < length) {
											charCode = source.charCodeAt(Index);
											switch (charCode) {
												case 9:case 10:case 13:case 32:
													// Skip whitespace tokens, including tabs, carriage returns, line
													// feeds, and space characters.
													Index++;
													break;
												case 123:case 125:case 91:case 93:case 58:case 44:
													// Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
													// the current position.
													value = charIndexBuggy ? source.charAt(Index) : source[Index];
													Index++;
													return value;
												case 34:
													// `"` delimits a JSON string; advance to the next character and
													// begin parsing the string. String tokens are prefixed with the
													// sentinel `@` character to distinguish them from punctuators and
													// end-of-string tokens.
													for (value = "@", Index++; Index < length;) {
														charCode = source.charCodeAt(Index);
														if (charCode < 32) {
															// Unescaped ASCII control characters (those with a code unit
															// less than the space character) are not permitted.
															abort();
														} else if (charCode == 92) {
															// A reverse solidus (`\`) marks the beginning of an escaped
															// control character (including `"`, `\`, and `/`) or Unicode
															// escape sequence.
															charCode = source.charCodeAt(++Index);
															switch (charCode) {
																case 92:case 34:case 47:case 98:case 116:case 110:case 102:case 114:
																	// Revive escaped control characters.
																	value += Unescapes[charCode];
																	Index++;
																	break;
																case 117:
																	// `\u` marks the beginning of a Unicode escape sequence.
																	// Advance to the first character and validate the
																	// four-digit code point.
																	begin = ++Index;
																	for (position = Index + 4; Index < position; Index++) {
																		charCode = source.charCodeAt(Index);
																		// A valid sequence comprises four hexdigits (case-
																		// insensitive) that form a single hexadecimal value.
																		if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
																			// Invalid Unicode escape sequence.
																			abort();
																		}
																	}
																	// Revive the escaped character.
																	value += fromCharCode("0x" + source.slice(begin, Index));
																	break;
																default:
																	// Invalid escape sequence.
																	abort();
															}
														} else {
															if (charCode == 34) {
																// An unescaped double-quote character marks the end of the
																// string.
																break;
															}
															charCode = source.charCodeAt(Index);
															begin = Index;
															// Optimize for the common case where a string is valid.
															while (charCode >= 32 && charCode != 92 && charCode != 34) {
																charCode = source.charCodeAt(++Index);
															}
															// Append the string as-is.
															value += source.slice(begin, Index);
														}
													}
													if (source.charCodeAt(Index) == 34) {
														// Advance to the next character and return the revived string.
														Index++;
														return value;
													}
													// Unterminated string.
													abort();
												default:
													// Parse numbers and literals.
													begin = Index;
													// Advance past the negative sign, if one is specified.
													if (charCode == 45) {
														isSigned = true;
														charCode = source.charCodeAt(++Index);
													}
													// Parse an integer or floating-point value.
													if (charCode >= 48 && charCode <= 57) {
														// Leading zeroes are interpreted as octal literals.
														if (charCode == 48 && (charCode = source.charCodeAt(Index + 1), charCode >= 48 && charCode <= 57)) {
															// Illegal octal literal.
															abort();
														}
														isSigned = false;
														// Parse the integer component.
														for (; Index < length && (charCode = source.charCodeAt(Index), charCode >= 48 && charCode <= 57); Index++) {}
														// Floats cannot contain a leading decimal point; however, this
														// case is already accounted for by the parser.
														if (source.charCodeAt(Index) == 46) {
															position = ++Index;
															// Parse the decimal component.
															for (; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}
															if (position == Index) {
																// Illegal trailing decimal.
																abort();
															}
															Index = position;
														}
														// Parse exponents. The `e` denoting the exponent is
														// case-insensitive.
														charCode = source.charCodeAt(Index);
														if (charCode == 101 || charCode == 69) {
															charCode = source.charCodeAt(++Index);
															// Skip past the sign following the exponent, if one is
															// specified.
															if (charCode == 43 || charCode == 45) {
																Index++;
															}
															// Parse the exponential component.
															for (position = Index; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}
															if (position == Index) {
																// Illegal empty exponent.
																abort();
															}
															Index = position;
														}
														// Coerce the parsed value to a JavaScript number.
														return +source.slice(begin, Index);
													}
													// A negative sign may only precede numbers.
													if (isSigned) {
														abort();
													}
													// `true`, `false`, and `null` literals.
													if (source.slice(Index, Index + 4) == "true") {
														Index += 4;
														return true;
													} else if (source.slice(Index, Index + 5) == "false") {
														Index += 5;
														return false;
													} else if (source.slice(Index, Index + 4) == "null") {
														Index += 4;
														return null;
													}
													// Unrecognized token.
													abort();
											}
										}
										// Return the sentinel `$` character if the parser has reached the end
										// of the source string.
										return "$";
									};

									// Internal: Parses a JSON `value` token.
									var get = function get(value) {
										var results, hasMembers;
										if (value == "$") {
											// Unexpected end of input.
											abort();
										}
										if (typeof value == "string") {
											if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
												// Remove the sentinel `@` character.
												return value.slice(1);
											}
											// Parse object and array literals.
											if (value == "[") {
												// Parses a JSON array, returning a new JavaScript array.
												results = [];
												for (;; hasMembers || (hasMembers = true)) {
													value = lex();
													// A closing square bracket marks the end of the array literal.
													if (value == "]") {
														break;
													}
													// If the array literal contains elements, the current token
													// should be a comma separating the previous element from the
													// next.
													if (hasMembers) {
														if (value == ",") {
															value = lex();
															if (value == "]") {
																// Unexpected trailing `,` in array literal.
																abort();
															}
														} else {
															// A `,` must separate each array element.
															abort();
														}
													}
													// Elisions and leading commas are not permitted.
													if (value == ",") {
														abort();
													}
													results.push(get(value));
												}
												return results;
											} else if (value == "{") {
												// Parses a JSON object, returning a new JavaScript object.
												results = {};
												for (;; hasMembers || (hasMembers = true)) {
													value = lex();
													// A closing curly brace marks the end of the object literal.
													if (value == "}") {
														break;
													}
													// If the object literal contains members, the current token
													// should be a comma separator.
													if (hasMembers) {
														if (value == ",") {
															value = lex();
															if (value == "}") {
																// Unexpected trailing `,` in object literal.
																abort();
															}
														} else {
															// A `,` must separate each object member.
															abort();
														}
													}
													// Leading commas are not permitted, object property names must be
													// double-quoted strings, and a `:` must separate each property
													// name and value.
													if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
														abort();
													}
													results[value.slice(1)] = get(lex());
												}
												return results;
											}
											// Unexpected token encountered.
											abort();
										}
										return value;
									};

									// Internal: Updates a traversed object member.
									var update = function update(source, property, callback) {
										var element = walk(source, property, callback);
										if (element === undef) {
											delete source[property];
										} else {
											source[property] = element;
										}
									};

									// Internal: Recursively traverses a parsed JSON object, invoking the
									// `callback` function for each value. This is an implementation of the
									// `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
									var walk = function walk(source, property, callback) {
										var value = source[property],
										    length;
										if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && value) {
											// `forEach` can't be used to traverse an array in Opera <= 8.54
											// because its `Object#hasOwnProperty` implementation returns `false`
											// for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
											if (getClass.call(value) == arrayClass) {
												for (length = value.length; length--;) {
													update(value, length, callback);
												}
											} else {
												_forEach(value, function (property) {
													update(value, property, callback);
												});
											}
										}
										return callback.call(source, property, value);
									};

									// Public: `JSON.parse`. See ES 5.1 section 15.12.2.
									exports.parse = function (source, callback) {
										var result, value;
										Index = 0;
										Source = "" + source;
										result = get(lex());
										// If a JSON string contains multiple tokens, it is invalid.
										if (lex() != "$") {
											abort();
										}
										// Reset the parser state.
										Index = Source = null;
										return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
									};
								}
							}

							exports["runInContext"] = runInContext;
							return exports;
						}

						if (freeExports && !isLoader) {
							// Export for CommonJS environments.
							runInContext(root, freeExports);
						} else {
							// Export for web browsers and JavaScript engines.
							var nativeJSON = root.JSON,
							    previousJSON = root["JSON3"],
							    isRestored = false;

							var JSON3 = runInContext(root, root["JSON3"] = {
								// Public: Restores the original value of the global `JSON` object and
								// returns a reference to the `JSON3` object.
								"noConflict": function noConflict() {
									if (!isRestored) {
										isRestored = true;
										root.JSON = nativeJSON;
										root["JSON3"] = previousJSON;
										nativeJSON = previousJSON = null;
									}
									return JSON3;
								}
							});

							root.JSON = {
								"parse": JSON3.parse,
								"stringify": JSON3.stringify
							};
						}

						// Export for asynchronous module loaders.
						if (isLoader) {
							define(function () {
								return JSON3;
							});
						}
					}).call(this);
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, {}], 51: [function (_dereq_, module, exports) {
				module.exports = toArray;

				function toArray(list, index) {
					var array = [];

					index = index || 0;

					for (var i = index || 0; i < list.length; i++) {
						array[i - index] = list[i];
					}

					return array;
				}
			}, {}] }, {}, [31])(31);
	});
}

cc._RF.pop();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},["socket-io","AnysdkMgr","AudioMgr","GameNetMgr","Global","HTTP","HotUpdate","MahjongMgr","Net","ReplayMgr","UserMgr","Utils","VoiceMgr","Alert","Chat","CheckBox","CreateRole","CreateRoom","DingQue","Folds","GameOver","GameResult","Hall","History","HuanSanZhang","ImageLoader","JoinGameInput","LoadingLogic","Login","MJGame","MJRoom","NoticeTip","OnBack","PengGangs","PopupMgr","RadioButton","RadioGroupMgr","ReConnect","ReplayCtrl","Seat","Settings","TimePointer","UserInfoShow","Voice","WaitingConnection"])

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0cy9zY3JpcHRzL2NvbXBvbmVudHMvQWxlcnQuanMiLCJhc3NldHMvc2NyaXB0cy9BbnlzZGtNZ3IuanMiLCJhc3NldHMvc2NyaXB0cy9BdWRpb01nci5qcyIsImFzc2V0cy9zY3JpcHRzL2NvbXBvbmVudHMvQ2hhdC5qcyIsImFzc2V0cy9zY3JpcHRzL2NvbXBvbmVudHMvQ2hlY2tCb3guanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL0NyZWF0ZVJvbGUuanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL0NyZWF0ZVJvb20uanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL0RpbmdRdWUuanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL0ZvbGRzLmpzIiwiYXNzZXRzL3NjcmlwdHMvR2FtZU5ldE1nci5qcyIsImFzc2V0cy9zY3JpcHRzL2NvbXBvbmVudHMvR2FtZU92ZXIuanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL0dhbWVSZXN1bHQuanMiLCJhc3NldHMvc2NyaXB0cy9HbG9iYWwuanMiLCJhc3NldHMvc2NyaXB0cy9IVFRQLmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9IYWxsLmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9IaXN0b3J5LmpzIiwiYXNzZXRzL3NjcmlwdHMvSG90VXBkYXRlLmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9IdWFuU2FuWmhhbmcuanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL0ltYWdlTG9hZGVyLmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9Kb2luR2FtZUlucHV0LmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9Mb2FkaW5nTG9naWMuanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL0xvZ2luLmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9NSkdhbWUuanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL01KUm9vbS5qcyIsImFzc2V0cy9zY3JpcHRzL01haGpvbmdNZ3IuanMiLCJhc3NldHMvc2NyaXB0cy9OZXQuanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL05vdGljZVRpcC5qcyIsImFzc2V0cy9zY3JpcHRzL2NvbXBvbmVudHMvT25CYWNrLmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9QZW5nR2FuZ3MuanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL1BvcHVwTWdyLmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9SYWRpb0J1dHRvbi5qcyIsImFzc2V0cy9zY3JpcHRzL2NvbXBvbmVudHMvUmFkaW9Hcm91cE1nci5qcyIsImFzc2V0cy9zY3JpcHRzL2NvbXBvbmVudHMvUmVDb25uZWN0LmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9SZXBsYXlDdHJsLmpzIiwiYXNzZXRzL3NjcmlwdHMvUmVwbGF5TWdyLmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9TZWF0LmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9TZXR0aW5ncy5qcyIsImFzc2V0cy9zY3JpcHRzL2NvbXBvbmVudHMvVGltZVBvaW50ZXIuanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL1VzZXJJbmZvU2hvdy5qcyIsImFzc2V0cy9zY3JpcHRzL1VzZXJNZ3IuanMiLCJhc3NldHMvc2NyaXB0cy9VdGlscy5qcyIsImFzc2V0cy9zY3JpcHRzL1ZvaWNlTWdyLmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9Wb2ljZS5qcyIsImFzc2V0cy9zY3JpcHRzL2NvbXBvbmVudHMvV2FpdGluZ0Nvbm5lY3Rpb24uanMiLCJhc3NldHMvc2NyaXB0cy8zcmRwYXJ0eS9zb2NrZXQtaW8uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhCUTs7QUFtQlo7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNJO0FBQ0g7QUFDSjtBQUNEO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUVHO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTs7QUFFQTtBQTVFSzs7Ozs7Ozs7OztBQ0FUO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWFE7O0FBY1o7QUFDQTs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNUOztBQUVTO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBQ0Q7QUFDSDtBQUVHO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNIO0FBQ0o7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7QUFDRDtBQUNIO0FBbEhJOzs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQWRROztBQWlCWjtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0g7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7OztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUNEO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDtBQWpHSTs7Ozs7Ozs7OztBQ0FUO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBaEJROztBQW1CWjtBQUNBO0FBQ0k7QUFDSTtBQUNIOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7OztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUVHO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNIOztBQWpHSTs7Ozs7Ozs7OztBQ0FUO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJROztBQWdCWjtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUNKOztBQUlEO0FBQ0E7O0FBRUE7QUE1Q0s7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFEUTs7QUFhWjtBQUNJOztBQW9CQTtBQVdBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7QUFDRDtBQUNBOztBQUVBO0FBM0VLOzs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJROztBQW1CWjtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUNKO0FBRUc7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBR0Q7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZPOztBQWFYO0FBQ0k7QUFDQTtBQUNBO0FBSE87QUFLWDtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBL01LOzs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBSlE7O0FBZ0JaO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEOztBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBekxLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWUTs7QUFhWjtBQUNBO0FBQ0k7QUFDSTtBQUNIOztBQUVEO0FBQ0E7O0FBRUE7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDs7QUFFQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUF2SEk7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQlE7O0FBNEJaO0FBQ0k7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7OztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNEO0FBQ0k7QUFEUTtBQUdaO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0Q7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUVHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNHO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFFRztBQUNJO0FBQ0E7QUFDSDtBQUVHO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNEO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNMO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDSDs7QUFHRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFFRztBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7QUFDRDtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNJOztBQUVBO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNEO0FBQ0g7QUFDRDtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7QUFDSjtBQUNEO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUZPO0FBSVg7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFKSztBQU1UO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFQTtBQTNvQks7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQlE7O0FBbUJaO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFFRztBQUNIOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQXdDO0FBQThCOztBQUV0RTtBQUF1QztBQUF3QjtBQUNsRTs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDSjtBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7O0FBR0Q7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFDRDtBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUVFO0FBQ0Y7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7O0FBRUE7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIOztBQUdEO0FBQ0E7QUFDSTtBQUNIOztBQUVEOztBQUVBO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUdEO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFDRDtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDs7QUFFRDtBQUNBO0FBQ0g7QUFFRztBQUNJO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFDSjs7QUFFRDs7QUFFQTtBQUNJO0FBQ0E7QUFDSDtBQUVHO0FBQ0E7QUFDSDtBQUVHO0FBQ0E7QUFDSDtBQUVHO0FBQ0E7QUFDSDtBQUVHO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7O0FBRUE7QUFDQTtBQUNIOztBQUVEOztBQUVBO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBR0Q7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBRUc7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBRUc7QUFDSDtBQUNKO0FBRUc7QUFDSDtBQUNKO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0E7O0FBRUE7QUFobkJLOzs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYUTs7QUFjWjtBQUNBO0FBQ0k7QUFDSTtBQUNIOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQXVDO0FBQTZCO0FBQ3ZFOztBQUVEO0FBQ0k7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIO0FBNUZJOzs7Ozs7Ozs7O0FDQVQ7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQSztBQUZTOzs7Ozs7Ozs7O0FDQXRCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0c7QUFDQTtBQUNIO0FBRUc7QUFDQTtBQUNDO0FBQ0o7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSDtBQWxERztBQUhROzs7Ozs7Ozs7O0FDTnBCO0FBQ0E7QUFDQTtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiUTs7QUF5Qlo7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7O0FBRUE7QUFDSTtBQUNBO0FBQ0g7QUFFRztBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0k7QUFDSTtBQUNBO0FBRm1CO0FBSTFCOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBRm9CO0FBSTNCOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBRk87QUFJWDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFKTztBQU1YO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBRUc7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBSk87QUFNWDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIOztBQUlEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNEOztBQUVBO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFwT0k7Ozs7Ozs7Ozs7O0FDRlQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0k7QUFDQTtBQUZjO0FBSWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJROztBQXVCWjtBQUNBO0FBQ0k7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBRUc7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFDRDtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0Q7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNHO0FBQ0Y7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0o7O0FBek5JOzs7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDSTtBQUNBO0FBRlM7QUFJYjtBQUNJO0FBQ0E7QUFGUztBQUliO0FBQ0k7QUFDQTtBQUZLO0FBSVQ7QUFDSTtBQUNBO0FBRkk7QUFiQTs7QUFtQlo7QUFDSTtBQUNBO0FBRUk7QUFDSTtBQUNBO0FBQ0E7QUFDSjtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0o7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0o7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0o7QUFDSTtBQXhCUjtBQTBCQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBRUk7QUFDSTtBQUNBO0FBQ0E7QUFDSjtBQUNJO0FBQ0E7O0FBRUE7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSjtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0o7QUFDSTtBQUNBO0FBQ0E7QUFDSjtBQUNJOztBQUVBO0FBQ0E7QUFDSjtBQUNJOztBQUVBO0FBQ0E7QUFFSTtBQUNIO0FBR0c7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNKO0FBQ0k7QUFyRFI7O0FBd0RBO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUk7QUFDQTs7QUFFQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNIO0FBM0tJOzs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpROztBQWVaO0FBQ0E7QUFDSTtBQUNBOztBQUVBO0FBQ0k7QUFDSDtBQUNEOztBQUVBO0FBQ0E7QUFDSTtBQUNIOztBQUVEOztBQUVBO0FBQ0c7QUFDQTtBQUNGOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFFRztBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNJO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBSE87O0FBTVg7QUFDQTtBQUNBOztBQUVBO0FBQ0g7O0FBbEpJOzs7Ozs7Ozs7O0FDQVQ7QUFDSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEJBO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIO0FBRUc7QUFDSTtBQUNBO0FBQ0c7QUFDRjtBQUNEO0FBQ0k7QUFDQTtBQUNBO0FBSE87QUFLWDtBQUNBO0FBRUg7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVlE7O0FBYVo7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNHO0FBQ0s7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFDSjtBQUNEO0FBQ0E7O0FBRUE7QUFyREs7Ozs7Ozs7Ozs7QUMvRFQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0k7QUFDQTtBQUZDO0FBSUw7QUFMUTs7QUFpQlo7QUFDQTs7QUFJQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDSDtBQUNEO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUNEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBcEhLOzs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMUTs7QUFRWjtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFFRztBQUNBO0FBQ0g7QUFDSjtBQUNKO0FBQ0Q7QUFDSDtBQUVHO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDSjtBQUNEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBRUc7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUVHO0FBQ0g7QUFDSjtBQUNKO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7QUExTUk7Ozs7Ozs7Ozs7OztBQ0FUO0FBQ0k7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUVHO0FBQ0k7QUFDSTtBQUNIO0FBRUc7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQUNEO0FBQ0g7QUFFRztBQUNIO0FBQ0o7O0FBRUQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYUTs7QUFjWjtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUhNO0FBS1Y7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUVHO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0E7O0FBRUE7QUFsRks7Ozs7Ozs7Ozs7QUMzQlQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0k7QUFDQTtBQUZLOztBQUtUO0FBQ0k7QUFDQTtBQUZROztBQUtaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJROztBQXVCWjtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7QUFFSTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBRk87QUFJWDtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJOztBQUVBO0FBQ0E7O0FBRUE7QUFDRztBQUNBO0FBQ0Y7O0FBSUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFFRztBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFFRztBQUNIO0FBQ0o7QUFDSjtBQUVHO0FBQ0E7O0FBRUE7QUFFSTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUFFRztBQUNIOztBQUVEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFHRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7O0FBRUE7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBRUc7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDs7QUFFSTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFDSjtBQUNKOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0o7QUFDSjtBQUNEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0k7QUFDSDtBQUVHO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7QUFFRztBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ1I7QUFDUTtBQUNBO0FBQ0k7QUFDSTtBQUNoQjtBQUNnQjtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7O0FBRVQ7QUFDUTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFFRztBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNKO0FBRUc7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUNKOztBQUVEO0FBQ0E7O0FBR0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBcndCSTs7Ozs7Ozs7OztBQ0FUO0FBQ0k7O0FBRUE7QUFDSTtBQUNJO0FBQ0E7QUFGTTtBQUlWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJROztBQXVCWjtBQUNBO0FBQ0k7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSDs7QUFHRDtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDs7QUFJQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDSDs7QUFHRDtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFFRztBQUNIO0FBQ0o7O0FBR0Q7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ1I7QUFDSztBQTlSSTs7Ozs7Ozs7OztBQ0FUOztBQUVBO0FBQ0k7O0FBRUE7QUFDSTtBQUNJO0FBQ0E7QUFGTTs7QUFLVjtBQUNJO0FBQ0E7QUFGTzs7QUFLWDtBQUNJO0FBQ0E7QUFGUTs7QUFLWjtBQUNJO0FBQ0E7QUFGWTs7QUFLaEI7QUFDSTtBQUNBO0FBRlc7O0FBS2Y7QUFDSTtBQUNBO0FBRlc7O0FBS2Y7QUFDSTtBQUNBO0FBRk87O0FBS1g7QUFDSTtBQUNBO0FBRk87O0FBS1g7QUFDQTtBQUNBO0FBM0NROztBQThDWjtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNFO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBQ0Y7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0o7QUFDSjtBQUNEO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDtBQTlMSTs7Ozs7Ozs7Ozs7O0FDRlQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUNEO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFITztBQUtYO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBRUc7QUFDQTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDSjtBQUNEO0FBQ0k7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFKTztBQU1YO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNKO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JIO0FBbEtJO0FBRlM7Ozs7Ozs7Ozs7QUNKdEI7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYlE7O0FBZ0JaO0FBQ0E7QUFDSTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNHO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNIO0FBM0NJOzs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVlE7O0FBYVo7QUFDQTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0E7O0FBRUE7QUEvQks7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVFE7O0FBWVo7QUFDQTtBQUNJO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFDSjtBQUNKOztBQUVEOztBQUVJO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDSTtBQUNIO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7O0FBRUQ7QUFDSDtBQUVHO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUFFRztBQUNBO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFFRztBQUNIO0FBQ0o7QUFFRztBQUNIO0FBQ0o7QUFDSjs7QUFsTEk7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQWhCUTs7QUFtQlo7QUFDQTtBQUNJO0FBQ0k7QUFDSDs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0o7QUFDRDtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0g7QUFDSjtBQTlJSTs7Ozs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkUTs7QUFpQlo7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNBOztBQUVBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNJO0FBQ0k7QUFDSDtBQUNKO0FBaEVJOzs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVlE7O0FBYVo7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNHO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0E7O0FBRUE7QUFqRUs7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiUTs7QUFnQlo7QUFDQTtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0c7QUFDSztBQUNKO0FBRUc7QUFDSDtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNKO0FBckRJOzs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpROztBQWVaO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFyREk7Ozs7Ozs7Ozs7QUNBVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaUTs7QUFlWjtBQUNBOztBQUlBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFDSjtBQUNEO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBRUc7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFFRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFFRztBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0E7O0FBRUE7QUFuR0s7Ozs7Ozs7Ozs7QUNQVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJCUTs7QUF3Qlo7QUFDQTtBQUNJO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFHRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNIOztBQUVEOztBQUVBO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNHO0FBQ0M7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFDRDtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNEOztBQUVBO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSDs7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDSjtBQUNKO0FBek9JOzs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkUTs7QUFpQlo7QUFDQTtBQUNJO0FBQ0k7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDs7QUFFSTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0E7QUFDQTtBQUNIO0FBRUc7QUFDQTtBQUNIO0FBRUc7QUFDQTtBQUNIO0FBRUc7QUFDQTtBQUNIO0FBRUc7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTs7QUFFQTtBQXZISzs7Ozs7Ozs7OztBQ0FUO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTFE7O0FBaUJaO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNIO0FBQ0o7QUE3RUk7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhROztBQWNaO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBNURLOzs7Ozs7Ozs7O0FDQVQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNNO0FBQ0E7QUFDQTs7QUFFQTtBQWJROztBQWdCWjtBQUNJO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFFRztBQUNJO0FBQ0E7QUFDSDtBQUVHO0FBQ0E7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUztBQUNBO0FBQ0E7QUFDVDtBQUNNO0FBQ0o7QUFDSjtBQUNEO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFITztBQUtYO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNJO0FBQ0k7QUFDSDtBQUNKO0FBRUc7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNKO0FBRUc7QUFDSTtBQUNIO0FBQ0Q7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBSE87QUFLWDtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFFRztBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBRk87QUFJWDtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBRUc7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFITztBQUtYO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBRUc7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUpPO0FBTVg7QUFDSDtBQTFMSTs7Ozs7Ozs7OztBQ0FUO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZROztBQWFaO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0g7O0FBbkNJOzs7Ozs7Ozs7O0FDQVQ7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDs7QUFFRDtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDRDtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaUTs7QUFlWjtBQUNBO0FBQ0k7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTtBQUNJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBR0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFHSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBSUc7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNKO0FBQ0Q7QUFDSDs7QUFFRDtBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFFRztBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7QUE5TEk7Ozs7Ozs7Ozs7QUN6RVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQlE7O0FBb0JaO0FBQ0E7O0FBRUk7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUVHO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUVHO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7QUF6SEk7Ozs7Ozs7Ozs7QUNBVDtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaUTs7QUFlWjtBQUNBO0FBQ0k7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNIO0FBQ0o7QUFDRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFqREk7Ozs7Ozs7Ozs7Ozs7QUNBVDtBQUNDO0FBQWE7QUFBMkQ7QUFBbUI7QUFBZ0Q7QUFBYTtBQUFLO0FBQXNDO0FBQVM7QUFBcUM7QUFBUztBQUFtQztBQUFPO0FBQUs7QUFBTztBQUFXO0FBQUM7QUFBYTtBQUFvRDtBQUFnQjtBQUFVO0FBQVU7QUFBc0s7QUFBMkQ7QUFBaUM7QUFBc0I7QUFBb0I7QUFBcUU7QUFBM0I7QUFBNEM7O0FBRW55QjtBQUVDOztBQUVEOztBQUVBOzs7Ozs7QUFNQTtBQUVDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7Ozs7O0FBUUE7QUFDRTs7QUFFQTs7QUFFQTtBQUNEO0FBQ0E7QUFDRTs7QUFFRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7O0FBRUQ7O0FBR0E7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRDtBQUNFOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7O0FBRUQ7QUFDRDs7QUFFRDs7QUFFQTs7OztBQUlBOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkJzQzs7QUEwQnJDO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7QUFDRDtBQUNEOztBQUVEOzs7OztBQUtBO0FBQ0U7QUFDQTtBQUNEO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0Q7QUFDRTtBQUNGO0FBQ0U7QUFDRDs7QUFFQTtBQUNBO0FBQ0Q7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNBOztBQUVBO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUVEO0FBQ0U7QUFFRjtBQUNFO0FBRUY7QUFDRTtBQUVGO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUFBO0FBQUE7O0FBSUE7O0FBRUE7QUFDRDtBQUNFO0FBQ0E7QUFDRDtBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNDOztBQUVEO0FBQ0Q7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTs7QUFFRDtBQUNEO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEO0FBQ0U7QUFDQTtBQUNEO0FBQ0M7O0FBRUQ7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUVEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNFO0FBQ0Q7QUFDQztBQUNGOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0Q7QUFDQTs7QUFFQztBQUNEO0FBQ0E7QUFDQTs7QUFFQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVDO0FBQ0Q7QUFDQTtBQUNBO0FBbkJEO0FBcUJFO0FBQ0Y7QUFDRTtBQUNGOztBQUVEOzs7Ozs7O0FBT0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNBO0FBQ0Q7QUFDRTtBQUNGOztBQUVEOzs7Ozs7QUFNQTtBQUNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Q7QUFDRTtBQUNGO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQTtBQUVFO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQVVBO0FBQ0U7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDRDtBQUNFOztBQUVEO0FBQ0E7O0FBRUE7QUFDRDtBQUNBO0FBQ0E7QUFIYztBQUtiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDRDs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7QUFDRDtBQUNDO0FBQ0Y7QUFDQztBQUNEO0FBQ0M7QUFDRDtBQUNDOztBQUVEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7O0FBRUQ7QUFDRDtBQUNBO0FBQ0E7QUFDRTs7QUFFRDtBQUNEO0FBQ0E7QUFDQTtBQUNFOztBQUVEO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNFO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7QUFDRDtBQUVBO0FBQ0E7QUFDRDs7OztBQUlBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRDs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7OztBQVFBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDRDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDRDtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0E7QUFDQTtBQUNEOztBQUVEOzs7Ozs7O0FBT0E7QUFDRTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7QUFJQTtBQUNFO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNEO0FBRUE7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBOzs7Ozs7O0FBT0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNEO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUVBO0FBQ0E7QUFDRDs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNFOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Q7QUFDRTs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7QUFDQztBQUNGOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7O0FBTUE7QUFDRTtBQUNEO0FBQ0E7QUFDRTs7QUFFRDtBQUNEO0FBQ0E7QUFDQTtBQUNFOztBQUVEO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTs7QUFFQTtBQUNEO0FBQ0E7QUFDRTs7QUFFRDtBQUNBO0FBQ0E7QUFDRDtBQUNFOztBQUVEO0FBQ0E7QUFDRDtBQUNFO0FBRUY7QUFDRTtBQUNEOztBQUVBOztBQUVBO0FBQ0Q7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNDO0FBQ0Y7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTs7QUFFQTtBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTs7QUFFRDs7QUFFQTtBQUNEO0FBQ0E7QUFDRTs7QUFFRDtBQUNEO0FBQ0U7QUFDRDtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVEO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7QUFFQTtBQUNBO0FBQ0U7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRDtBQUNFOztBQUVEO0FBQ0Q7QUFDRTtBQUNEO0FBQ0U7QUFDRjtBQUNDO0FBQ0Y7QUFDRTtBQUNGO0FBRUE7QUFDQTtBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7Ozs7O0FBT0E7QUFDRTs7QUFFQTtBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0Q7O0FBRUQ7QUFFQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7QUFDRDtBQUNFO0FBQ0Q7QUFDRDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Q7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7O0FBTUE7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRDtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0E7QUFDRTtBQUNEO0FBQ0U7QUFDRjtBQUNDO0FBQ0Y7QUFDRDtBQUNFO0FBQ0E7QUFDQTtBQUNEOztBQUVEO0FBQ0U7QUFDRDtBQUNFO0FBQ0Q7QUFDQztBQUNEO0FBQ0M7QUFDRjs7QUFFRDtBQUNBO0FBQ0U7QUFDRDs7QUFFRDtBQUNFO0FBQ0Q7QUFDRTtBQUNEO0FBQ0Q7QUFDRTtBQUNGO0FBQ0M7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNDO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDRjtBQUNDO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0Q7QUFDRTs7QUFFRDtBQUNEO0FBQ0E7QUFDRTtBQUNGOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7QUFDRTtBQUNEO0FBQ0E7QUFDRDtBQUNFO0FBQ0Y7QUFDRTs7QUFFRDtBQUNEO0FBQ0U7QUFDRDtBQUNDOztBQUVEO0FBQ0Q7QUFDRTs7QUFFRDtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDRDtBQUNDO0FBQ0Q7QUFDRTtBQUNGO0FBQ0U7QUFDRDtBQUNDO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7O0FBRUQ7QUFDRDtBQUNDO0FBQ0Y7QUFDQztBQUNGO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNGO0FBQ0U7QUFDRjs7QUFFRDtBQUNFO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7QUFDRjtBQUVBO0FBQ0E7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7O0FBSUE7QUFDRTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNEO0FBQ0U7QUFDRDtBQUNEOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0U7QUFDRDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTs7QUFFQTs7QUFFQTtBQUNEO0FBQ0E7QUFDQTtBQUNFOztBQUVEO0FBQ0Q7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRjs7QUFFRDtBQUNFO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDRTtBQUNGO0FBQ0M7QUFDRjtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRDs7QUFFRDtBQUNBO0FBQ0U7QUFDQTtBQUNEOztBQUVEO0FBQ0E7QUFDRTs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNEO0FBQ0M7QUFDRDtBQUNDO0FBQ0Y7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7O0FBRUE7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDRDtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNEO0FBQ0U7O0FBRUQ7QUFDRDtBQUNFOztBQUVEOztBQUVBO0FBQ0E7QUFFRDtBQUNFOztBQUVEO0FBQ0E7QUFDRDtBQUNFOztBQUVEO0FBQ0E7QUFDRDtBQUVBO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0U7QUFDRDtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNEO0FBQ0U7QUFDRDtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7O0FBTUE7QUFDRTtBQUNEO0FBQ0E7QUFDRTs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFGWTs7QUFLWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFOztBQUVEOztBQUVBO0FBQ0Q7QUFDRTs7QUFFRDtBQUNEO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7O0FBRUQ7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTs7QUFFQTtBQUNEO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7OztBQU9BO0FBRUU7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNDO0FBQ0Y7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNFOztBQUVEO0FBQ0Q7QUFDQTtBQUNFO0FBQ0Q7QUFDQztBQUNGOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDQztBQUNEOztBQUVEO0FBQ0U7QUFDRjtBQUNDOztBQUVEO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNEO0FBQ0M7QUFDRjs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7QUFDRTtBQUNGOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUQ7QUFDRTs7QUFFRDtBQUNBO0FBQ0Q7QUFDRTs7QUFFRDtBQUNBO0FBQ0Q7QUFDRTs7QUFFRDs7QUFFQTtBQUNBO0FBQ0Q7QUFDRTs7QUFFRDtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0Q7QUFFQTtBQUNBO0FBQ0Q7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNEO0FBQ0U7QUFDRDtBQUNDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7O0FBRUQ7QUFDRDtBQUNFO0FBQ0Q7QUFDQztBQUNGO0FBRUE7QUFDRDs7QUFFQTtBQUNDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNDO0FBQ0M7QUFDQTtBQUNEOztBQUVBO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQ7QUFFQztBQUNEOzs7Ozs7O0FBT0E7QUFDRTtBQUNBO0FBQ0E7O0FBRUE7QUFBeUI7QUFBdUM7O0FBRWhFO0FBQWlCO0FBQWlCO0FBQ2xDO0FBQWU7QUFBZTtBQUM5QjtBQUFtQjtBQUFjOztBQUVqQztBQUNEO0FBQ0U7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0Q7QUFFQTtBQUNEOzs7Ozs7O0FBT0E7QUFDRTs7QUFFQTtBQUNEO0FBQUE7QUFBQTtBQUFBOztBQUdBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDtBQUNFO0FBQ0Q7QUFDQztBQUNEOztBQUVEO0FBQ0U7O0FBRUQ7QUFDRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUlBO0FBQ0U7QUFDQTtBQUNEO0FBQ0U7QUFDRjs7QUFFRDtBQUFBOztBQUdBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNGO0FBRUE7QUFDRDtBQUNBOzs7O0FBSUE7O0FBS0E7Ozs7QUFJQTtBQUNFO0FBQ0Q7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVEOzs7OztBQUtBO0FBQ0U7QUFDRDtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7QUFJQTs7QUFJQTs7Ozs7O0FBTUE7QUFDRTtBQUNEO0FBQ0E7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDRTs7QUFFRDtBQUNEO0FBQ0M7QUFDRjs7QUFFRDtBQUNFOztBQUVBO0FBQ0E7O0FBRUE7QUFDRDtBQUNFOztBQUVEO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNEO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBRUE7QUFDQTs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNEO0FBQ0U7QUFDRDtBQUNEOztBQUVEOzs7Ozs7Ozs7QUFTQTtBQUVFO0FBQ0E7QUFFQTtBQUNEOztBQUVEOzs7Ozs7Ozs7O0FBVUE7QUFDRTtBQUNBOztBQUVBO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDQTtBQUNEOztBQUVEOzs7Ozs7Ozs7O0FBVUE7QUFJRTs7QUFFQTtBQUNBO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDRTtBQUNBO0FBQ0Q7QUFDQztBQUNEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQUE7O0FBR0E7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNDOztBQUVEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNEO0FBRUE7O0FBRUQ7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7O0FBRUQ7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtBOzs7O0FBSUE7O0FBU0E7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQ0Q7QUFDQztBQUNEO0FBQ0E7QUFDQztBQUNEOztBQUVEOzs7O0FBSUE7QUFDRTtBQUNEOztBQUdEOzs7Ozs7QUFNQTtBQUNFO0FBQ0E7O0FBRUE7O0FBT0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNDOztBQUVEO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNBO0FBR0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7QUFDRDtBQUNDO0FBQ0Y7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7QUFDRDs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7Ozs7OztBQVdBO0FBQ0U7QUFDRDtBQUNFO0FBQ0Y7QUFFQTs7QUFFRDs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0U7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQTs7QUFFRTtBQUNBO0FBRUE7O0FBRUE7QUFDQTs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNEOztBQUVEO0FBQ0U7QUFDRDtBQUNEO0FBQ0E7QUFDRTtBQUNEOztBQUVBOztBQUVBOztBQUVBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNDO0FBQ0Q7QUFDQztBQUNGOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7QUFDRDtBQUNEO0FBQ0U7QUFDRDtBQUNDO0FBQ0Q7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNFO0FBQ0E7QUFDRDtBQUVBO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQU9BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTtBQUNDO0FBRCtCO0FBQUE7QUFJNUI7QUFDQTtBQUNBO0FBQ0E7QUFQNEI7O0FBVWhDOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUNFO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0Q7QUFDQTtBQUNFOztBQUVEOztBQUlBO0FBQ0Q7QUFDRTtBQUNGO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEO0FBQ0U7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Q7QUFDRTs7QUFFRDtBQUVEOztBQUVEO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7QUFJQTtBQUNFO0FBQ0Q7QUFDRTs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNEO0FBQ0U7O0FBRUQ7QUFDRDs7QUFFRDtBQUNFO0FBQ0Q7QUFDRTs7QUFFRDtBQUNBO0FBQ0Q7QUFDQTtBQUNFO0FBQ0Q7QUFDRDs7QUFFRDtBQUNFO0FBQ0Q7QUFDRTs7QUFFRDtBQUNEO0FBQ0U7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDQTtBQUNEO0FBQ0Q7QUFDRTs7QUFFRDtBQUNBO0FBQ0Q7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDRDtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNEO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRDs7QUFFQTtBQUNFO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNEO0FBQ0M7QUFDRDtBQUNDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0E7QUFDRDtBQUNFOztBQUVEOztBQUVBO0FBQ0Q7QUFDRTs7QUFFRDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0U7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7O0FBRUE7QUFDRDtBQUNFO0FBQ0Q7O0FBRUQ7QUFDRTs7QUFFRDtBQUNEO0FBQ0U7O0FBRUQ7QUFDRDtBQUNFOztBQUVEO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7O0FBRUQ7QUFDRDtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7QUFJQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRDtBQUNFO0FBQ0E7QUFDRDtBQUNDOztBQUVEO0FBQ0Q7QUFDRTtBQUNGOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0U7QUFDRDtBQUNFOztBQUVEO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFBQTtBQUFBOztBQUdBO0FBQ0Q7O0FBRUE7QUFDRTtBQUNEO0FBQ0M7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7O0FBRUE7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDRDs7QUFFQTtBQUNFO0FBQ0E7QUFDRDs7QUFFRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Q7QUFDQzs7QUFFRDtBQUNEO0FBQ0E7QUFDRTtBQUVGOztBQUVEOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0U7QUFDRDtBQUNFOztBQUVEO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7O0FBRUQ7QUFDRDtBQUNFO0FBQ0E7QUFDRDtBQUNFO0FBQ0Y7QUFDRTtBQUNEO0FBQ0Q7O0FBRUQ7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDRTtBQUNEO0FBQ0Q7QUFDRTs7QUFFRDtBQUFnQjtBQUNqQjtBQUNFO0FBQVE7QUFDVjtBQUNFOztBQUVEO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7O0FBRUE7QUFDQTtBQUNEO0FBQ0U7QUFDRjs7QUFFRDtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7QUFJQTtBQUNFO0FBQ0Q7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0E7QUFDRTs7QUFFRDs7QUFJQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7O0FBRUE7QUFDRDtBQUNBO0FBQ0U7QUFDRjtBQUNDOztBQUVEO0FBQ0Q7QUFDRTtBQUNGOztBQUVEOzs7Ozs7Ozs7QUFTQTtBQUNFO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0Q7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRDtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0M7QUFDRjs7QUFFRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEO0FBQ0U7QUFDRjtBQUVBO0FBQ0E7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRDtBQUNFO0FBQ0Q7QUFDQztBQUNEO0FBQ0Q7QUFFQTtBQUNEOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7O0FBRUU7QUFDRDs7QUFFQTtBQUtFO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNDO0FBQ0M7QUFDQTtBQUNEO0FBQ0Y7QUFDQztBQUNEO0FBQ0U7O0FBRUQ7QUFDRDtBQUNFO0FBQ0Q7QUFDQztBQUNGOztBQUVEO0FBQ0U7O0FBRUQ7QUFDRDtBQUVBO0FBQ0E7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUVEO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFFQTs7QUFFRDs7QUFFQTtBQUNFO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7QUFDRDtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBRUE7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNFO0FBQ0E7QUFDQTtBQUdEOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQWxDRDtBQW9DRDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNFO0FBS0Q7O0FBRUQ7Ozs7QUFJQTtBQUNFO0FBQ0E7QUFDQTtBQUNEO0FBRUE7QUFDRDtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDRDtBQUNFOztBQUVEOztBQUVBO0FBQ0E7QUFDRDtBQUNFOztBQUVEO0FBR0Q7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNEOzs7Ozs7OztBQVFBO0FBQ0U7O0FBRUE7QUFDRDtBQUNFO0FBQ0E7QUFDRDtBQUNDOztBQUVEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDRTtBQUNEO0FBQ0Q7QUFFQTtBQUNEOzs7Ozs7O0FBT0E7O0FBRUE7O0FBSUE7QUFDQztBQUFBO0FBQUE7O0FBSUE7QUFDQztBQUNBOztBQUVEO0FBQUE7QUFBQTs7QUFJQTtBQUNDO0FBQ0E7O0FBRUQ7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVEO0FBQ0E7QUFFQTtBQUNEO0FBQ0E7QUFDQTs7QUFFQztBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQztBQUNBOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQztBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQWtDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Q7QUFDRDtBQUNBOztBQUVEO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0M7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNEO0FBQ0E7O0FBRUQ7QUFDQztBQUNDO0FBSUE7QUFDRDtBQUNEOztBQUVBO0FBQ0M7QUFDQTs7QUFFRDtBQUNDO0FBQXFDO0FBQ3BDO0FBQ0E7QUFDRDtBQUNBO0FBQXFDO0FBQ3BDO0FBQ0E7QUFDeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7O0FBRUQ7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDRDtBQUNBOztBQUVEOztBQUVBO0FBQ0M7QUFDQztBQUNBOztBQUVEO0FBQ0E7O0FBRUE7QUFDQztBQUNBOztBQUVEO0FBQ0E7QUFDQTs7QUFFRDtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQztBQUNBOztBQUVEO0FBQ0M7QUFDQTs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNDO0FBQ0E7O0FBRUQ7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEOztBQUVEO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0M7QUFDQTtBQUNEOztBQUVEO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQztBQUNBO0FBQ0Q7QUFDQTs7QUFFRDs7QUFFQTtBQUNDO0FBQ0E7QUFDQTtBQUhVOztBQU1YO0FBQ0E7QUFDQTtBQUtDO0FBQ0M7QUFDQTtBQUNEO0FBQ0E7QUFBa0I7QUFDakI7QUFDQTtBQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0M7QUFDQTtBQUNEO0FBQ0Q7QUFBUTtBQUNSO0FBQ0E7QUFFRDtBQUVBO0FBQ0E7QUFDRDs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBT0E7Ozs7Ozs7QUFPQTtBQUNFOztBQUVBO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFOztBQUVBO0FBQ0Q7QUFDRTs7QUFFRDtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFOztBQUVBO0FBQ0E7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUF3QjtBQUF4QjtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQzs7QUFFRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0U7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBOztBQUVBO0FBQ0Q7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNBO0FBQ0Q7QUFDRDtBQUNFOztBQUVEO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BOztBQUVBOzs7Ozs7O0FBT0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFFQzs7QUFFRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQ0Q7QUFDQTtBQUNFO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFINEI7QUFLM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7QUFDQztBQUNGOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7QUFDRjs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7OztBQVFBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNEOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRjs7QUFHRDs7Ozs7Ozs7QUFRQTtBQUVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNDO0FBQ0E7QUFDRDtBQUNDOztBQUVEO0FBQ0E7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNEO0FBQ0U7QUFIWTtBQUtiOztBQUVEO0FBQ0E7O0FBRUE7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNEOztBQUVEO0FBQ0U7QUFDQTtBQUNEO0FBQ0M7O0FBRUQ7QUFDRDtBQUNFO0FBQ0Q7QUFDQzs7QUFFRDtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNEOztBQUVEOzs7Ozs7O0FBT0E7QUFDRTtBQUNBOztBQUVBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNFO0FBQ0Q7QUFDQTtBQUNEO0FBQ0M7QUFBUTtBQUNWO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDRDtBQUNBO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7O0FBTUE7QUFDRTs7QUFFQTtBQUNBO0FBQWdDO0FBQWhDO0FBR0E7QUFDQTs7QUFFQTtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNEO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7O0FBTUE7QUFDRTs7QUFFQTs7QUFFQTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNEO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNDO0FBQ0E7QUFDRDtBQUNDO0FBQ0Y7O0FBRUQ7QUFDRTtBQUNEO0FBQ0U7QUFIWTtBQUtiO0FBQ0Y7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBRUE7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDRTtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBSE87QUFLUjtBQUVBOztBQUVEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiVzs7QUFnQmI7Ozs7QUFJQTs7QUFFQTs7Ozs7O0FBTUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0U7O0FBRUE7QUFDQTtBQUtEOztBQUVEOzs7Ozs7QUFNQTtBQUVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7Ozs7O0FBU0E7QUFDRTtBQUNEO0FBQ0E7QUFDRTs7QUFFRDtBQUNBO0FBQ0E7QUFBb0I7QUFBbUM7QUFDdkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7O0FBRUQ7QUFDRDtBQUNFO0FBQ0Y7QUFDRTs7QUFFRDs7QUFFQTtBQUNEOztBQUVEOzs7Ozs7O0FBT0E7QUFDRTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7O0FBRUE7QUFDQTtBQUNEO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEOztBQUVEOzs7Ozs7O0FBT0E7QUFDRTs7QUFFQTtBQUNEO0FBQ0U7QUFDQTs7QUFFRjtBQUNFO0FBQ0E7O0FBRUY7QUFDRTtBQUNBOztBQUVGO0FBQ0U7QUFDQTs7QUFFRjtBQUNFO0FBQ0E7O0FBRUY7QUFDRTtBQUNBOztBQUVGO0FBQ0U7QUFDQTtBQTNCRDtBQTZCRDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTs7QUFFQTtBQUNEO0FBQ0E7QUFDRTs7QUFFRDtBQUNEO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBSFU7QUFLVjtBQUNGOztBQUVEOzs7Ozs7O0FBT0E7QUFDRTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNBO0FBQ0Q7QUFDRTtBQUNEOztBQUVBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNEO0FBQ0E7QUFDRTtBQUNEO0FBQ0Q7QUFDRTs7QUFFRDtBQUNEOztBQUVEOzs7Ozs7O0FBT0E7QUFFRTtBQUNEO0FBQ0E7QUFDRTs7QUFFRDtBQUNBOztBQUVBO0FBQ0Q7QUFDQTtBQUNFO0FBQ0Q7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNFO0FBQ0E7QUFDQTtBQUNEO0FBRUE7QUFDRDs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNEO0FBQ0U7QUFDRDtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVEO0FBQ0U7QUFDQTtBQUNEO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEO0FBQ0U7QUFDRDtBQUVDO0FBQ0Q7QUFDQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Q7QUFFQTtBQUNBOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDRDtBQUdBO0FBQ0Q7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDRjtBQUVBOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0U7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNFO0FBQ0Q7QUFDRTtBQUNEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBO0FBRUU7QUFDQTtBQUVBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQTtBQUNFO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDQTtBQUNEOztBQUVEOzs7Ozs7Ozs7O0FBVUE7QUFJRTs7QUFFQTtBQUNBO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDRTtBQUNBO0FBQ0Q7QUFDQztBQUNEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQUE7O0FBR0E7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNDOztBQUVEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNEO0FBRUE7QUFDRDtBQUNDO0FBQ0Q7QUFDQztBQUNEOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7O0FBRUU7QUFDRDs7QUFFQTtBQUtFO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNDO0FBQ0M7QUFDQTtBQUNEO0FBQ0Y7QUFDQztBQUNBO0FBQ0Q7QUFDRTs7QUFFRDtBQUNEO0FBQ0U7QUFDRDtBQUNDO0FBQ0Y7O0FBRUQ7QUFDRTs7QUFFRDtBQUNEO0FBRUE7QUFDQTtBQUNEO0FBQ0M7QUFDRDtBQUNDO0FBQ0Q7QUFDQztBQUNEO0FBQ0M7QUFDRDtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTs7Ozs7Ozs7OztBQVVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNEOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0Q7QUFDQztBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0Q7QUFDRDtBQUNFOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBO0FBQ0U7O0FBRUE7QUFDRDtBQUNFO0FBQ0E7QUFDRDtBQUNDO0FBQ0Q7QUFDRTtBQUNEO0FBQ0Q7QUFDQztBQUNEO0FBQ0U7QUFDRDtBQUNEO0FBQ0Q7QUFDRTs7QUFFRDtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQVVBO0FBQ0U7QUFDRDs7QUFFQTtBQUNBO0FBRUU7O0FBRUE7QUFDQTtBQUNBO0FBQWlDO0FBQ2xDO0FBQ0U7QUFDRDtBQUVDO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNFO0FBQ0Q7QUFDQzs7QUFFRDtBQUNEO0FBQTBCO0FBQ3pCO0FBQ0Q7QUFDRTtBQUNGO0FBQTBEO0FBQ3pEO0FBQ0Q7QUFDRTtBQUNGO0FBQ0M7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0Y7QUFFQTtBQUNBOztBQUVEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBVUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7Ozs7O0FBVUE7QUFDRTs7QUFFQTtBQUNEO0FBQ0U7QUFFRjtBQUNBO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDRTs7QUFFRDtBQUNBO0FBQ0Q7QUFDRTtBQUNBO0FBQ0Q7QUFDRDtBQUNFOztBQUVEO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEOztBQUVEOzs7Ozs7Ozs7O0FBVUE7O0FBRUU7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFOztBQUVEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0Q7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNFO0FBQ0E7QUFDRDtBQUNBO0FBQWdGO0FBQzlFOztBQUVBO0FBQ0E7QUFDRDtBQUNFO0FBQ0Y7QUFBUTtBQUNQO0FBQ0Q7QUFDQztBQUNvQztBQUN0QztBQUNFO0FBQ0Q7QUFDQztBQUNBO0FBQWM7QUFDZjtBQUNBO0FBQ0U7QUFDRjtBQUNDO0FBRUY7QUFDRTtBQUNGOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNEO0FBQ0E7QUFDRTtBQUNBO0FBQ0Q7QUFDRDtBQUNFO0FBQ0Q7QUFDRDtBQUNFOztBQUVEO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNDO0FBQ0Y7QUFDRTs7QUFFRDtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDQTtBQUNEO0FBQ0E7QUFDRTtBQUNEO0FBQ0E7QUFDRDtBQUNEO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEO0FBQ0U7QUFDRDtBQUNDO0FBQ0Q7QUFDQzs7QUFFRDtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDRDtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQTtBQUNFO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQVVBO0FBQ0U7QUFDQTtBQUF5RDtBQUMxRDtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNEOztBQUVEO0FBQ0U7QUFDRDtBQUNBO0FBRlE7QUFJUjtBQUVBO0FBQ0Q7O0FBRUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0U7QUFFRDtBQUVBO0FBQ0E7QUFDRDtBQUNDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRDtBQUNBO0FBRm1COztBQUtsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFHQTtBQUNEO0FBQ0U7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBU0E7QUFDQTtBQUNFO0FBQ0E7QUFDRDs7QUFFRDtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBSUE7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFRDtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0E7QUFDRTtBQUNEO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFBQTtBQUNBO0FBQ0E7QUFDRTtBQUFBO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0M7QUFDRDtBQUNDO0FBQ0Q7QUFDRDtBQUNEO0FBQ0E7QUFDRTtBQUNBO0FBQ0Q7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNDO0FBQ0Q7QUFDRDtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNGO0FBQ0M7QUFDRjtBQUNDO0FBQ0Q7QUFDQztBQUNEO0FBQ0Q7QUFDQztBQUNEO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFPQTtBQUNBOztBQUVBO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Q7QUFDQzs7QUFFRDtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQUE7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUhvRDtBQUtwRDtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Q7QUFDQztBQUNEO0FBQ0E7QUFDRDtBQUNDOztBQUVEO0FBQ0E7QUFDQTtBQUNEO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Q7QUFDRTtBQUNGO0FBQ0Q7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNGO0FBQ0Q7QUFDQTtBQUNFO0FBQ0Y7QUFDQztBQUNBO0FBQ0Q7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNGO0FBQ0M7QUFDRjtBQUNDO0FBQ0E7QUFDRDtBQUFBO0FBQUE7QUFDQTtBQUNFO0FBQ0Q7QUFDRTtBQUNGO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNDO0FBQ0Y7QUFDRDtBQUNFOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUFk7O0FBVWQ7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Q7QUFDQTtBQUNDO0FBQ0Q7QUFDRTtBQUNBO0FBQ0Q7QUFDRDtBQVREO0FBV0U7QUFDRDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0E7QUFDRTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFDQTtBQUVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRjtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNDO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0Q7QUFDRTtBQUNEO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNEO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0E7QUFDRTtBQUNGO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Q7QUFDQTtBQUNFO0FBQ0Q7QUFDRDtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNEO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVEO0FBQ0E7QUFDRTtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNEO0FBQ0Q7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0Y7QUFDQztBQUNEO0FBQ0M7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0M7O0FBRUQ7QUFDQTtBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSYzs7QUFXaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNEO0FBQ0E7QUFDRTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0M7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0M7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDRTtBQUNGO0FBQ0Q7QUFDQTtBQUNBO0FBQ0M7QUFDRDtBQUNBO0FBekJEO0FBMkJFO0FBQ0Y7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0E7QUFDRTtBQUNGO0FBQ0Q7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNEO0FBQ0E7QUFDQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNEO0FBQ0Q7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNEO0FBQ0U7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNEO0FBQ0U7QUFDRDtBQUNBO0FBQ0Q7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0E7QUFDRTtBQUNBO0FBQ0Q7QUFDQztBQUNBO0FBQ0Q7QUFDQztBQUNBO0FBQ0Q7QUFDRDtBQUNBO0FBakpEO0FBbUpFO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDQTtBQUNEO0FBQ0Q7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNFO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Q7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNDO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDRDtBQUNEO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNFO0FBQ0Q7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNDO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Q7QUFDRDtBQUNFO0FBQ0Q7QUFDRDtBQUNEO0FBQ0E7QUFDRTtBQUNEO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFBQTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0U7QUFDRjtBQUNDO0FBQ0Q7QUFDRTtBQUNGO0FBQ0M7QUFDRDtBQUNEOztBQUVEO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNGOztBQUVEO0FBQ0E7QUFDRTs7QUFFRDtBQUNEO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFBQTtBQUFBOztBQUlBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFDRTtBQVg2Qzs7QUFjaEQ7QUFDRTtBQUNBO0FBRlU7QUFJVjs7QUFFRDtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7QUFDRjtBQUVBO0FBQ0E7QUFDRDs7QUFFQTtBQUNDOztBQUVBOztBQUVBO0FBQ0M7QUFDQTs7QUFFRDtBQUNBO0FBRUE7QUFDQTtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAvLyBmb286IHtcclxuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLCAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdXNlZCBvbmx5IHdoZW4gdGhlIGNvbXBvbmVudCBhdHRhY2hpbmdcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGEgbm9kZSBmb3IgdGhlIGZpcnN0IHRpbWVcclxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XHJcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxyXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcclxuICAgICAgICAvLyB9LFxyXG4gICAgICAgIC8vIC4uLlxyXG4gICAgICAgIF9hbGVydDpudWxsLFxyXG4gICAgICAgIF9idG5PSzpudWxsLFxyXG4gICAgICAgIF9idG5DYW5jZWw6bnVsbCxcclxuICAgICAgICBfdGl0bGU6bnVsbCxcclxuICAgICAgICBfY29udGVudDpudWxsLFxyXG4gICAgICAgIF9vbm9rOm51bGwsXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYoY2MudnYgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYWxlcnQgPSBjYy5maW5kKFwiQ2FudmFzL2FsZXJ0XCIpO1xyXG4gICAgICAgIHRoaXMuX3RpdGxlID0gY2MuZmluZChcIkNhbnZhcy9hbGVydC90aXRsZVwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjYy5maW5kKFwiQ2FudmFzL2FsZXJ0L2NvbnRlbnRcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9idG5PSyA9IGNjLmZpbmQoXCJDYW52YXMvYWxlcnQvYnRuX29rXCIpO1xyXG4gICAgICAgIHRoaXMuX2J0bkNhbmNlbCA9IGNjLmZpbmQoXCJDYW52YXMvYWxlcnQvYnRuX2NhbmNlbFwiKTtcclxuICAgICAgICBcclxuICAgICAgICBjYy52di51dGlscy5hZGRDbGlja0V2ZW50KHRoaXMuX2J0bk9LLHRoaXMubm9kZSxcIkFsZXJ0XCIsXCJvbkJ0bkNsaWNrZWRcIik7XHJcbiAgICAgICAgY2MudnYudXRpbHMuYWRkQ2xpY2tFdmVudCh0aGlzLl9idG5DYW5jZWwsdGhpcy5ub2RlLFwiQWxlcnRcIixcIm9uQnRuQ2xpY2tlZFwiKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9hbGVydC5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICBjYy52di5hbGVydCA9IHRoaXM7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbkJ0bkNsaWNrZWQ6ZnVuY3Rpb24oZXZlbnQpe1xyXG4gICAgICAgIGlmKGV2ZW50LnRhcmdldC5uYW1lID09IFwiYnRuX29rXCIpe1xyXG4gICAgICAgICAgICBpZih0aGlzLl9vbm9rKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29ub2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9hbGVydC5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9vbm9rID0gbnVsbDtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNob3c6ZnVuY3Rpb24odGl0bGUsY29udGVudCxvbm9rLG5lZWRjYW5jZWwpe1xyXG4gICAgICAgIHRoaXMuX2FsZXJ0LmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fb25vayA9IG9ub2s7XHJcbiAgICAgICAgdGhpcy5fdGl0bGUuc3RyaW5nID0gdGl0bGU7XHJcbiAgICAgICAgdGhpcy5fY29udGVudC5zdHJpbmcgPSBjb250ZW50O1xyXG4gICAgICAgIGlmKG5lZWRjYW5jZWwpe1xyXG4gICAgICAgICAgICB0aGlzLl9idG5DYW5jZWwuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fYnRuT0sueCA9IC0xNTA7XHJcbiAgICAgICAgICAgIHRoaXMuX2J0bkNhbmNlbC54ID0gMTUwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB0aGlzLl9idG5DYW5jZWwuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2J0bk9LLnggPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uRGVzdG9yeTpmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmKGNjLnZ2KXtcclxuICAgICAgICAgICAgY2MudnYuYWxlcnQgPSBudWxsOyAgICBcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCwgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQgb25seSB3aGVuIHRoZSBjb21wb25lbnQgYXR0YWNoaW5nXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIG5vZGUgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuICAgICAgICBfaXNDYXB0dXJpbmc6ZmFsc2UsXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG5cclxuICAgIC8vIH0sXHJcbiAgICBcclxuICAgIGluaXQ6ZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLkFORFJPSURfQVBJID0gXCJjb20vdml2aWdhbWVzL3NjbWovV1hBUElcIjtcclxuICAgICAgICB0aGlzLklPU19BUEkgPSBcIkFwcENvbnRyb2xsZXJcIjtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGxvZ2luOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYoY2Muc3lzLm9zID09IGNjLnN5cy5PU19BTkRST0lEKXsgXHJcbiAgICAgICAgICAgIGpzYi5yZWZsZWN0aW9uLmNhbGxTdGF0aWNNZXRob2QodGhpcy5BTkRST0lEX0FQSSwgXCJMb2dpblwiLCBcIigpVlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0lPUyl7XHJcbiAgICAgICAgICAgIGpzYi5yZWZsZWN0aW9uLmNhbGxTdGF0aWNNZXRob2QodGhpcy5JT1NfQVBJLCBcImxvZ2luXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInBsYXRmb3JtOlwiICsgY2Muc3lzLm9zICsgXCIgZG9zbid0IGltcGxlbWVudCBzaGFyZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc2hhcmU6ZnVuY3Rpb24odGl0bGUsZGVzYyl7XHJcbiAgICAgICAgaWYoY2Muc3lzLm9zID09IGNjLnN5cy5PU19BTkRST0lEKXtcclxuICAgICAgICAgICAganNiLnJlZmxlY3Rpb24uY2FsbFN0YXRpY01ldGhvZCh0aGlzLkFORFJPSURfQVBJLCBcIlNoYXJlXCIsIFwiKExqYXZhL2xhbmcvU3RyaW5nO0xqYXZhL2xhbmcvU3RyaW5nO0xqYXZhL2xhbmcvU3RyaW5nOylWXCIsY2MudnYuU0kuYXBwd2ViLHRpdGxlLGRlc2MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfSU9TKXtcclxuICAgICAgICAgICAganNiLnJlZmxlY3Rpb24uY2FsbFN0YXRpY01ldGhvZCh0aGlzLklPU19BUEksIFwic2hhcmU6c2hhcmVUaXRsZTpzaGFyZURlc2M6XCIsY2MudnYuU0kuYXBwd2ViLHRpdGxlLGRlc2MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInBsYXRmb3JtOlwiICsgY2Muc3lzLm9zICsgXCIgZG9zbid0IGltcGxlbWVudCBzaGFyZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc2hhcmVSZXN1bHQ6ZnVuY3Rpb24oKXtcclxuICAgICAgICBpZih0aGlzLl9pc0NhcHR1cmluZyl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faXNDYXB0dXJpbmcgPSB0cnVlO1xyXG4gICAgICAgIHZhciBzaXplID0gY2MuZGlyZWN0b3IuZ2V0V2luU2l6ZSgpO1xyXG4gICAgICAgIHZhciBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgdmFyIGZpbGVOYW1lID0gXCJyZXN1bHRfc2hhcmUuanBnXCI7XHJcbiAgICAgICAgdmFyIGZ1bGxQYXRoID0ganNiLmZpbGVVdGlscy5nZXRXcml0YWJsZVBhdGgoKSArIGZpbGVOYW1lO1xyXG4gICAgICAgIGlmKGpzYi5maWxlVXRpbHMuaXNGaWxlRXhpc3QoZnVsbFBhdGgpKXtcclxuICAgICAgICAgICAganNiLmZpbGVVdGlscy5yZW1vdmVGaWxlKGZ1bGxQYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSBuZXcgY2MuUmVuZGVyVGV4dHVyZShNYXRoLmZsb29yKHNpemUud2lkdGgpLCBNYXRoLmZsb29yKHNpemUuaGVpZ2h0KSk7XHJcbiAgICAgICAgdGV4dHVyZS5zZXRQb3NpdGlvbihjYy5wKHNpemUud2lkdGgvMiwgc2l6ZS5oZWlnaHQvMikpO1xyXG4gICAgICAgIHRleHR1cmUuYmVnaW4oKTtcclxuICAgICAgICBjYy5kaXJlY3Rvci5nZXRSdW5uaW5nU2NlbmUoKS52aXNpdCgpO1xyXG4gICAgICAgIHRleHR1cmUuZW5kKCk7XHJcbiAgICAgICAgdGV4dHVyZS5zYXZlVG9GaWxlKGZpbGVOYW1lLCBjYy5JTUFHRV9GT1JNQVRfSlBHKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHRyeVRpbWVzID0gMDtcclxuICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBpZihqc2IuZmlsZVV0aWxzLmlzRmlsZUV4aXN0KGZ1bGxQYXRoKSl7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gMTAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gaGVpZ2h0L3NpemUuaGVpZ2h0O1xyXG5cdFx0XHQgICAgdmFyIHdpZHRoID0gTWF0aC5mbG9vcihzaXplLndpZHRoICogc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0FORFJPSUQpe1xyXG4gICAgICAgICAgICAgICAgICAgIGpzYi5yZWZsZWN0aW9uLmNhbGxTdGF0aWNNZXRob2Qoc2VsZi5BTkRST0lEX0FQSSwgXCJTaGFyZUlNR1wiLCBcIihMamF2YS9sYW5nL1N0cmluZztJSSlWXCIsZnVsbFBhdGgsd2lkdGgsaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoY2Muc3lzLm9zID09IGNjLnN5cy5PU19JT1Mpe1xyXG4gICAgICAgICAgICAgICAgICAgIGpzYi5yZWZsZWN0aW9uLmNhbGxTdGF0aWNNZXRob2Qoc2VsZi5JT1NfQVBJLCBcInNoYXJlSU1HOndpZHRoOmhlaWdodDpcIixmdWxsUGF0aCx3aWR0aCxoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInBsYXRmb3JtOlwiICsgY2Muc3lzLm9zICsgXCIgZG9zbid0IGltcGxlbWVudCBzaGFyZS5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9pc0NhcHR1cmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICB0cnlUaW1lcysrO1xyXG4gICAgICAgICAgICAgICAgaWYodHJ5VGltZXMgPiAxMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0aW1lIG91dC4uLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZuLDUwKTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0VGltZW91dChmbiw1MCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbkxvZ2luUmVzcDpmdW5jdGlvbihjb2RlKXtcclxuICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbihyZXQpe1xyXG4gICAgICAgICAgICBpZihyZXQuZXJyY29kZSA9PSAwKXtcclxuICAgICAgICAgICAgICAgIGNjLnN5cy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInd4X2FjY291bnRcIixyZXQuYWNjb3VudCk7XHJcbiAgICAgICAgICAgICAgICBjYy5zeXMubG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ3eF9zaWduXCIscmV0LnNpZ24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNjLnZ2LnVzZXJNZ3Iub25BdXRoKHJldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNjLnZ2Lmh0dHAuc2VuZFJlcXVlc3QoXCIvd2VjaGF0X2F1dGhcIix7Y29kZTpjb2RlLG9zOmNjLnN5cy5vc30sZm4pO1xyXG4gICAgfSxcclxufSk7XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCwgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQgb25seSB3aGVuIHRoZSBjb21wb25lbnQgYXR0YWNoaW5nXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIG5vZGUgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuICAgICAgICBiZ21Wb2x1bWU6MS4wLFxyXG4gICAgICAgIHNmeFZvbHVtZToxLjAsXHJcbiAgICAgICAgXHJcbiAgICAgICAgYmdtQXVkaW9JRDotMSxcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHQgPSBjYy5zeXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJiZ21Wb2x1bWVcIik7XHJcbiAgICAgICAgaWYodCAhPSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5iZ21Wb2x1bWUgPSBwYXJzZUZsb2F0KHQpOyAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHQgPSBjYy5zeXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzZnhWb2x1bWVcIik7XHJcbiAgICAgICAgaWYodCAhPSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5zZnhWb2x1bWUgPSBwYXJzZUZsb2F0KHQpOyAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MuZ2FtZS5vbihjYy5nYW1lLkVWRU5UX0hJREUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYy5hdWRpb0VuZ2luZS5wYXVzZUFsbFwiKTtcclxuICAgICAgICAgICAgY2MuYXVkaW9FbmdpbmUucGF1c2VBbGwoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjYy5nYW1lLm9uKGNjLmdhbWUuRVZFTlRfU0hPVywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNjLmF1ZGlvRW5naW5lLnJlc3VtZUFsbFwiKTtcclxuICAgICAgICAgICAgY2MuYXVkaW9FbmdpbmUucmVzdW1lQWxsKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG5cclxuICAgIC8vIH0sXHJcbiAgICBcclxuICAgIGdldFVybDpmdW5jdGlvbih1cmwpe1xyXG4gICAgICAgIHJldHVybiBjYy51cmwucmF3KFwicmVzb3VyY2VzL3NvdW5kcy9cIiArIHVybCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBwbGF5QkdNKHVybCl7XHJcbiAgICAgICAgdmFyIGF1ZGlvVXJsID0gdGhpcy5nZXRVcmwodXJsKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhhdWRpb1VybCk7XHJcbiAgICAgICAgaWYodGhpcy5iZ21BdWRpb0lEID49IDApe1xyXG4gICAgICAgICAgICBjYy5hdWRpb0VuZ2luZS5zdG9wKHRoaXMuYmdtQXVkaW9JRCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYmdtQXVkaW9JRCA9IGNjLmF1ZGlvRW5naW5lLnBsYXkoYXVkaW9VcmwsdHJ1ZSx0aGlzLmJnbVZvbHVtZSk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBwbGF5U0ZYKHVybCl7XHJcbiAgICAgICAgdmFyIGF1ZGlvVXJsID0gdGhpcy5nZXRVcmwodXJsKTtcclxuICAgICAgICBpZih0aGlzLnNmeFZvbHVtZSA+IDApe1xyXG4gICAgICAgICAgICB2YXIgYXVkaW9JZCA9IGNjLmF1ZGlvRW5naW5lLnBsYXkoYXVkaW9VcmwsZmFsc2UsdGhpcy5zZnhWb2x1bWUpOyAgICBcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzZXRTRlhWb2x1bWU6ZnVuY3Rpb24odil7XHJcbiAgICAgICAgaWYodGhpcy5zZnhWb2x1bWUgIT0gdil7XHJcbiAgICAgICAgICAgIGNjLnN5cy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInNmeFZvbHVtZVwiLHYpO1xyXG4gICAgICAgICAgICB0aGlzLnNmeFZvbHVtZSA9IHY7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc2V0QkdNVm9sdW1lOmZ1bmN0aW9uKHYsZm9yY2Upe1xyXG4gICAgICAgIGlmKHRoaXMuYmdtQXVkaW9JRCA+PSAwKXtcclxuICAgICAgICAgICAgaWYodiA+IDApe1xyXG4gICAgICAgICAgICAgICAgY2MuYXVkaW9FbmdpbmUucmVzdW1lKHRoaXMuYmdtQXVkaW9JRCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGNjLmF1ZGlvRW5naW5lLnBhdXNlKHRoaXMuYmdtQXVkaW9JRCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9jYy5hdWRpb0VuZ2luZS5zZXRWb2x1bWUodGhpcy5iZ21BdWRpb0lELHRoaXMuYmdtVm9sdW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5iZ21Wb2x1bWUgIT0gdiB8fCBmb3JjZSl7XHJcbiAgICAgICAgICAgIGNjLnN5cy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImJnbVZvbHVtZVwiLHYpO1xyXG4gICAgICAgICAgICB0aGlzLmJnbVZvbHVtZSA9IHY7XHJcbiAgICAgICAgICAgIGNjLmF1ZGlvRW5naW5lLnNldFZvbHVtZSh0aGlzLmJnbUF1ZGlvSUQsdik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgcGF1c2VBbGw6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy5hdWRpb0VuZ2luZS5wYXVzZUFsbCgpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgcmVzdW1lQWxsOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuYXVkaW9FbmdpbmUucmVzdW1lQWxsKCk7XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIC8vIGZvbzoge1xyXG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuICAgICAgICBfY2hhdFJvb3Q6bnVsbCxcclxuICAgICAgICBfdGFiUXVpY2s6bnVsbCxcclxuICAgICAgICBfdGFiRW1vamk6bnVsbCxcclxuICAgICAgICBfaXB0Q2hhdDpudWxsLFxyXG4gICAgICAgIFxyXG4gICAgICAgIF9xdWlja0NoYXRJbmZvOm51bGwsXHJcbiAgICAgICAgX2J0bkNoYXQ6bnVsbCxcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZihjYy52diA9PSBudWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBjYy52di5jaGF0ID0gdGhpcztcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9idG5DaGF0ID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiYnRuX2NoYXRcIik7XHJcbiAgICAgICAgdGhpcy5fYnRuQ2hhdC5hY3RpdmUgPSBjYy52di5yZXBsYXlNZ3IuaXNSZXBsYXkoKSA9PSBmYWxzZTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9jaGF0Um9vdCA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImNoYXRcIik7XHJcbiAgICAgICAgdGhpcy5fY2hhdFJvb3QuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5fdGFiUXVpY2sgPSB0aGlzLl9jaGF0Um9vdC5nZXRDaGlsZEJ5TmFtZShcInF1aWNrY2hhdGxpc3RcIik7XHJcbiAgICAgICAgdGhpcy5fdGFiRW1vamkgPSB0aGlzLl9jaGF0Um9vdC5nZXRDaGlsZEJ5TmFtZShcImVtb2ppc1wiKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9pcHRDaGF0ID0gdGhpcy5fY2hhdFJvb3QuZ2V0Q2hpbGRCeU5hbWUoXCJpcHRDaGF0XCIpLmdldENvbXBvbmVudChjYy5FZGl0Qm94KTtcclxuICAgICAgICBcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9xdWlja0NoYXRJbmZvID0ge307XHJcbiAgICAgICAgdGhpcy5fcXVpY2tDaGF0SW5mb1tcIml0ZW0wXCJdID0ge2luZGV4OjAsY29udGVudDpcIuW/q+eCueWViu+8jOmDveetieWIsOaIkeiKseWEv+mDveiwouiwouS6hu+8gVwiLHNvdW5kOlwiZml4X21zZ18xLm1wM1wifTtcclxuICAgICAgICB0aGlzLl9xdWlja0NoYXRJbmZvW1wiaXRlbTFcIl0gPSB7aW5kZXg6MSxjb250ZW50Olwi5oCO5LmI5Y+I5pat57q/5LqG77yM572R57uc5oCO5LmI6L+Z5LmI5beu5ZWK77yBXCIsc291bmQ6XCJmaXhfbXNnXzIubXAzXCJ9O1xyXG4gICAgICAgIHRoaXMuX3F1aWNrQ2hhdEluZm9bXCJpdGVtMlwiXSA9IHtpbmRleDoyLGNvbnRlbnQ6XCLkuI3opoHotbDvvIzlhrPmiJjliLDlpKnkuq7vvIFcIixzb3VuZDpcImZpeF9tc2dfMy5tcDNcIn07XHJcbiAgICAgICAgdGhpcy5fcXVpY2tDaGF0SW5mb1tcIml0ZW0zXCJdID0ge2luZGV4OjMsY29udGVudDpcIuS9oOeahOeJjOaJk+W+l+S5n+WkquWlveS6hu+8gVwiLHNvdW5kOlwiZml4X21zZ180Lm1wM1wifTtcclxuICAgICAgICB0aGlzLl9xdWlja0NoYXRJbmZvW1wiaXRlbTRcIl0gPSB7aW5kZXg6NCxjb250ZW50Olwi5L2g5piv5aa55aa56L+Y5piv5ZOl5ZOl5ZWK77yfXCIsc291bmQ6XCJmaXhfbXNnXzUubXAzXCJ9O1xyXG4gICAgICAgIHRoaXMuX3F1aWNrQ2hhdEluZm9bXCJpdGVtNVwiXSA9IHtpbmRleDo1LGNvbnRlbnQ6XCLlkozkvaDlkIjkvZznnJ/mmK/lpKrmhInlv6vkuobvvIFcIixzb3VuZDpcImZpeF9tc2dfNi5tcDNcIn07XHJcbiAgICAgICAgdGhpcy5fcXVpY2tDaGF0SW5mb1tcIml0ZW02XCJdID0ge2luZGV4OjYsY29udGVudDpcIuWkp+WutuWlve+8jOW+iOmrmOWFtOingeWIsOWQhOS9je+8gVwiLHNvdW5kOlwiZml4X21zZ183Lm1wM1wifTtcclxuICAgICAgICB0aGlzLl9xdWlja0NoYXRJbmZvW1wiaXRlbTdcIl0gPSB7aW5kZXg6Nyxjb250ZW50Olwi5ZCE5L2N77yM55yf5piv5LiN5aW95oSP5oCd77yM5oiR5b6X56a75byA5LiA5Lya5YS/44CCXCIsc291bmQ6XCJmaXhfbXNnXzgubXAzXCJ9O1xyXG4gICAgICAgIHRoaXMuX3F1aWNrQ2hhdEluZm9bXCJpdGVtOFwiXSA9IHtpbmRleDo4LGNvbnRlbnQ6XCLkuI3opoHlkLXkuobvvIzkuJPlv4PnjqnmuLjmiI/lkKfvvIFcIixzb3VuZDpcImZpeF9tc2dfOS5tcDNcIn07XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBnZXRRdWlja0NoYXRJbmZvKGluZGV4KXtcclxuICAgICAgICB2YXIga2V5ID0gXCJpdGVtXCIgKyBpbmRleDtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcXVpY2tDaGF0SW5mb1trZXldOyAgIFxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25CdG5DaGF0Q2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuX2NoYXRSb290LmFjdGl2ZSA9IHRydWU7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbkJnQ2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuX2NoYXRSb290LmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25UYWJDbGlja2VkOmZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICBpZihldmVudC50YXJnZXQubmFtZSA9PSBcInRhYlF1aWNrXCIpe1xyXG4gICAgICAgICAgICB0aGlzLl90YWJRdWljay5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl90YWJFbW9qaS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihldmVudC50YXJnZXQubmFtZSA9PSBcInRhYkVtb2ppXCIpe1xyXG4gICAgICAgICAgICB0aGlzLl90YWJRdWljay5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fdGFiRW1vamkuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvblF1aWNrQ2hhdEl0ZW1DbGlja2VkOmZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICB0aGlzLl9jaGF0Um9vdC5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB2YXIgaW5mbyA9IHRoaXMuX3F1aWNrQ2hhdEluZm9bZXZlbnQudGFyZ2V0Lm5hbWVdO1xyXG4gICAgICAgIGNjLnZ2Lm5ldC5zZW5kKFwicXVpY2tfY2hhdFwiLGluZm8uaW5kZXgpOyBcclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uRW1vamlJdGVtQ2xpY2tlZDpmdW5jdGlvbihldmVudCl7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXZlbnQudGFyZ2V0Lm5hbWUpO1xyXG4gICAgICAgIHRoaXMuX2NoYXRSb290LmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIGNjLnZ2Lm5ldC5zZW5kKFwiZW1vamlcIixldmVudC50YXJnZXQubmFtZSk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbkJ0blNlbmRDaGF0Q2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuX2NoYXRSb290LmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmKHRoaXMuX2lwdENoYXQuc3RyaW5nID09IFwiXCIpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNjLnZ2Lm5ldC5zZW5kKFwiY2hhdFwiLHRoaXMuX2lwdENoYXQuc3RyaW5nKTtcclxuICAgICAgICB0aGlzLl9pcHRDaGF0LnN0cmluZyA9IFwiXCI7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG5cclxuICAgIC8vIH0sXHJcbn0pO1xyXG4iLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIC8vIGZvbzoge1xyXG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuICAgICAgICB0YXJnZXQ6Y2MuTm9kZSxcclxuICAgICAgICBzcHJpdGU6Y2MuU3ByaXRlRnJhbWUsXHJcbiAgICAgICAgY2hlY2tlZFNwcml0ZTpjYy5TcHJpdGVGcmFtZSxcclxuICAgICAgICBjaGVja2VkOmZhbHNlLFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25DbGlja2VkOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5jaGVja2VkID0gIXRoaXMuY2hlY2tlZDtcclxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHJlZnJlc2g6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgdGFyZ2V0U3ByaXRlID0gdGhpcy50YXJnZXQuZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7XHJcbiAgICAgICAgaWYodGhpcy5jaGVja2VkKXtcclxuICAgICAgICAgICAgdGFyZ2V0U3ByaXRlLnNwcml0ZUZyYW1lID0gdGhpcy5jaGVja2VkU3ByaXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB0YXJnZXRTcHJpdGUuc3ByaXRlRnJhbWUgPSB0aGlzLnNwcml0ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIFxyXG5cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG5cclxuICAgIC8vIH0sXHJcbn0pO1xyXG4iLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIGlucHV0TmFtZTpjYy5FZGl0Qm94LFxyXG4gICAgICAgIC8vIGZvbzoge1xyXG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uUmFuZG9tQnRuQ2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBuYW1lcyA9IFtcclxuICAgICAgICAgICAgXCLkuIrlrphcIixcclxuICAgICAgICAgICAgXCLmrKfpmLNcIixcclxuICAgICAgICAgICAgXCLkuJzmlrlcIixcclxuICAgICAgICAgICAgXCLnq6/mnKhcIixcclxuICAgICAgICAgICAgXCLni6zlraRcIixcclxuICAgICAgICAgICAgXCLlj7jpqaxcIixcclxuICAgICAgICAgICAgXCLljZflrqtcIixcclxuICAgICAgICAgICAgXCLlpI/kvq9cIixcclxuICAgICAgICAgICAgXCLor7jokZtcIixcclxuICAgICAgICAgICAgXCLnmofnlKtcIixcclxuICAgICAgICAgICAgXCLplb/lrZlcIixcclxuICAgICAgICAgICAgXCLlrofmlodcIixcclxuICAgICAgICAgICAgXCLovanovpVcIixcclxuICAgICAgICAgICAgXCLkuJzpg61cIixcclxuICAgICAgICAgICAgXCLlrZDovaZcIixcclxuICAgICAgICAgICAgXCLkuJzpmLNcIixcclxuICAgICAgICAgICAgXCLlrZDoqIBcIixcclxuICAgICAgICBdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBuYW1lczIgPSBbXHJcbiAgICAgICAgICAgIFwi6ZuA5ZyjXCIsXHJcbiAgICAgICAgICAgIFwi6LWM5L6gXCIsXHJcbiAgICAgICAgICAgIFwi6LWM5ZyjXCIsXHJcbiAgICAgICAgICAgIFwi56iz6LWiXCIsXHJcbiAgICAgICAgICAgIFwi5LiN6L6TXCIsXHJcbiAgICAgICAgICAgIFwi5aW96L+QXCIsXHJcbiAgICAgICAgICAgIFwi6Ieq5pG4XCIsXHJcbiAgICAgICAgICAgIFwi5pyJ6ZKxXCIsXHJcbiAgICAgICAgICAgIFwi5Zyf6LGqXCIsXHJcbiAgICAgICAgXTtcclxuICAgICAgICB2YXIgaWR4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG5hbWVzLmxlbmd0aCAtIDEpKTtcclxuICAgICAgICB2YXIgaWR4MiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChuYW1lczIubGVuZ3RoIC0gMSkpO1xyXG4gICAgICAgIHRoaXMuaW5wdXROYW1lLnN0cmluZyA9IG5hbWVzW2lkeF0gKyBuYW1lczJbaWR4Ml07XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYoIWNjLnN5cy5pc05hdGl2ZSAmJiBjYy5zeXMuaXNNb2JpbGUpe1xyXG4gICAgICAgICAgICB2YXIgY3ZzID0gdGhpcy5ub2RlLmdldENvbXBvbmVudChjYy5DYW52YXMpO1xyXG4gICAgICAgICAgICBjdnMuZml0SGVpZ2h0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgY3ZzLmZpdFdpZHRoID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vblJhbmRvbUJ0bkNsaWNrZWQoKTtcclxuICAgIH0sXHJcblxyXG4gICAgb25CdG5Db25maXJtQ2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5pbnB1dE5hbWUuc3RyaW5nO1xyXG4gICAgICAgIGlmKG5hbWUgPT0gXCJcIil7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaW52YWxpZCBuYW1lLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmxvZyhuYW1lKTtcclxuICAgICAgICBjYy52di51c2VyTWdyLmNyZWF0ZShuYW1lKTtcclxuICAgIH1cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG5cclxuICAgIC8vIH0sXHJcbn0pO1xyXG4iLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIC8vIGZvbzoge1xyXG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuICAgICAgICBfZGlmZW54dWFuemU6bnVsbCxcclxuICAgICAgICBfemltbzpudWxsLFxyXG4gICAgICAgIF93YW5mYXh1YW56ZTpudWxsLFxyXG4gICAgICAgIF96dWlkYWZhbnNodTpudWxsLFxyXG4gICAgICAgIF9qdXNodXh1YW56ZTpudWxsLFxyXG4gICAgICAgIF9kaWFuZ2FuZ2h1YTpudWxsLFxyXG4gICAgICAgIF9sZWl4aW5neHVhbnplOm51bGwsXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fbGVpeGluZ3h1YW56ZSA9IFtdO1xyXG4gICAgICAgIHZhciB0ID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwibGVpeGluZ3h1YW56ZVwiKTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdC5jaGlsZHJlbkNvdW50OyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbiA9IHQuY2hpbGRyZW5baV0uZ2V0Q29tcG9uZW50KFwiUmFkaW9CdXR0b25cIik7XHJcbiAgICAgICAgICAgIGlmKG4gIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sZWl4aW5neHVhbnplLnB1c2gobik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5fZGlmZW54dWFuemUgPSBbXTtcclxuICAgICAgICB2YXIgdCA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImRpZmVueHVhbnplXCIpO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0LmNoaWxkcmVuQ291bnQ7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBuID0gdC5jaGlsZHJlbltpXS5nZXRDb21wb25lbnQoXCJSYWRpb0J1dHRvblwiKTtcclxuICAgICAgICAgICAgaWYobiAhPSBudWxsKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpZmVueHVhbnplLnB1c2gobik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLl9kaWZlbnh1YW56ZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5femltbyA9IFtdO1xyXG4gICAgICAgIHZhciB0ID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiemltb2ppYWNoZW5nXCIpO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0LmNoaWxkcmVuQ291bnQ7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBuID0gdC5jaGlsZHJlbltpXS5nZXRDb21wb25lbnQoXCJSYWRpb0J1dHRvblwiKTtcclxuICAgICAgICAgICAgaWYobiAhPSBudWxsKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ppbW8ucHVzaChuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuX3ppbW8pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX3dhbmZheHVhbnplID0gW107XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJ3YW5mYXh1YW56ZVwiKTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdC5jaGlsZHJlbkNvdW50OyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbiA9IHQuY2hpbGRyZW5baV0uZ2V0Q29tcG9uZW50KFwiQ2hlY2tCb3hcIik7XHJcbiAgICAgICAgICAgIGlmKG4gIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93YW5mYXh1YW56ZS5wdXNoKG4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vY29uc29sZS5sb2codGhpcy5fd2FuZmF4dWFuemUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX3p1aWRhZmFuc2h1ID0gW107XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJ6dWlkYWZhbnNodVwiKTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdC5jaGlsZHJlbkNvdW50OyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbiA9IHQuY2hpbGRyZW5baV0uZ2V0Q29tcG9uZW50KFwiUmFkaW9CdXR0b25cIik7XHJcbiAgICAgICAgICAgIGlmKG4gIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl96dWlkYWZhbnNodS5wdXNoKG4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vY29uc29sZS5sb2codGhpcy5fenVpZGFmYW5zaHUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX2p1c2h1eHVhbnplID0gW107XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJ4dWFuemVqdXNodVwiKTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdC5jaGlsZHJlbkNvdW50OyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbiA9IHQuY2hpbGRyZW5baV0uZ2V0Q29tcG9uZW50KFwiUmFkaW9CdXR0b25cIik7XHJcbiAgICAgICAgICAgIGlmKG4gIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9qdXNodXh1YW56ZS5wdXNoKG4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX2RpYW5nYW5naHVhID0gW107XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJkaWFuZ2FuZ2h1YVwiKTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdC5jaGlsZHJlbkNvdW50OyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbiA9IHQuY2hpbGRyZW5baV0uZ2V0Q29tcG9uZW50KFwiUmFkaW9CdXR0b25cIik7XHJcbiAgICAgICAgICAgIGlmKG4gIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaWFuZ2FuZ2h1YS5wdXNoKG4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vY29uc29sZS5sb2codGhpcy5fanVzaHV4dWFuemUpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25CdG5CYWNrOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25CdG5PSzpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNyZWF0ZVJvb20oKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGNyZWF0ZVJvb206ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG9uQ3JlYXRlID0gZnVuY3Rpb24ocmV0KXtcclxuICAgICAgICAgICAgaWYocmV0LmVycmNvZGUgIT09IDApe1xyXG4gICAgICAgICAgICAgICAgY2MudnYud2MuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhyZXQuZXJybXNnKTtcclxuICAgICAgICAgICAgICAgIGlmKHJldC5lcnJjb2RlID09IDIyMjIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLnZ2LmFsZXJ0LnNob3coXCLmj5DnpLpcIixcIuaIv+WNoeS4jei2s++8jOWIm+W7uuaIv+mXtOWksei0pSFcIik7ICBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MudnYuYWxlcnQuc2hvdyhcIuaPkOekulwiLFwi5Yib5bu65oi/6Ze05aSx6LSlLOmUmeivr+eggTpcIiArIHJldC5lcnJjb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgY2MudnYuZ2FtZU5ldE1nci5jb25uZWN0R2FtZVNlcnZlcihyZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgZGlmZW4gPSAwO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZWxmLl9kaWZlbnh1YW56ZS5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIGlmKHNlbGYuX2RpZmVueHVhbnplW2ldLmNoZWNrZWQpe1xyXG4gICAgICAgICAgICAgICAgZGlmZW4gPSBpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHppbW8gPSAwO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZWxmLl96aW1vLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgaWYoc2VsZi5femltb1tpXS5jaGVja2VkKXtcclxuICAgICAgICAgICAgICAgIHppbW8gPSBpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH0gICAgIFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGh1YW5zYW56aGFuZyA9IHNlbGYuX3dhbmZheHVhbnplWzBdLmNoZWNrZWQ7ICAgICAgICBcclxuICAgICAgICB2YXIgamlhbmdkdWkgPSBzZWxmLl93YW5mYXh1YW56ZVsxXS5jaGVja2VkO1xyXG4gICAgICAgIHZhciBtZW5xaW5nID0gc2VsZi5fd2FuZmF4dWFuemVbMl0uY2hlY2tlZDtcclxuICAgICAgICB2YXIgdGlhbmRpaHUgPSBzZWxmLl93YW5mYXh1YW56ZVszXS5jaGVja2VkO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciB0eXBlID0gMDtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VsZi5fbGVpeGluZ3h1YW56ZS5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIGlmKHNlbGYuX2xlaXhpbmd4dWFuemVbaV0uY2hlY2tlZCl7XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gaTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9ICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodHlwZSA9PSAwKXtcclxuICAgICAgICAgICAgdHlwZSA9IFwieHpkZFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB0eXBlID0gXCJ4bGNoXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciB6dWlkYWZhbnNodSA9IDA7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNlbGYuX3p1aWRhZmFuc2h1Lmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgaWYoc2VsZi5fenVpZGFmYW5zaHVbaV0uY2hlY2tlZCl7XHJcbiAgICAgICAgICAgICAgICB6dWlkYWZhbnNodSA9IGk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfSAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBqdXNodXh1YW56ZSA9IDA7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNlbGYuX2p1c2h1eHVhbnplLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgaWYoc2VsZi5fanVzaHV4dWFuemVbaV0uY2hlY2tlZCl7XHJcbiAgICAgICAgICAgICAgICBqdXNodXh1YW56ZSA9IGk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfSAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBkaWFuZ2FuZ2h1YSA9IDA7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNlbGYuX2RpYW5nYW5naHVhLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgaWYoc2VsZi5fZGlhbmdhbmdodWFbaV0uY2hlY2tlZCl7XHJcbiAgICAgICAgICAgICAgICBkaWFuZ2FuZ2h1YSA9IGk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfSAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBjb25mID0ge1xyXG4gICAgICAgICAgICB0eXBlOnR5cGUsXHJcbiAgICAgICAgICAgIGRpZmVuOmRpZmVuLFxyXG4gICAgICAgICAgICB6aW1vOnppbW8sXHJcbiAgICAgICAgICAgIGppYW5nZHVpOmppYW5nZHVpLFxyXG4gICAgICAgICAgICBodWFuc2Fuemhhbmc6aHVhbnNhbnpoYW5nLFxyXG4gICAgICAgICAgICB6dWlkYWZhbnNodTp6dWlkYWZhbnNodSxcclxuICAgICAgICAgICAganVzaHV4dWFuemU6anVzaHV4dWFuemUsXHJcbiAgICAgICAgICAgIGRpYW5nYW5naHVhOmRpYW5nYW5naHVhLFxyXG4gICAgICAgICAgICBtZW5xaW5nOm1lbnFpbmcsXHJcbiAgICAgICAgICAgIHRpYW5kaWh1OnRpYW5kaWh1LCAgIFxyXG4gICAgICAgIH07IFxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBkYXRhID0ge1xyXG4gICAgICAgICAgICBhY2NvdW50OmNjLnZ2LnVzZXJNZ3IuYWNjb3VudCxcclxuICAgICAgICAgICAgc2lnbjpjYy52di51c2VyTWdyLnNpZ24sXHJcbiAgICAgICAgICAgIGNvbmY6SlNPTi5zdHJpbmdpZnkoY29uZilcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xyXG4gICAgICAgIGNjLnZ2LndjLnNob3coXCLmraPlnKjliJvlu7rmiL/pl7RcIik7XHJcbiAgICAgICAgY2MudnYuaHR0cC5zZW5kUmVxdWVzdChcIi9jcmVhdGVfcHJpdmF0ZV9yb29tXCIsZGF0YSxvbkNyZWF0ZSk7ICAgXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgcXVlWWlNZW46bnVsbCxcclxuICAgICAgICB0aXBzOltdLFxyXG4gICAgICAgIHNlbGVjdGVkOltdLFxyXG4gICAgICAgIGRpbmdxdWVzOltdLFxyXG4gICAgICAgIC8vIGZvbzoge1xyXG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZihjYy52diA9PSBudWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmluaXRWaWV3KCk7XHJcbiAgICAgICAgdGhpcy5pbml0RGluZ1F1ZSgpO1xyXG4gICAgICAgIHRoaXMuaW5pdEV2ZW50SGFuZGxlcnMoKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGluaXRWaWV3OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIGdhbWVDaGlsZCA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImdhbWVcIik7XHJcbiAgICAgICAgdGhpcy5xdWVZaU1lbiA9IGdhbWVDaGlsZC5nZXRDaGlsZEJ5TmFtZShcImRpbmdxdWVcIik7XHJcbiAgICAgICAgdGhpcy5xdWVZaU1lbi5hY3RpdmUgPSBjYy52di5nYW1lTmV0TWdyLmlzRGluZ1F1ZWluZztcclxuICAgICAgICBcclxuICAgICAgICB2YXIgYXJyID0gW1wibXlzZWxmXCIsXCJyaWdodFwiLFwidXBcIixcImxlZnRcIl07XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBzaWRlID0gZ2FtZUNoaWxkLmdldENoaWxkQnlOYW1lKGFycltpXSk7XHJcbiAgICAgICAgICAgIHZhciBzZWF0ID0gc2lkZS5nZXRDaGlsZEJ5TmFtZShcInNlYXRcIik7XHJcbiAgICAgICAgICAgIHZhciBkaW5ncXVlID0gc2VhdC5nZXRDaGlsZEJ5TmFtZShcInF1ZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5kaW5ncXVlcy5wdXNoKGRpbmdxdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHRpcHMgPSB0aGlzLnF1ZVlpTWVuLmdldENoaWxkQnlOYW1lKFwidGlwc1wiKTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGlwcy5jaGlsZHJlbkNvdW50OyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbiA9IHRpcHMuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIHRoaXMudGlwcy5wdXNoKG4uZ2V0Q29tcG9uZW50KGNjLkxhYmVsKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKGNjLnZ2LmdhbWVOZXRNZ3IuZ2FtZXN0YXRlID09IFwiZGluZ3F1ZVwiKXtcclxuICAgICAgICAgICAgdGhpcy5zaG93RGluZ1F1ZUNob2ljZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIGluaXRFdmVudEhhbmRsZXJzOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMubm9kZS5vbignZ2FtZV9kaW5ncXVlJyxmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgc2VsZi5zaG93RGluZ1F1ZUNob2ljZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubm9kZS5vbignZ2FtZV9kaW5ncXVlX25vdGlmeScsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHZhciBzZWF0SW5kZXggPSBjYy52di5nYW1lTmV0TWdyLmdldFNlYXRJbmRleEJ5SUQoZGF0YS5kZXRhaWwpO1xyXG4gICAgICAgICAgICB2YXIgbG9jYWxJbmRleCA9IGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0TG9jYWxJbmRleChzZWF0SW5kZXgpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImdhbWVfZGluZ3F1ZV9ub3RpZnk6XCIgKyBsb2NhbEluZGV4KTtcclxuICAgICAgICAgICAgc2VsZi50aXBzW2xvY2FsSW5kZXhdLm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfZGluZ3F1ZV9maW5pc2gnLGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIC8v6YCa55+l5q+P5LiA5Liq546p5a625a6a57y655qE6Iqx6ImyXHJcbiAgICAgICAgICAgIHNlbGYucXVlWWlNZW4uYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNjLnZ2LmdhbWVOZXRNZ3IuaXNEaW5nUXVlaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNlbGYuaW5pdERpbmdRdWUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNob3dEaW5nUXVlQ2hvaWNlOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5xdWVZaU1lbi5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHZhciBzZCA9IGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0U2VsZkRhdGEoKTtcclxuICAgICAgICB2YXIgdHlwZUNvdW50cyA9IFswLDAsMF07XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNkLmhvbGRzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIHBhaSA9IHNkLmhvbGRzW2ldO1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0TWFoam9uZ1R5cGUocGFpKTtcclxuICAgICAgICAgICAgdHlwZUNvdW50c1t0eXBlXSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgbWluID0gNjU1MzU7XHJcbiAgICAgICAgdmFyIG1pbkluZGV4ID0gMDtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdHlwZUNvdW50cy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIGlmKHR5cGVDb3VudHNbaV0gPCBtaW4pe1xyXG4gICAgICAgICAgICAgICAgbWluID0gdHlwZUNvdW50c1tpXTtcclxuICAgICAgICAgICAgICAgIG1pbkluZGV4ID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgYXJyID0gW1widG9uZ1wiLFwidGlhb1wiLFwid2FuXCJdO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMucXVlWWlNZW4uZ2V0Q2hpbGRCeU5hbWUoYXJyW2ldKTtcclxuICAgICAgICAgICAgaWYobWluSW5kZXggPT0gaSl7XHJcbiAgICAgICAgICAgICAgICBub2RlLmdldENvbXBvbmVudChjYy5BbmltYXRpb24pLnBsYXkoXCJkaW5ncXVlX3R1aWppYW5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIG5vZGUuZ2V0Q29tcG9uZW50KGNjLkFuaW1hdGlvbikuc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vdGhpcy5xdWVZaU1lbi5nZXRDaGlsZEJ5TmFtZShhcnJbaV0pLmdldENoaWxkQnlOYW1lKCdqaWFuJykuYWN0aXZlID0gbWluSW5kZXggPT0gaTsgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy50aXBzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLnRpcHNbaV07XHJcbiAgICAgICAgICAgIGlmKGkgPiAwKXtcclxuICAgICAgICAgICAgICAgIG4ubm9kZS5hY3RpdmUgPSBmYWxzZTsgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIG4ubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgaW5pdERpbmdRdWU6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgYXJyID0gW1widG9uZ1wiLFwidGlhb1wiLFwid2FuXCJdO1xyXG4gICAgICAgIHZhciBkYXRhID0gY2MudnYuZ2FtZU5ldE1nci5zZWF0cztcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBxdWUgPSBkYXRhW2ldLmRpbmdxdWU7XHJcbiAgICAgICAgICAgIGlmKHF1ZSA9PSBudWxsIHx8IHF1ZSA8IDAgfHwgcXVlID49IGFyci5sZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgcXVlID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgcXVlID0gYXJyW3F1ZV07IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgbG9jYWxJbmRleCA9IGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0TG9jYWxJbmRleChpKTtcclxuICAgICAgICAgICAgaWYocXVlKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGluZ3F1ZXNbbG9jYWxJbmRleF0uZ2V0Q2hpbGRCeU5hbWUocXVlKS5hY3RpdmUgPSB0cnVlOyAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIHJlc2V0OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5zZXRJbnRlcmFjdGFibGUodHJ1ZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZC5wdXNoKHRoaXMucXVlWWlNZW4uZ2V0Q2hpbGRCeU5hbWUoXCJ0b25nX3NlbGVjdGVkXCIpKTtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkLnB1c2godGhpcy5xdWVZaU1lbi5nZXRDaGlsZEJ5TmFtZShcInRpYW9fc2VsZWN0ZWRcIikpO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWQucHVzaCh0aGlzLnF1ZVlpTWVuLmdldENoaWxkQnlOYW1lKFwid2FuX3NlbGVjdGVkXCIpKTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5zZWxlY3RlZC5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRbaV0uYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgfSAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuZGluZ3F1ZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgdGhpcy5kaW5ncXVlc1tpXS5jaGlsZHJlbi5sZW5ndGg7ICsrail7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpbmdxdWVzW2ldLmNoaWxkcmVuW2pdLmFjdGl2ZSA9IGZhbHNlOyAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uUXVlWWlNZW5DbGlja2VkOmZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICB2YXIgdHlwZSA9IDA7XHJcbiAgICAgICAgaWYoZXZlbnQudGFyZ2V0Lm5hbWUgPT0gXCJ0b25nXCIpe1xyXG4gICAgICAgICAgICB0eXBlID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihldmVudC50YXJnZXQubmFtZSA9PSBcInRpYW9cIil7XHJcbiAgICAgICAgICAgIHR5cGUgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldC5uYW1lID09IFwid2FuXCIpe1xyXG4gICAgICAgICAgICB0eXBlID0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuc2VsZWN0ZWQubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkW2ldLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH0gIFxyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRbdHlwZV0uYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICBjYy52di5nYW1lTmV0TWdyLmRpbmdxdWUgPSB0eXBlO1xyXG4gICAgICAgIGNjLnZ2Lm5ldC5zZW5kKFwiZGluZ3F1ZVwiLHR5cGUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vdGhpcy5zZXRJbnRlcmFjdGFibGUoZmFsc2UpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc2V0SW50ZXJhY3RhYmxlOmZ1bmN0aW9uKHZhbHVlKXtcclxuICAgICAgICB0aGlzLnF1ZVlpTWVuLmdldENoaWxkQnlOYW1lKFwidG9uZ1wiKS5nZXRDb21wb25lbnQoY2MuQnV0dG9uKS5pbnRlcmFjdGFibGUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnF1ZVlpTWVuLmdldENoaWxkQnlOYW1lKFwidGlhb1wiKS5nZXRDb21wb25lbnQoY2MuQnV0dG9uKS5pbnRlcmFjdGFibGUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnF1ZVlpTWVuLmdldENoaWxkQnlOYW1lKFwid2FuXCIpLmdldENvbXBvbmVudChjYy5CdXR0b24pLmludGVyYWN0YWJsZSA9IHZhbHVlOyAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCxcclxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XHJcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxyXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcclxuICAgICAgICAvLyB9LFxyXG4gICAgICAgIC8vIC4uLlxyXG4gICAgICAgIF9mb2xkczpudWxsLFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmKGNjLnZ2ID09IG51bGwpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuaW5pdFZpZXcoKTtcclxuICAgICAgICB0aGlzLmluaXRFdmVudEhhbmRsZXIoKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmluaXRBbGxGb2xkcygpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgaW5pdFZpZXc6ZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLl9mb2xkcyA9IHt9O1xyXG4gICAgICAgIHZhciBnYW1lID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiZ2FtZVwiKTtcclxuICAgICAgICB2YXIgc2lkZXMgPSBbXCJteXNlbGZcIixcInJpZ2h0XCIsXCJ1cFwiLFwibGVmdFwiXTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2lkZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgc2lkZU5hbWUgPSBzaWRlc1tpXTtcclxuICAgICAgICAgICAgdmFyIHNpZGVSb290ID0gZ2FtZS5nZXRDaGlsZEJ5TmFtZShzaWRlTmFtZSk7XHJcbiAgICAgICAgICAgIHZhciBmb2xkcyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgZm9sZFJvb3QgPSBzaWRlUm9vdC5nZXRDaGlsZEJ5TmFtZShcImZvbGRzXCIpO1xyXG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgZm9sZFJvb3QuY2hpbGRyZW4ubGVuZ3RoOyArK2ope1xyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSBmb2xkUm9vdC5jaGlsZHJlbltqXTtcclxuICAgICAgICAgICAgICAgIG4uYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gbi5nZXRDb21wb25lbnQoY2MuU3ByaXRlKTsgXHJcbiAgICAgICAgICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZm9sZHMucHVzaChzcHJpdGUpOyAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2ZvbGRzW3NpZGVOYW1lXSA9IGZvbGRzOyBcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5oaWRlQWxsRm9sZHMoKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGhpZGVBbGxGb2xkczpmdW5jdGlvbigpe1xyXG4gICAgICAgIGZvcih2YXIgayBpbiB0aGlzLl9mb2xkcyl7XHJcbiAgICAgICAgICAgIHZhciBmID0gdGhpcy5fZm9sZHNbaV07XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSBpbiBmKXtcclxuICAgICAgICAgICAgICAgIGZbaV0ubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIGluaXRFdmVudEhhbmRsZXI6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW1lX2JlZ2luJyxmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgc2VsZi5pbml0QWxsRm9sZHMoKTtcclxuICAgICAgICB9KTsgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubm9kZS5vbignZ2FtZV9zeW5jJyxmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgc2VsZi5pbml0QWxsRm9sZHMoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfY2h1cGFpX25vdGlmeScsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHNlbGYuaW5pdEZvbGRzKGRhdGEuZGV0YWlsKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm5vZGUub24oJ2d1b19ub3RpZnknLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBzZWxmLmluaXRGb2xkcyhkYXRhLmRldGFpbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBpbml0QWxsRm9sZHM6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgc2VhdHMgPSBjYy52di5nYW1lTmV0TWdyLnNlYXRzO1xyXG4gICAgICAgIGZvcih2YXIgaSBpbiBzZWF0cyl7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdEZvbGRzKHNlYXRzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBpbml0Rm9sZHM6ZnVuY3Rpb24oc2VhdERhdGEpe1xyXG4gICAgICAgIHZhciBmb2xkcyA9IHNlYXREYXRhLmZvbGRzO1xyXG4gICAgICAgIGlmKGZvbGRzID09IG51bGwpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsb2NhbEluZGV4ID0gY2MudnYuZ2FtZU5ldE1nci5nZXRMb2NhbEluZGV4KHNlYXREYXRhLnNlYXRpbmRleCk7XHJcbiAgICAgICAgdmFyIHByZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0Rm9sZFByZShsb2NhbEluZGV4KTtcclxuICAgICAgICB2YXIgc2lkZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0U2lkZShsb2NhbEluZGV4KTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgZm9sZHNTcHJpdGVzID0gdGhpcy5fZm9sZHNbc2lkZV07XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGZvbGRzU3ByaXRlcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgIGlmKHNpZGUgPT0gXCJyaWdodFwiIHx8IHNpZGUgPT0gXCJ1cFwiKXtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9sZHNTcHJpdGVzLmxlbmd0aCAtIGkgLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzcHJpdGUgPSBmb2xkc1Nwcml0ZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICBzcHJpdGUubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnNldFNwcml0ZUZyYW1lQnlNSklEKHByZSxzcHJpdGUsZm9sZHNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IodmFyIGkgPSBmb2xkcy5sZW5ndGg7IGkgPCBmb2xkc1Nwcml0ZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICBpZihzaWRlID09IFwicmlnaHRcIiB8fCBzaWRlID09IFwidXBcIil7XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvbGRzU3ByaXRlcy5sZW5ndGggLSBpIC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gZm9sZHNTcHJpdGVzW2luZGV4XTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHNwcml0ZS5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH0gIFxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc2V0U3ByaXRlRnJhbWVCeU1KSUQ6ZnVuY3Rpb24ocHJlLHNwcml0ZSxtamlkKXtcclxuICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKHByZSxtamlkKTtcclxuICAgICAgICBzcHJpdGUubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xyXG4gICAgLy8gdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcclxuXHJcbiAgICAvLyB9LFxyXG59KTtcclxuIiwiY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBkYXRhRXZlbnRIYW5kbGVyOm51bGwsXHJcbiAgICAgICAgcm9vbUlkOm51bGwsXHJcbiAgICAgICAgbWF4TnVtT2ZHYW1lczowLFxyXG4gICAgICAgIG51bU9mR2FtZXM6MCxcclxuICAgICAgICBudW1PZk1KOjAsXHJcbiAgICAgICAgc2VhdEluZGV4Oi0xLFxyXG4gICAgICAgIHNlYXRzOm51bGwsXHJcbiAgICAgICAgdHVybjotMSxcclxuICAgICAgICBidXR0b246LTEsXHJcbiAgICAgICAgZGluZ3F1ZTotMSxcclxuICAgICAgICBjaHVwYWk6LTEsXHJcbiAgICAgICAgaXNEaW5nUXVlaW5nOmZhbHNlLFxyXG4gICAgICAgIGlzSHVhblNhblpoYW5nOmZhbHNlLFxyXG4gICAgICAgIGdhbWVzdGF0ZTpcIlwiLFxyXG4gICAgICAgIGlzT3ZlcjpmYWxzZSxcclxuICAgICAgICBkaXNzb3ZlRGF0YTpudWxsLFxyXG4gICAgICAgIC8vIGZvbzoge1xyXG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuICAgIH0sXHJcbiAgICBcclxuICAgIHJlc2V0OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy50dXJuID0gLTE7XHJcbiAgICAgICAgdGhpcy5jaHVwYWkgPSAtMSxcclxuICAgICAgICB0aGlzLmRpbmdxdWUgPSAtMTtcclxuICAgICAgICB0aGlzLmJ1dHRvbiA9IC0xO1xyXG4gICAgICAgIHRoaXMuZ2FtZXN0YXRlID0gXCJcIjtcclxuICAgICAgICB0aGlzLmRpbmdxdWUgPSAtMTtcclxuICAgICAgICB0aGlzLmlzRGluZ1F1ZWluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNIdWFuU2FuWmhhbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmN1cmFjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuc2VhdHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB0aGlzLnNlYXRzW2ldLmhvbGRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuc2VhdHNbaV0uZm9sZHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5zZWF0c1tpXS5wZW5ncyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnNlYXRzW2ldLmFuZ2FuZ3MgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5zZWF0c1tpXS5kaWFuZ2FuZ3MgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5zZWF0c1tpXS53YW5nYW5ncyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnNlYXRzW2ldLmRpbmdxdWUgPSAtMTtcclxuICAgICAgICAgICAgdGhpcy5zZWF0c1tpXS5yZWFkeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnNlYXRzW2ldLmh1ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5zZWF0c1tpXS5odWFucGFpcyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaHVhbnBhaW1ldGhvZCA9IC0xO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIGNsZWFyOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5kYXRhRXZlbnRIYW5kbGVyID0gbnVsbDtcclxuICAgICAgICBpZih0aGlzLmlzT3ZlciA9PSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5zZWF0cyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMucm9vbUlkID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5tYXhOdW1PZkdhbWVzID0gMDtcclxuICAgICAgICAgICAgdGhpcy5udW1PZkdhbWVzID0gMDsgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQsZGF0YSl7XHJcbiAgICAgICAgaWYodGhpcy5kYXRhRXZlbnRIYW5kbGVyKXtcclxuICAgICAgICAgICAgdGhpcy5kYXRhRXZlbnRIYW5kbGVyLmVtaXQoZXZlbnQsZGF0YSk7XHJcbiAgICAgICAgfSAgICBcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGdldFNlYXRJbmRleEJ5SUQ6ZnVuY3Rpb24odXNlcklkKXtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5zZWF0cy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5zZWF0c1tpXTtcclxuICAgICAgICAgICAgaWYocy51c2VyaWQgPT0gdXNlcklkKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGlzT3duZXI6ZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWF0SW5kZXggPT0gMDsgICBcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGdldFNlYXRCeUlEOmZ1bmN0aW9uKHVzZXJJZCl7XHJcbiAgICAgICAgdmFyIHNlYXRJbmRleCA9IHRoaXMuZ2V0U2VhdEluZGV4QnlJRCh1c2VySWQpO1xyXG4gICAgICAgIHZhciBzZWF0ID0gdGhpcy5zZWF0c1tzZWF0SW5kZXhdO1xyXG4gICAgICAgIHJldHVybiBzZWF0O1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgZ2V0U2VsZkRhdGE6ZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWF0c1t0aGlzLnNlYXRJbmRleF07XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBnZXRMb2NhbEluZGV4OmZ1bmN0aW9uKGluZGV4KXtcclxuICAgICAgICB2YXIgcmV0ID0gKGluZGV4IC0gdGhpcy5zZWF0SW5kZXggKyA0KSAlIDQ7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHByZXBhcmVSZXBsYXk6ZnVuY3Rpb24ocm9vbUluZm8sZGV0YWlsT2ZHYW1lKXtcclxuICAgICAgICB0aGlzLnJvb21JZCA9IHJvb21JbmZvLmlkO1xyXG4gICAgICAgIHRoaXMuc2VhdHMgPSByb29tSW5mby5zZWF0cztcclxuICAgICAgICB0aGlzLnR1cm4gPSBkZXRhaWxPZkdhbWUuYmFzZV9pbmZvLmJ1dHRvbjtcclxuICAgICAgICB2YXIgYmFzZUluZm8gPSBkZXRhaWxPZkdhbWUuYmFzZV9pbmZvO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnNlYXRzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnNlYXRzW2ldO1xyXG4gICAgICAgICAgICBzLnNlYXRpbmRleCA9IGk7XHJcbiAgICAgICAgICAgIHMuc2NvcmUgPSBudWxsO1xyXG4gICAgICAgICAgICBzLmhvbGRzID0gYmFzZUluZm8uZ2FtZV9zZWF0c1tpXTtcclxuICAgICAgICAgICAgcy5wZW5ncyA9IFtdO1xyXG4gICAgICAgICAgICBzLmFuZ2FuZ3MgPSBbXTtcclxuICAgICAgICAgICAgcy5kaWFuZ2FuZ3MgPSBbXTtcclxuICAgICAgICAgICAgcy53YW5nYW5ncyA9IFtdO1xyXG4gICAgICAgICAgICBzLmZvbGRzID0gW107XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHMpO1xyXG4gICAgICAgICAgICBpZihjYy52di51c2VyTWdyLnVzZXJJZCA9PSBzLnVzZXJpZCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXRJbmRleCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25mID0ge1xyXG4gICAgICAgICAgICB0eXBlOmJhc2VJbmZvLnR5cGUsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMuY29uZi50eXBlID09IG51bGwpe1xyXG4gICAgICAgICAgICB0aGlzLmNvbmYudHlwZSA9PSBcInh6ZGRcIjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBnZXRXYW5mYTpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBjb25mID0gdGhpcy5jb25mO1xyXG4gICAgICAgIGlmKGNvbmYgJiYgY29uZi5tYXhHYW1lcyE9bnVsbCAmJiBjb25mLm1heEZhbiE9bnVsbCl7XHJcbiAgICAgICAgICAgIHZhciBzdHJBcnIgPSBbXTtcclxuICAgICAgICAgICAgc3RyQXJyLnB1c2goY29uZi5tYXhHYW1lcyArIFwi5bGAXCIpO1xyXG4gICAgICAgICAgICBzdHJBcnIucHVzaChjb25mLm1heEZhbiArIFwi55Wq5bCB6aG2XCIpO1xyXG4gICAgICAgICAgICBpZihjb25mLmhzeil7XHJcbiAgICAgICAgICAgICAgICBzdHJBcnIucHVzaChcIuaNouS4ieW8oFwiKTsgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihjb25mLnppbW8gPT0gMSl7XHJcbiAgICAgICAgICAgICAgICBzdHJBcnIucHVzaChcIuiHquaRuOWKoOeVqlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgc3RyQXJyLnB1c2goXCLoh6rmkbjliqDlupVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoY29uZi5qaWFuZ2R1aSl7XHJcbiAgICAgICAgICAgICAgICBzdHJBcnIucHVzaChcIuWwhuWvuVwiKTsgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihjb25mLmRpYW5nYW5naHVhID09IDEpe1xyXG4gICAgICAgICAgICAgICAgc3RyQXJyLnB1c2goXCLngrnmnaDoirEo6Ieq5pG4KVwiKTsgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgc3RyQXJyLnB1c2goXCLngrnmnaDoirEo5pS+54KuKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihjb25mLm1lbnFpbmcpe1xyXG4gICAgICAgICAgICAgICAgc3RyQXJyLnB1c2goXCLpl6jmuIXjgIHkuK3lvKBcIik7ICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoY29uZi50aWFuZGlodSl7XHJcbiAgICAgICAgICAgICAgICBzdHJBcnIucHVzaChcIuWkqeWcsOiDoVwiKTsgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RyQXJyLmpvaW4oXCIgXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGluaXRIYW5kbGVyczpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcImxvZ2luX3Jlc3VsdFwiLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcclxuICAgICAgICAgICAgaWYoZGF0YS5lcnJjb2RlID09PSAwKXtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gZGF0YS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5yb29tSWQgPSBkYXRhLnJvb21pZDtcclxuICAgICAgICAgICAgICAgIHNlbGYuY29uZiA9IGRhdGEuY29uZjtcclxuICAgICAgICAgICAgICAgIHNlbGYubWF4TnVtT2ZHYW1lcyA9IGRhdGEuY29uZi5tYXhHYW1lcztcclxuICAgICAgICAgICAgICAgIHNlbGYubnVtT2ZHYW1lcyA9IGRhdGEubnVtb2ZnYW1lcztcclxuICAgICAgICAgICAgICAgIHNlbGYuc2VhdHMgPSBkYXRhLnNlYXRzO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5zZWF0SW5kZXggPSBzZWxmLmdldFNlYXRJbmRleEJ5SUQoY2MudnYudXNlck1nci51c2VySWQpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5pc092ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YS5lcnJtc2cpOyAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcImxvZ2luX2ZpbmlzaGVkXCIsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibG9naW5fZmluaXNoZWRcIik7XHJcbiAgICAgICAgICAgIGNjLmRpcmVjdG9yLmxvYWRTY2VuZShcIm1qZ2FtZVwiKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJleGl0X3Jlc3VsdFwiLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBzZWxmLnJvb21JZCA9IG51bGw7XHJcbiAgICAgICAgICAgIHNlbGYudHVybiA9IC0xO1xyXG4gICAgICAgICAgICBzZWxmLmRpbmdxdWUgPSAtMTtcclxuICAgICAgICAgICAgc2VsZi5pc0RpbmdRdWVpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgc2VsZi5zZWF0cyA9IG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJleGl0X25vdGlmeV9wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgdmFyIHVzZXJJZCA9IGRhdGE7XHJcbiAgICAgICAgICAgdmFyIHMgPSBzZWxmLmdldFNlYXRCeUlEKHVzZXJJZCk7XHJcbiAgICAgICAgICAgaWYocyAhPSBudWxsKXtcclxuICAgICAgICAgICAgICAgcy51c2VyaWQgPSAwO1xyXG4gICAgICAgICAgICAgICBzLm5hbWUgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJ1c2VyX3N0YXRlX2NoYW5nZWRcIixzKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJkaXNwcmVzc19wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHNlbGYucm9vbUlkID0gbnVsbDtcclxuICAgICAgICAgICAgc2VsZi50dXJuID0gLTE7XHJcbiAgICAgICAgICAgIHNlbGYuZGluZ3F1ZSA9IC0xO1xyXG4gICAgICAgICAgICBzZWxmLmlzRGluZ1F1ZWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBzZWxmLnNlYXRzID0gbnVsbDtcclxuICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwiZGlzY29ubmVjdFwiLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBpZihzZWxmLnJvb21JZCA9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgIGNjLmRpcmVjdG9yLmxvYWRTY2VuZShcImhhbGxcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGlmKHNlbGYuaXNPdmVyID09IGZhbHNlKXtcclxuICAgICAgICAgICAgICAgICAgICBjYy52di51c2VyTWdyLm9sZFJvb21JZCA9IHNlbGYucm9vbUlkO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChcImRpc2Nvbm5lY3RcIik7ICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yb29tSWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJuZXdfdXNlcl9jb21lc19wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coZGF0YSk7XHJcbiAgICAgICAgICAgIHZhciBzZWF0SW5kZXggPSBkYXRhLnNlYXRpbmRleDtcclxuICAgICAgICAgICAgaWYoc2VsZi5zZWF0c1tzZWF0SW5kZXhdLnVzZXJpZCA+IDApe1xyXG4gICAgICAgICAgICAgICAgc2VsZi5zZWF0c1tzZWF0SW5kZXhdLm9ubGluZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGRhdGEub25saW5lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHNlbGYuc2VhdHNbc2VhdEluZGV4XSA9IGRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCduZXdfdXNlcicsc2VsZi5zZWF0c1tzZWF0SW5kZXhdKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcInVzZXJfc3RhdGVfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGRhdGEpO1xyXG4gICAgICAgICAgICB2YXIgdXNlcklkID0gZGF0YS51c2VyaWQ7XHJcbiAgICAgICAgICAgIHZhciBzZWF0ID0gc2VsZi5nZXRTZWF0QnlJRCh1c2VySWQpO1xyXG4gICAgICAgICAgICBzZWF0Lm9ubGluZSA9IGRhdGEub25saW5lO1xyXG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3VzZXJfc3RhdGVfY2hhbmdlZCcsc2VhdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJ1c2VyX3JlYWR5X3B1c2hcIixmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhkYXRhKTtcclxuICAgICAgICAgICAgdmFyIHVzZXJJZCA9IGRhdGEudXNlcmlkO1xyXG4gICAgICAgICAgICB2YXIgc2VhdCA9IHNlbGYuZ2V0U2VhdEJ5SUQodXNlcklkKTtcclxuICAgICAgICAgICAgc2VhdC5yZWFkeSA9IGRhdGEucmVhZHk7XHJcbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgndXNlcl9zdGF0ZV9jaGFuZ2VkJyxzZWF0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcImdhbWVfaG9sZHNfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICB2YXIgc2VhdCA9IHNlbGYuc2VhdHNbc2VsZi5zZWF0SW5kZXhdOyBcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XHJcbiAgICAgICAgICAgIHNlYXQuaG9sZHMgPSBkYXRhO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNlbGYuc2VhdHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSBzZWxmLnNlYXRzW2ldOyBcclxuICAgICAgICAgICAgICAgIGlmKHMuZm9sZHMgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcy5mb2xkcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYocy5wZW5ncyA9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBzLnBlbmdzID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZihzLmFuZ2FuZ3MgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcy5hbmdhbmdzID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZihzLmRpYW5nYW5ncyA9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBzLmRpYW5nYW5ncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYocy53YW5nYW5ncyA9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBzLndhbmdhbmdzID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzLnJlYWR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdnYW1lX2hvbGRzJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgIFxyXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwiZ2FtZV9iZWdpbl9wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnYW1lX2FjdGlvbl9wdXNoJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xyXG4gICAgICAgICAgICBzZWxmLmJ1dHRvbiA9IGRhdGE7XHJcbiAgICAgICAgICAgIHNlbGYudHVybiA9IHNlbGYuYnV0dG9uO1xyXG4gICAgICAgICAgICBzZWxmLmdhbWVzdGF0ZSA9IFwiYmVnaW5cIjtcclxuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdnYW1lX2JlZ2luJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJnYW1lX3BsYXlpbmdfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZ2FtZV9wbGF5aW5nX3B1c2gnKTsgXHJcbiAgICAgICAgICAgIHNlbGYuZ2FtZXN0YXRlID0gXCJwbGF5aW5nXCI7IFxyXG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2dhbWVfcGxheWluZycpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwiZ2FtZV9zeW5jX3B1c2hcIixmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJnYW1lX3N5bmNfcHVzaFwiKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XHJcbiAgICAgICAgICAgIHNlbGYubnVtT2ZNSiA9IGRhdGEubnVtb2ZtajtcclxuICAgICAgICAgICAgc2VsZi5nYW1lc3RhdGUgPSBkYXRhLnN0YXRlO1xyXG4gICAgICAgICAgICBpZihzZWxmLmdhbWVzdGF0ZSA9PSBcImRpbmdxdWVcIil7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmlzRGluZ1F1ZWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihzZWxmLmdhbWVzdGF0ZSA9PSBcImh1YW5wYWlcIil7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmlzSHVhblNhblpoYW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWxmLnR1cm4gPSBkYXRhLnR1cm47XHJcbiAgICAgICAgICAgIHNlbGYuYnV0dG9uID0gZGF0YS5idXR0b247XHJcbiAgICAgICAgICAgIHNlbGYuY2h1cGFpID0gZGF0YS5jaHVQYWk7XHJcbiAgICAgICAgICAgIHNlbGYuaHVhbnBhaW1ldGhvZCA9IGRhdGEuaHVhbnBhaW1ldGhvZDtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDQ7ICsraSl7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VhdCA9IHNlbGYuc2VhdHNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgc2QgPSBkYXRhLnNlYXRzW2ldO1xyXG4gICAgICAgICAgICAgICAgc2VhdC5ob2xkcyA9IHNkLmhvbGRzO1xyXG4gICAgICAgICAgICAgICAgc2VhdC5mb2xkcyA9IHNkLmZvbGRzO1xyXG4gICAgICAgICAgICAgICAgc2VhdC5hbmdhbmdzID0gc2QuYW5nYW5ncztcclxuICAgICAgICAgICAgICAgIHNlYXQuZGlhbmdhbmdzID0gc2QuZGlhbmdhbmdzO1xyXG4gICAgICAgICAgICAgICAgc2VhdC53YW5nYW5ncyA9IHNkLndhbmdhbmdzO1xyXG4gICAgICAgICAgICAgICAgc2VhdC5wZW5ncyA9IHNkLnBlbmdzO1xyXG4gICAgICAgICAgICAgICAgc2VhdC5kaW5ncXVlID0gc2QucXVlO1xyXG4gICAgICAgICAgICAgICAgc2VhdC5odWVkID0gc2QuaHVlZDsgXHJcbiAgICAgICAgICAgICAgICBzZWF0LmlzemltbyA9IHNkLmlzemltbztcclxuICAgICAgICAgICAgICAgIHNlYXQuaHVpbmZvID0gc2QuaHVpbmZvO1xyXG4gICAgICAgICAgICAgICAgc2VhdC5odWFucGFpcyA9IHNkLmh1YW5wYWlzO1xyXG4gICAgICAgICAgICAgICAgaWYoaSA9PSBzZWxmLnNlYXRJbmRleCl7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kaW5ncXVlID0gc2QucXVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcImdhbWVfZGluZ3F1ZV9wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHNlbGYuaXNEaW5nUXVlaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2VsZi5pc0h1YW5TYW5aaGFuZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2dhbWVfZGluZ3F1ZScpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwiZ2FtZV9odWFucGFpX3B1c2hcIixmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgc2VsZi5pc0h1YW5TYW5aaGFuZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZ2FtZV9odWFucGFpJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJoYW5nYW5nX25vdGlmeV9wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnaGFuZ2FuZ19ub3RpZnknLGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwiZ2FtZV9hY3Rpb25fcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBzZWxmLmN1cmFjdGlvbiA9IGRhdGE7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xyXG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2dhbWVfYWN0aW9uJyxkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcImdhbWVfY2h1cGFpX3B1c2hcIixmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2dhbWVfY2h1cGFpX3B1c2gnKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhkYXRhKTtcclxuICAgICAgICAgICAgdmFyIHR1cm5Vc2VySUQgPSBkYXRhO1xyXG4gICAgICAgICAgICB2YXIgc2kgPSBzZWxmLmdldFNlYXRJbmRleEJ5SUQodHVyblVzZXJJRCk7XHJcbiAgICAgICAgICAgIHNlbGYuZG9UdXJuQ2hhbmdlKHNpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcImdhbWVfbnVtX3B1c2hcIixmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgc2VsZi5udW1PZkdhbWVzID0gZGF0YTtcclxuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdnYW1lX251bScsZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwiZ2FtZV9vdmVyX3B1c2hcIixmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2dhbWVfb3Zlcl9wdXNoJyk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gZGF0YS5yZXN1bHRzO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgIHNlbGYuc2VhdHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgc2VsZi5zZWF0c1tpXS5zY29yZSA9IHJlc3VsdHMubGVuZ3RoID09IDA/IDA6cmVzdWx0c1tpXS50b3RhbHNjb3JlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZ2FtZV9vdmVyJyxyZXN1bHRzKTtcclxuICAgICAgICAgICAgaWYoZGF0YS5lbmRpbmZvKXtcclxuICAgICAgICAgICAgICAgIHNlbGYuaXNPdmVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZ2FtZV9lbmQnLGRhdGEuZW5kaW5mbyk7ICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYucmVzZXQoKTtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8ICBzZWxmLnNlYXRzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgndXNlcl9zdGF0ZV9jaGFuZ2VkJyxzZWxmLnNlYXRzW2ldKTsgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcIm1qX2NvdW50X3B1c2hcIixmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ21qX2NvdW50X3B1c2gnKTtcclxuICAgICAgICAgICAgc2VsZi5udW1PZk1KID0gZGF0YTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhkYXRhKTtcclxuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdtal9jb3VudCcsZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJodV9wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdodV9wdXNoJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xyXG4gICAgICAgICAgICBzZWxmLmRvSHUoZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJnYW1lX2NodXBhaV9ub3RpZnlfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICB2YXIgdXNlcklkID0gZGF0YS51c2VySWQ7XHJcbiAgICAgICAgICAgIHZhciBwYWkgPSBkYXRhLnBhaTtcclxuICAgICAgICAgICAgdmFyIHNpID0gc2VsZi5nZXRTZWF0SW5kZXhCeUlEKHVzZXJJZCk7XHJcbiAgICAgICAgICAgIHNlbGYuZG9DaHVwYWkoc2kscGFpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcImdhbWVfbW9wYWlfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZ2FtZV9tb3BhaV9wdXNoJyk7XHJcbiAgICAgICAgICAgIHNlbGYuZG9Nb3BhaShzZWxmLnNlYXRJbmRleCxkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcImd1b19ub3RpZnlfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZ3VvX25vdGlmeV9wdXNoJyk7XHJcbiAgICAgICAgICAgIHZhciB1c2VySWQgPSBkYXRhLnVzZXJJZDtcclxuICAgICAgICAgICAgdmFyIHBhaSA9IGRhdGEucGFpO1xyXG4gICAgICAgICAgICB2YXIgc2kgPSBzZWxmLmdldFNlYXRJbmRleEJ5SUQodXNlcklkKTtcclxuICAgICAgICAgICAgc2VsZi5kb0d1byhzaSxwYWkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwiZ3VvX3Jlc3VsdFwiLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZ3VvX3Jlc3VsdCcpO1xyXG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2d1b19yZXN1bHQnKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcImd1b2h1X3B1c2hcIixmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2d1b2h1X3B1c2gnKTtcclxuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwicHVzaF9ub3RpY2VcIix7aW5mbzpcIui/h+iDoVwiLHRpbWU6MS41fSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJodWFucGFpX25vdGlmeVwiLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICB2YXIgc2VhdCA9IHNlbGYuZ2V0U2VhdEJ5SUQoZGF0YS5zaSk7XHJcbiAgICAgICAgICAgIHNlYXQuaHVhbnBhaXMgPSBkYXRhLmh1YW5wYWlzO1xyXG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2h1YW5wYWlfbm90aWZ5JyxzZWF0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcImdhbWVfaHVhbnBhaV9vdmVyX3B1c2hcIixmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2dhbWVfaHVhbnBhaV9vdmVyX3B1c2gnKTtcclxuICAgICAgICAgICAgdmFyIGluZm8gPSBcIlwiO1xyXG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gZGF0YS5tZXRob2Q7XHJcbiAgICAgICAgICAgIGlmKG1ldGhvZCA9PSAwKXtcclxuICAgICAgICAgICAgICAgIGluZm8gPSBcIuaNouWvueWutueJjFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYobWV0aG9kID09IDEpe1xyXG4gICAgICAgICAgICAgICAgaW5mbyA9IFwi5o2i5LiL5a6254mMXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGluZm8gPSBcIuaNouS4iuWutueJjFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYuaHVhbnBhaW1ldGhvZCA9IG1ldGhvZDtcclxuICAgICAgICAgICAgY2MudnYuZ2FtZU5ldE1nci5pc0h1YW5TYW5aaGFuZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJnYW1lX2h1YW5wYWlfb3ZlclwiKTtcclxuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwicHVzaF9ub3RpY2VcIix7aW5mbzppbmZvLHRpbWU6Mn0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwicGVuZ19ub3RpZnlfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygncGVuZ19ub3RpZnlfcHVzaCcpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcclxuICAgICAgICAgICAgdmFyIHVzZXJJZCA9IGRhdGEudXNlcmlkO1xyXG4gICAgICAgICAgICB2YXIgcGFpID0gZGF0YS5wYWk7XHJcbiAgICAgICAgICAgIHZhciBzaSA9IHNlbGYuZ2V0U2VhdEluZGV4QnlJRCh1c2VySWQpO1xyXG4gICAgICAgICAgICBzZWxmLmRvUGVuZyhzaSxkYXRhLnBhaSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJnYW5nX25vdGlmeV9wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnYW5nX25vdGlmeV9wdXNoJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xyXG4gICAgICAgICAgICB2YXIgdXNlcklkID0gZGF0YS51c2VyaWQ7XHJcbiAgICAgICAgICAgIHZhciBwYWkgPSBkYXRhLnBhaTtcclxuICAgICAgICAgICAgdmFyIHNpID0gc2VsZi5nZXRTZWF0SW5kZXhCeUlEKHVzZXJJZCk7XHJcbiAgICAgICAgICAgIHNlbGYuZG9HYW5nKHNpLHBhaSxkYXRhLmdhbmd0eXBlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcImdhbWVfZGluZ3F1ZV9ub3RpZnlfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2dhbWVfZGluZ3F1ZV9ub3RpZnknLGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwiZ2FtZV9kaW5ncXVlX2ZpbmlzaF9wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIHNlbGYuc2VhdHNbaV0uZGluZ3F1ZSA9IGRhdGFbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdnYW1lX2RpbmdxdWVfZmluaXNoJyxkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBcclxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcImNoYXRfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJjaGF0X3B1c2hcIixkYXRhKTsgICAgXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJxdWlja19jaGF0X3B1c2hcIixmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwicXVpY2tfY2hhdF9wdXNoXCIsZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJlbW9qaV9wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChcImVtb2ppX3B1c2hcIixkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcImRpc3NvbHZlX25vdGljZV9wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZGlzc29sdmVfbm90aWNlX3B1c2hcIik7IFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcclxuICAgICAgICAgICAgc2VsZi5kaXNzb3ZlRGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChcImRpc3NvbHZlX25vdGljZVwiLGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwiZGlzc29sdmVfY2FuY2VsX3B1c2hcIixmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgc2VsZi5kaXNzb3ZlRGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChcImRpc3NvbHZlX2NhbmNlbFwiLGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwidm9pY2VfbXNnX3B1c2hcIixmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwidm9pY2VfbXNnXCIsZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBkb0d1bzpmdW5jdGlvbihzZWF0SW5kZXgscGFpKXtcclxuICAgICAgICB2YXIgc2VhdERhdGEgPSB0aGlzLnNlYXRzW3NlYXRJbmRleF07XHJcbiAgICAgICAgdmFyIGZvbGRzID0gc2VhdERhdGEuZm9sZHM7XHJcbiAgICAgICAgZm9sZHMucHVzaChwYWkpO1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnZ3VvX25vdGlmeScsc2VhdERhdGEpOyAgICBcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGRvTW9wYWk6ZnVuY3Rpb24oc2VhdEluZGV4LHBhaSl7XHJcbiAgICAgICAgdmFyIHNlYXREYXRhID0gdGhpcy5zZWF0c1tzZWF0SW5kZXhdO1xyXG4gICAgICAgIGlmKHNlYXREYXRhLmhvbGRzKXtcclxuICAgICAgICAgICAgc2VhdERhdGEuaG9sZHMucHVzaChwYWkpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2dhbWVfbW9wYWknLHtzZWF0SW5kZXg6c2VhdEluZGV4LHBhaTpwYWl9KTsgICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBkb0NodXBhaTpmdW5jdGlvbihzZWF0SW5kZXgscGFpKXtcclxuICAgICAgICB0aGlzLmNodXBhaSA9IHBhaTtcclxuICAgICAgICB2YXIgc2VhdERhdGEgPSB0aGlzLnNlYXRzW3NlYXRJbmRleF07XHJcbiAgICAgICAgaWYoc2VhdERhdGEuaG9sZHMpeyAgICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGlkeCA9IHNlYXREYXRhLmhvbGRzLmluZGV4T2YocGFpKTtcclxuICAgICAgICAgICAgc2VhdERhdGEuaG9sZHMuc3BsaWNlKGlkeCwxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdnYW1lX2NodXBhaV9ub3RpZnknLHtzZWF0RGF0YTpzZWF0RGF0YSxwYWk6cGFpfSk7ICAgIFxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgZG9QZW5nOmZ1bmN0aW9uKHNlYXRJbmRleCxwYWkpe1xyXG4gICAgICAgIHZhciBzZWF0RGF0YSA9IHRoaXMuc2VhdHNbc2VhdEluZGV4XTtcclxuICAgICAgICAvL+enu+mZpOaJi+eJjFxyXG4gICAgICAgIGlmKHNlYXREYXRhLmhvbGRzKXtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDI7ICsraSl7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gc2VhdERhdGEuaG9sZHMuaW5kZXhPZihwYWkpO1xyXG4gICAgICAgICAgICAgICAgc2VhdERhdGEuaG9sZHMuc3BsaWNlKGlkeCwxKTtcclxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIC8v5pu05paw56Kw54mM5pWw5o2uXHJcbiAgICAgICAgdmFyIHBlbmdzID0gc2VhdERhdGEucGVuZ3M7XHJcbiAgICAgICAgcGVuZ3MucHVzaChwYWkpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3Blbmdfbm90aWZ5JyxzZWF0RGF0YSk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBnZXRHYW5nVHlwZTpmdW5jdGlvbihzZWF0RGF0YSxwYWkpe1xyXG4gICAgICAgIGlmKHNlYXREYXRhLnBlbmdzLmluZGV4T2YocGFpKSAhPSAtMSl7XHJcbiAgICAgICAgICAgIHJldHVybiBcIndhbmdhbmdcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgdmFyIGNudCA9IDA7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZWF0RGF0YS5ob2xkcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgICBpZihzZWF0RGF0YS5ob2xkc1tpXSA9PSBwYWkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGNudCA9PSAzKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImRpYW5nYW5nXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImFuZ2FuZ1wiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgZG9HYW5nOmZ1bmN0aW9uKHNlYXRJbmRleCxwYWksZ2FuZ3R5cGUpe1xyXG4gICAgICAgIHZhciBzZWF0RGF0YSA9IHRoaXMuc2VhdHNbc2VhdEluZGV4XTtcclxuICAgICAgICBcclxuICAgICAgICBpZighZ2FuZ3R5cGUpe1xyXG4gICAgICAgICAgICBnYW5ndHlwZSA9IHRoaXMuZ2V0R2FuZ1R5cGUoc2VhdERhdGEscGFpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoZ2FuZ3R5cGUgPT0gXCJ3YW5nYW5nXCIpe1xyXG4gICAgICAgICAgICBpZihzZWF0RGF0YS5wZW5ncy5pbmRleE9mKHBhaSkgIT0gLTEpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IHNlYXREYXRhLnBlbmdzLmluZGV4T2YocGFpKTtcclxuICAgICAgICAgICAgICAgIGlmKGlkeCAhPSAtMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VhdERhdGEucGVuZ3Muc3BsaWNlKGlkeCwxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWF0RGF0YS53YW5nYW5ncy5wdXNoKHBhaSk7ICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHNlYXREYXRhLmhvbGRzKXtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8PSA0OyArK2kpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IHNlYXREYXRhLmhvbGRzLmluZGV4T2YocGFpKTtcclxuICAgICAgICAgICAgICAgIGlmKGlkeCA9PSAtMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy/lpoLmnpzmsqHmnInmib7liLDvvIzooajnpLrnp7vlrozkuobvvIznm7TmjqXot7Plh7rlvqrnjq9cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlYXREYXRhLmhvbGRzLnNwbGljZShpZHgsMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoZ2FuZ3R5cGUgPT0gXCJhbmdhbmdcIil7XHJcbiAgICAgICAgICAgIHNlYXREYXRhLmFuZ2FuZ3MucHVzaChwYWkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGdhbmd0eXBlID09IFwiZGlhbmdhbmdcIil7XHJcbiAgICAgICAgICAgIHNlYXREYXRhLmRpYW5nYW5ncy5wdXNoKHBhaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnZ2FuZ19ub3RpZnknLHtzZWF0RGF0YTpzZWF0RGF0YSxnYW5ndHlwZTpnYW5ndHlwZX0pO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgZG9IdTpmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2h1cGFpJyxkYXRhKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGRvVHVybkNoYW5nZTpmdW5jdGlvbihzaSl7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgICAgICAgIGxhc3Q6dGhpcy50dXJuLFxyXG4gICAgICAgICAgICB0dXJuOnNpLFxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnR1cm4gPSBzaTtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2dhbWVfY2h1cGFpJyxkYXRhKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGNvbm5lY3RHYW1lU2VydmVyOmZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgIHRoaXMuZGlzc292ZURhdGEgPSBudWxsO1xyXG4gICAgICAgIGNjLnZ2Lm5ldC5pcCA9IGRhdGEuaXAgKyBcIjpcIiArIGRhdGEucG9ydDtcclxuICAgICAgICBjb25zb2xlLmxvZyhjYy52di5uZXQuaXApO1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIG9uQ29ubmVjdE9LID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJvbkNvbm5lY3RPS1wiKTtcclxuICAgICAgICAgICAgdmFyIHNkID0ge1xyXG4gICAgICAgICAgICAgICAgdG9rZW46ZGF0YS50b2tlbixcclxuICAgICAgICAgICAgICAgIHJvb21pZDpkYXRhLnJvb21pZCxcclxuICAgICAgICAgICAgICAgIHRpbWU6ZGF0YS50aW1lLFxyXG4gICAgICAgICAgICAgICAgc2lnbjpkYXRhLnNpZ24sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNjLnZ2Lm5ldC5zZW5kKFwibG9naW5cIixzZCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgb25Db25uZWN0RmFpbGVkID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJmYWlsZWQuXCIpO1xyXG4gICAgICAgICAgICBjYy52di53Yy5oaWRlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjYy52di53Yy5zaG93KFwi5q2j5Zyo6L+b5YWl5oi/6Ze0XCIpO1xyXG4gICAgICAgIGNjLnZ2Lm5ldC5jb25uZWN0KG9uQ29ubmVjdE9LLG9uQ29ubmVjdEZhaWxlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCxcclxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XHJcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxyXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcclxuICAgICAgICAvLyB9LFxyXG4gICAgICAgIC8vIC4uLlxyXG4gICAgICAgIF9nYW1lb3ZlcjpudWxsLFxyXG4gICAgICAgIF9nYW1lcmVzdWx0Om51bGwsXHJcbiAgICAgICAgX3NlYXRzOltdLFxyXG4gICAgICAgIF9pc0dhbWVFbmQ6ZmFsc2UsXHJcbiAgICAgICAgX3BpbmdqdTpudWxsLFxyXG4gICAgICAgIF93aW46bnVsbCxcclxuICAgICAgICBfbG9zZTpudWxsLFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmKGNjLnZ2ID09IG51bGwpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGNjLnZ2LmdhbWVOZXRNZ3IuY29uZiA9PSBudWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihjYy52di5nYW1lTmV0TWdyLmNvbmYudHlwZSA9PSBcInh6ZGRcIil7XHJcbiAgICAgICAgICAgIHRoaXMuX2dhbWVvdmVyID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiZ2FtZV9vdmVyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB0aGlzLl9nYW1lb3ZlciA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImdhbWVfb3Zlcl94bGNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9nYW1lb3Zlci5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9waW5nanUgPSB0aGlzLl9nYW1lb3Zlci5nZXRDaGlsZEJ5TmFtZShcInBpbmdqdVwiKTtcclxuICAgICAgICB0aGlzLl93aW4gPSB0aGlzLl9nYW1lb3Zlci5nZXRDaGlsZEJ5TmFtZShcIndpblwiKTtcclxuICAgICAgICB0aGlzLl9sb3NlID0gdGhpcy5fZ2FtZW92ZXIuZ2V0Q2hpbGRCeU5hbWUoXCJsb3NlXCIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX2dhbWVyZXN1bHQgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJnYW1lX3Jlc3VsdFwiKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgd2FuZmEgPSB0aGlzLl9nYW1lb3Zlci5nZXRDaGlsZEJ5TmFtZShcIndhbmZhXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCk7XHJcbiAgICAgICAgd2FuZmEuc3RyaW5nID0gY2MudnYuZ2FtZU5ldE1nci5nZXRXYW5mYSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBsaXN0Um9vdCA9IHRoaXMuX2dhbWVvdmVyLmdldENoaWxkQnlOYW1lKFwicmVzdWx0X2xpc3RcIik7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8PSA0OyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgcyA9IFwic1wiICsgaTtcclxuICAgICAgICAgICAgdmFyIHNuID0gbGlzdFJvb3QuZ2V0Q2hpbGRCeU5hbWUocyk7XHJcbiAgICAgICAgICAgIHZhciB2aWV3ZGF0YSA9IHt9O1xyXG4gICAgICAgICAgICB2aWV3ZGF0YS51c2VybmFtZSA9IHNuLmdldENoaWxkQnlOYW1lKCd1c2VybmFtZScpLmdldENvbXBvbmVudChjYy5MYWJlbCk7XHJcbiAgICAgICAgICAgIHZpZXdkYXRhLnJlYXNvbiA9IHNuLmdldENoaWxkQnlOYW1lKCdyZWFzb24nKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGYgPSBzbi5nZXRDaGlsZEJ5TmFtZSgnZmFuJyk7XHJcbiAgICAgICAgICAgIGlmKGYgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICB2aWV3ZGF0YS5mYW4gPSBmLmdldENvbXBvbmVudChjYy5MYWJlbCk7ICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2aWV3ZGF0YS5zY29yZSA9IHNuLmdldENoaWxkQnlOYW1lKCdzY29yZScpLmdldENvbXBvbmVudChjYy5MYWJlbCk7XHJcbiAgICAgICAgICAgIHZpZXdkYXRhLmh1ID0gc24uZ2V0Q2hpbGRCeU5hbWUoJ2h1Jyk7XHJcbiAgICAgICAgICAgIHZpZXdkYXRhLm1haGpvbmdzID0gc24uZ2V0Q2hpbGRCeU5hbWUoJ3BhaScpO1xyXG4gICAgICAgICAgICB2aWV3ZGF0YS56aHVhbmcgPSBzbi5nZXRDaGlsZEJ5TmFtZSgnemh1YW5nJyk7XHJcbiAgICAgICAgICAgIHZpZXdkYXRhLmh1cGFpID0gc24uZ2V0Q2hpbGRCeU5hbWUoJ2h1cGFpJyk7XHJcbiAgICAgICAgICAgIHZpZXdkYXRhLl9wZW5nYW5kZ2FuZyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9zZWF0cy5wdXNoKHZpZXdkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy/liJ3lp4vljJbnvZHnu5zkuovku7bnm5HlkKzlmahcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW1lX292ZXInLGZ1bmN0aW9uKGRhdGEpe3NlbGYub25HYW1lT3ZlcihkYXRhLmRldGFpbCk7fSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW1lX2VuZCcsZnVuY3Rpb24oZGF0YSl7c2VsZi5faXNHYW1lRW5kID0gdHJ1ZTt9KTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uR2FtZU92ZXIoZGF0YSl7XHJcbiAgICAgICAgaWYoY2MudnYuZ2FtZU5ldE1nci5jb25mLnR5cGUgPT0gXCJ4emRkXCIpe1xyXG4gICAgICAgICAgICB0aGlzLm9uR2FtZU92ZXJfWFpERChkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5vbkdhbWVPdmVyX1hMQ0goZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25HYW1lT3Zlcl9YWkREKGRhdGEpe1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xyXG4gICAgICAgIGlmKGRhdGEubGVuZ3RoID09IDApe1xyXG4gICAgICAgICAgICB0aGlzLl9nYW1lcmVzdWx0LmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZ2FtZW92ZXIuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9waW5nanUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fd2luLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2xvc2UuYWN0aXZlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHZhciBteXNjb3JlID0gZGF0YVtjYy52di5nYW1lTmV0TWdyLnNlYXRJbmRleF0uc2NvcmU7XHJcbiAgICAgICAgaWYobXlzY29yZSA+IDApe1xyXG4gICAgICAgICAgICB0aGlzLl93aW4uYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB9ICAgICAgICAgXHJcbiAgICAgICAgZWxzZSBpZihteXNjb3JlIDwgMCl7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvc2UuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5fcGluZ2p1LmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAvL+aYvuekuueOqeWutuS/oeaBr1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCA0OyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgc2VhdFZpZXcgPSB0aGlzLl9zZWF0c1tpXTtcclxuICAgICAgICAgICAgdmFyIHVzZXJEYXRhID0gZGF0YVtpXTtcclxuICAgICAgICAgICAgdmFyIGh1ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy/og6HniYznmoTnjqnlrrbmiY3mmL7npLog5piv5ZCm5riF5LiA6ImyIOaguXhu55qE5a2X5qC3XHJcbiAgICAgICAgICAgIHZhciBudW1PZkdhbmdzID0gdXNlckRhdGEuYW5nYW5ncy5sZW5ndGggKyB1c2VyRGF0YS53YW5nYW5ncy5sZW5ndGggKyB1c2VyRGF0YS5kaWFuZ2FuZ3MubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgbnVtT2ZHZW4gPSB1c2VyRGF0YS5udW1vZmdlbjtcclxuICAgICAgICAgICAgdmFyIGFjdGlvbkFyciA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgaXM3cGFpcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGlzY2hhZGFqaWFvID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCB1c2VyRGF0YS5hY3Rpb25zLmxlbmd0aDsgKytqKXtcclxuICAgICAgICAgICAgICAgIHZhciBhYyA9IHVzZXJEYXRhLmFjdGlvbnNbal07XHJcbiAgICAgICAgICAgICAgICBpZihhYy50eXBlID09IFwiemltb1wiIHx8IGFjLnR5cGUgPT0gXCJnYW5naHVhXCIgfHwgYWMudHlwZSA9PSBcImRpYW5nYW5naHVhXCIgfHwgYWMudHlwZSA9PSBcImh1XCIgfHwgYWMudHlwZSA9PSBcImdhbmdwYW9odVwiIHx8IGFjLnR5cGUgPT0gXCJxaWFuZ2dhbmdodVwiIHx8IGFjLnR5cGUgPT0gXCJjaGFkYWppYW9cIil7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodXNlckRhdGEucGF0dGVybiA9PSBcIjdwYWlyc1wiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLkuIPlr7lcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYodXNlckRhdGEucGF0dGVybiA9PSBcImw3cGFpcnNcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi6b6Z5LiD5a+5XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHVzZXJEYXRhLnBhdHRlcm4gPT0gXCJqN3BhaXJzXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuWwhuS4g+WvuVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZih1c2VyRGF0YS5wYXR0ZXJuID09IFwiZHVpZHVpXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIueisOeisOiDoVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZih1c2VyRGF0YS5wYXR0ZXJuID09IFwiamlhbmdkdWlcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5bCG5a+5XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBpZihhYy50eXBlID09IFwiemltb1wiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLoh6rmkbhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcImdhbmdodWFcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5p2g5LiK6IqxXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGFjLnR5cGUgPT0gXCJkaWFuZ2FuZ2h1YVwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLngrnmnaDoirFcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcImdhbmdwYW9odVwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLmnaDngq7og6FcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcInFpYW5nZ2FuZ2h1XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuaKouadoOiDoVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihhYy50eXBlID09IFwiY2hhZGFqaWFvXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc2NoYWRhamlhbyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGh1ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihhYy50eXBlID09IFwiZmFuZ3Bhb1wiKXtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuaUvueCrlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcImFuZ2FuZ1wiKXtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuaal+adoFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcImRpYW5nYW5nXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5piO5p2gXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihhYy50eXBlID09IFwid2FuZ2FuZ1wiKXtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuW8r+adoFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcImZhbmdnYW5nXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLmlL7mnaBcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGFjLnR5cGUgPT0gXCJ6aHVhbnNob3VnYW5nXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi6L2s5omL5p2gXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihhYy50eXBlID09IFwiYmVpcWlhbmdnYW5nXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi6KKr5oqi5p2gXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihhYy50eXBlID09IFwiYmVpY2hhZGFqaWFvXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi6KKr5p+l5Y+rXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihodWVkKXtcclxuICAgICAgICAgICAgICAgIGlmKHVzZXJEYXRhLnFpbmd5aXNlKXtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIua4heS4gOiJslwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYodXNlckRhdGEubWVucWluZyl7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLpl6jmuIVcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmKHVzZXJEYXRhLnpob25nemhhbmcpe1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5Lit5bygXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS5qaW5nb3VodSl7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLph5Hpkqnog6FcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS5oYWlkaWh1KXtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIua1t+W6leiDoVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYodXNlckRhdGEudGlhbmh1KXtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuWkqeiDoVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYodXNlckRhdGEuZGlodSl7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLlnLDog6FcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYobnVtT2ZHZW4gPiAwKXtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuaguXhcIiArIG51bU9mR2VuKTsgXHJcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZihpc2NoYWRhamlhbyl7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLmn6XlpKflj6tcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGZvcih2YXIgbyA9IDA7IG8gPCAzOysrbyl7XHJcbiAgICAgICAgICAgICAgICBzZWF0Vmlldy5odS5jaGlsZHJlbltvXS5hY3RpdmUgPSBmYWxzZTsgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYodXNlckRhdGEuaHVvcmRlciA+PSAwKXtcclxuICAgICAgICAgICAgICAgIHNlYXRWaWV3Lmh1LmNoaWxkcmVuW3VzZXJEYXRhLmh1b3JkZXJdLmFjdGl2ZSA9IHRydWU7ICAgIFxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZWF0Vmlldy51c2VybmFtZS5zdHJpbmcgPSBjYy52di5nYW1lTmV0TWdyLnNlYXRzW2ldLm5hbWU7XHJcbiAgICAgICAgICAgIHNlYXRWaWV3LnpodWFuZy5hY3RpdmUgPSBjYy52di5nYW1lTmV0TWdyLmJ1dHRvbiA9PSBpO1xyXG4gICAgICAgICAgICBzZWF0Vmlldy5yZWFzb24uc3RyaW5nID0gYWN0aW9uQXJyLmpvaW4oXCLjgIFcIik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL+iDoeeJjOeahOeOqeWutuaJjeacieeVqlxyXG4gICAgICAgICAgICB2YXIgZmFuID0gMDtcclxuICAgICAgICAgICAgaWYoaHVlZCl7XHJcbiAgICAgICAgICAgICAgICBmYW4gPSB1c2VyRGF0YS5mYW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VhdFZpZXcuZmFuLnN0cmluZyA9IGZhbiArIFwi55WqXCI7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICBpZih1c2VyRGF0YS5zY29yZSA+IDApe1xyXG4gICAgICAgICAgICAgICAgc2VhdFZpZXcuc2NvcmUuc3RyaW5nID0gXCIrXCIgKyB1c2VyRGF0YS5zY29yZTsgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHNlYXRWaWV3LnNjb3JlLnN0cmluZyA9IHVzZXJEYXRhLnNjb3JlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgaHVwYWkgPSAtMTtcclxuICAgICAgICAgICAgaWYoaHVlZCl7XHJcbiAgICAgICAgICAgICAgICBodXBhaSA9IHVzZXJEYXRhLmhvbGRzLnBvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjYy52di5tYWhqb25nbWdyLnNvcnRNSih1c2VyRGF0YS5ob2xkcyx1c2VyRGF0YS5kaW5ncXVlKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8v6IOh54mM5LiN5Y+C5LiO5o6S5bqPXHJcbiAgICAgICAgICAgIGlmKGh1ZWQpe1xyXG4gICAgICAgICAgICAgICAgdXNlckRhdGEuaG9sZHMucHVzaChodXBhaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8v6ZqQ6JeP5omA5pyJ54mMXHJcbiAgICAgICAgICAgIGZvcih2YXIgayA9IDA7IGsgPCBzZWF0Vmlldy5tYWhqb25ncy5jaGlsZHJlbkNvdW50OyArK2spe1xyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSBzZWF0Vmlldy5tYWhqb25ncy5jaGlsZHJlbltrXTtcclxuICAgICAgICAgICAgICAgIG4uYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGxhY2tpbmdOdW0gPSAodXNlckRhdGEucGVuZ3MubGVuZ3RoICsgbnVtT2ZHYW5ncykqMzsgXHJcbiAgICAgICAgICAgIC8v5pi+56S655u45YWz55qE54mMXHJcbiAgICAgICAgICAgIGZvcih2YXIgayA9IDA7IGsgPCB1c2VyRGF0YS5ob2xkcy5sZW5ndGg7ICsrayl7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFpID0gdXNlckRhdGEuaG9sZHNba107XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHNlYXRWaWV3Lm1haGpvbmdzLmNoaWxkcmVuW2sgKyBsYWNraW5nTnVtXTtcclxuICAgICAgICAgICAgICAgIG4uYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBzcHJpdGUgPSBuLmdldENvbXBvbmVudChjYy5TcHJpdGUpO1xyXG4gICAgICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gY2MudnYubWFoam9uZ21nci5nZXRTcHJpdGVGcmFtZUJ5TUpJRChcIk1fXCIscGFpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGZvcih2YXIgayA9IDA7IGsgPCBzZWF0Vmlldy5fcGVuZ2FuZGdhbmcubGVuZ3RoOyArK2spe1xyXG4gICAgICAgICAgICAgICAgc2VhdFZpZXcuX3BlbmdhbmRnYW5nW2tdLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL+WIneWni+WMluadoOeJjFxyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICB2YXIgZ2FuZ3MgPSB1c2VyRGF0YS5hbmdhbmdzO1xyXG4gICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgZ2FuZ3MubGVuZ3RoOyArK2spe1xyXG4gICAgICAgICAgICAgICAgdmFyIG1qaWQgPSBnYW5nc1trXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFBlbmdBbmRHYW5ncyhzZWF0VmlldyxpbmRleCxtamlkLFwiYW5nYW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgaW5kZXgrKzsgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBnYW5ncyA9IHVzZXJEYXRhLmRpYW5nYW5ncztcclxuICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IGdhbmdzLmxlbmd0aDsgKytrKXtcclxuICAgICAgICAgICAgICAgIHZhciBtamlkID0gZ2FuZ3Nba107XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRQZW5nQW5kR2FuZ3Moc2VhdFZpZXcsaW5kZXgsbWppZCxcImRpYW5nYW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgaW5kZXgrKzsgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBnYW5ncyA9IHVzZXJEYXRhLndhbmdhbmdzO1xyXG4gICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgZ2FuZ3MubGVuZ3RoOyArK2spe1xyXG4gICAgICAgICAgICAgICAgdmFyIG1qaWQgPSBnYW5nc1trXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFBlbmdBbmRHYW5ncyhzZWF0VmlldyxpbmRleCxtamlkLFwid2FuZ2FuZ1wiKTtcclxuICAgICAgICAgICAgICAgIGluZGV4Kys7ICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL+WIneWni+WMlueisOeJjFxyXG4gICAgICAgICAgICB2YXIgcGVuZ3MgPSB1c2VyRGF0YS5wZW5nc1xyXG4gICAgICAgICAgICBpZihwZW5ncyl7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgcGVuZ3MubGVuZ3RoOyArK2spe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtamlkID0gcGVuZ3Nba107XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0UGVuZ0FuZEdhbmdzKHNlYXRWaWV3LGluZGV4LG1qaWQsXCJwZW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7ICAgIFxyXG4gICAgICAgICAgICAgICAgfSAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBvbkdhbWVPdmVyX1hMQ0g6ZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XHJcbiAgICAgICAgaWYoZGF0YS5sZW5ndGggPT0gMCl7XHJcbiAgICAgICAgICAgIHRoaXMuX2dhbWVyZXN1bHQuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9nYW1lb3Zlci5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3BpbmdqdS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl93aW4uYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbG9zZS5hY3RpdmUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgdmFyIG15c2NvcmUgPSBkYXRhW2NjLnZ2LmdhbWVOZXRNZ3Iuc2VhdEluZGV4XS5zY29yZTtcclxuICAgICAgICBpZihteXNjb3JlID4gMCl7XHJcbiAgICAgICAgICAgIHRoaXMuX3dpbi5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIH0gICAgICAgICBcclxuICAgICAgICBlbHNlIGlmKG15c2NvcmUgPCAwKXtcclxuICAgICAgICAgICAgdGhpcy5fbG9zZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB0aGlzLl9waW5nanUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIC8v5pi+56S6546p5a625L+h5oGvXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDQ7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBzZWF0VmlldyA9IHRoaXMuX3NlYXRzW2ldO1xyXG4gICAgICAgICAgICB2YXIgdXNlckRhdGEgPSBkYXRhW2ldO1xyXG4gICAgICAgICAgICB2YXIgaHVlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgYWN0aW9uQXJyID0gW107XHJcbiAgICAgICAgICAgIHZhciBpczdwYWlycyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgaXNjaGFkYWppYW8gPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGh1cGFpUm9vdCA9IHNlYXRWaWV3Lmh1cGFpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGh1cGFpUm9vdC5jaGlsZHJlbi5sZW5ndGg7ICsrail7XHJcbiAgICAgICAgICAgICAgICBodXBhaVJvb3QuY2hpbGRyZW5bal0uYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBoaSA9IDA7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCB1c2VyRGF0YS5odWluZm8ubGVuZ3RoOyArK2ope1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSB1c2VyRGF0YS5odWluZm9bal07XHJcbiAgICAgICAgICAgICAgICBodWVkID0gaHVlZCB8fCBpbmZvLmlzaHVwYWk7XHJcbiAgICAgICAgICAgICAgICBpZihpbmZvLmlzaHVwYWkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGhpIDwgaHVwYWlSb290LmNoaWxkcmVuLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBodXBhaVZpZXcgPSBodXBhaVJvb3QuY2hpbGRyZW5baGldOyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHVwYWlWaWV3LmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh1cGFpVmlldy5nZXRDb21wb25lbnQoY2MuU3ByaXRlKS5zcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0U3ByaXRlRnJhbWVCeU1KSUQoXCJCX1wiLGluZm8ucGFpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGkrKzsgICBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHZhciBzdHIgPSBcIlwiXHJcbiAgICAgICAgICAgICAgICB2YXIgc2VwID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFzZWF0ID0gdXNlckRhdGE7XHJcbiAgICAgICAgICAgICAgICBpZighaW5mby5pc2h1cGFpKXtcclxuICAgICAgICAgICAgICAgICAgICBpZihpbmZvLmFjdGlvbiA9PSBcImZhbmdwYW9cIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IFwi5pS+54KuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoaW5mby5hY3Rpb24gPT0gXCJnYW5ncGFvXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBcIuadoOS4iueCrlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGluZm8uYWN0aW9uID09IFwiYmVpcWlhbmdnYW5nXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBcIuiiq+aKouadoFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBcIuiiq+afpeWkp+WPq1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBkYXRhc2VhdCA9IGRhdGFbaW5mby50YXJnZXRdOyBcclxuICAgICAgICAgICAgICAgICAgICBpbmZvID0gZGF0YXNlYXQuaHVpbmZvW2luZm8uaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBpZihpbmZvLmFjdGlvbiA9PSBcImh1XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBcIuaOpeeCruiDoVwiXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoaW5mby5hY3Rpb24gPT0gXCJ6aW1vXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBcIuiHquaRuFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGluZm8uYWN0aW9uID09IFwiZ2FuZ2h1YVwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gXCLmnaDkuIroirFcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihpbmZvLmFjdGlvbiA9PSBcImRpYW5nYW5naHVhXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBcIueCueadoOiKsVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGluZm8uYWN0aW9uID09IFwiZ2FuZ3Bhb2h1XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBcIuadoOeCruiDoVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGluZm8uYWN0aW9uID09IFwicWlhbmdnYW5naHVcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IFwi5oqi5p2g6IOhXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoaW5mby5hY3Rpb24gPT0gXCJjaGFkYWppYW9cIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IFwi5p+l5aSn5Y+rXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSAgIFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCIoXCI7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmKGluZm8ucGF0dGVybiA9PSBcIjdwYWlyc1wiKXtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gXCLkuIPlr7lcIjtcclxuICAgICAgICAgICAgICAgICAgICBzZXAgPSBcIuOAgVwiXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGluZm8ucGF0dGVybiA9PSBcImw3cGFpcnNcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9IFwi6b6Z5LiD5a+5XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VwID0gXCLjgIFcIlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihpbmZvLnBhdHRlcm4gPT0gXCJqN3BhaXJzXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBcIuWwhuS4g+WvuVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcCA9IFwi44CBXCJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaW5mby5wYXR0ZXJuID09IFwiZHVpZHVpXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBcIueisOeisOiDoVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcCA9IFwi44CBXCJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaW5mby5wYXR0ZXJuID09IFwiamlhbmdkdWlcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9IFwi5bCG5a+5XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VwID0gXCLjgIFcIlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYoaW5mby5oYWlkaWh1KXtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gc2VwICsgXCLmtbflupXog6FcIjtcclxuICAgICAgICAgICAgICAgICAgICBzZXAgPSBcIuOAgVwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZihpbmZvLnRpYW5odSl7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9IHNlcCArIFwi5aSp6IOhXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VwID0gXCLjgIFcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYoaW5mby5kaWh1KXtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gc2VwICsgXCLlnLDog6FcIjtcclxuICAgICAgICAgICAgICAgICAgICBzZXAgPSBcIuOAgVwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZihkYXRhc2VhdC5xaW5neWlzZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9IHNlcCArIFwi5riF5LiA6ImyXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VwID0gXCLjgIFcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYoZGF0YXNlYXQubWVucWluZyl7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9IHNlcCArIFwi6Zeo5riFXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VwID0gXCLjgIFcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYoZGF0YXNlYXQuamluZ291aHUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBzZXAgKyBcIumHkemSqeiDoVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcCA9IFwi44CBXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmKGRhdGFzZWF0Lnpob25nemhhbmcpe1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBzZXAgKyBcIuS4reW8oFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcCA9IFwi44CBXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYoaW5mby5udW1vZmdlbiA+IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBzZXAgKyBcIuaguXhcIiArIGluZm8ubnVtb2ZnZW47XHJcbiAgICAgICAgICAgICAgICAgICAgc2VwID0gXCLjgIFcIjsgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmKHNlcCA9PSBcIlwiKXtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gXCLlubPog6FcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgc3RyICs9IFwi44CBXCIgKyBpbmZvLmZhbiArIFwi55WqXCI7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHN0ciArPSBcIilcIjtcclxuICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKHN0cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHNlYXRWaWV3Lmh1LmFjdGl2ZSA9IGh1ZWQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZih1c2VyRGF0YS5hbmdhbmdzLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuaal+adoHhcIiArIHVzZXJEYXRhLmFuZ2FuZ3MubGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYodXNlckRhdGEuZGlhbmdhbmdzLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuaYjuadoHhcIiArIHVzZXJEYXRhLmRpYW5nYW5ncy5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZih1c2VyRGF0YS53YW5nYW5ncy5sZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLlt7TmnaB4XCIgKyB1c2VyRGF0YS53YW5nYW5ncy5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZWF0Vmlldy51c2VybmFtZS5zdHJpbmcgPSBjYy52di5nYW1lTmV0TWdyLnNlYXRzW2ldLm5hbWU7XHJcbiAgICAgICAgICAgIHNlYXRWaWV3LnpodWFuZy5hY3RpdmUgPSBjYy52di5nYW1lTmV0TWdyLmJ1dHRvbiA9PSBpO1xyXG4gICAgICAgICAgICBzZWF0Vmlldy5yZWFzb24uc3RyaW5nID0gYWN0aW9uQXJyLmpvaW4oXCLjgIFcIik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICBpZih1c2VyRGF0YS5zY29yZSA+IDApe1xyXG4gICAgICAgICAgICAgICAgc2VhdFZpZXcuc2NvcmUuc3RyaW5nID0gXCIrXCIgKyB1c2VyRGF0YS5zY29yZTsgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHNlYXRWaWV3LnNjb3JlLnN0cmluZyA9IHVzZXJEYXRhLnNjb3JlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8v6ZqQ6JeP5omA5pyJ54mMXHJcbiAgICAgICAgICAgIGZvcih2YXIgayA9IDA7IGsgPCBzZWF0Vmlldy5tYWhqb25ncy5jaGlsZHJlbkNvdW50OyArK2spe1xyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSBzZWF0Vmlldy5tYWhqb25ncy5jaGlsZHJlbltrXTtcclxuICAgICAgICAgICAgICAgIG4uYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNjLnZ2Lm1haGpvbmdtZ3Iuc29ydE1KKHVzZXJEYXRhLmhvbGRzLHVzZXJEYXRhLmRpbmdxdWUpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIG51bU9mR2FuZ3MgPSB1c2VyRGF0YS5hbmdhbmdzLmxlbmd0aCArIHVzZXJEYXRhLndhbmdhbmdzLmxlbmd0aCArIHVzZXJEYXRhLmRpYW5nYW5ncy5sZW5ndGg7XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBsYWNraW5nTnVtID0gKHVzZXJEYXRhLnBlbmdzLmxlbmd0aCArIG51bU9mR2FuZ3MpKjM7IFxyXG4gICAgICAgICAgICAvL+aYvuekuuebuOWFs+eahOeJjFxyXG4gICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgdXNlckRhdGEuaG9sZHMubGVuZ3RoOyArK2spe1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhaSA9IHVzZXJEYXRhLmhvbGRzW2tdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSBzZWF0Vmlldy5tYWhqb25ncy5jaGlsZHJlbltrICsgbGFja2luZ051bV07XHJcbiAgICAgICAgICAgICAgICBuLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gbi5nZXRDb21wb25lbnQoY2MuU3ByaXRlKTtcclxuICAgICAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0U3ByaXRlRnJhbWVCeU1KSUQoXCJNX1wiLHBhaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgc2VhdFZpZXcuX3BlbmdhbmRnYW5nLmxlbmd0aDsgKytrKXtcclxuICAgICAgICAgICAgICAgIHNlYXRWaWV3Ll9wZW5nYW5kZ2FuZ1trXS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy/liJ3lp4vljJbmnaDniYxcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICAgICAgdmFyIGdhbmdzID0gdXNlckRhdGEuYW5nYW5ncztcclxuICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IGdhbmdzLmxlbmd0aDsgKytrKXtcclxuICAgICAgICAgICAgICAgIHZhciBtamlkID0gZ2FuZ3Nba107XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRQZW5nQW5kR2FuZ3Moc2VhdFZpZXcsaW5kZXgsbWppZCxcImFuZ2FuZ1wiKTtcclxuICAgICAgICAgICAgICAgIGluZGV4Kys7ICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgZ2FuZ3MgPSB1c2VyRGF0YS5kaWFuZ2FuZ3M7XHJcbiAgICAgICAgICAgIGZvcih2YXIgayA9IDA7IGsgPCBnYW5ncy5sZW5ndGg7ICsrayl7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWppZCA9IGdhbmdzW2tdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0UGVuZ0FuZEdhbmdzKHNlYXRWaWV3LGluZGV4LG1qaWQsXCJkaWFuZ2FuZ1wiKTtcclxuICAgICAgICAgICAgICAgIGluZGV4Kys7ICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgZ2FuZ3MgPSB1c2VyRGF0YS53YW5nYW5ncztcclxuICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IGdhbmdzLmxlbmd0aDsgKytrKXtcclxuICAgICAgICAgICAgICAgIHZhciBtamlkID0gZ2FuZ3Nba107XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRQZW5nQW5kR2FuZ3Moc2VhdFZpZXcsaW5kZXgsbWppZCxcIndhbmdhbmdcIik7XHJcbiAgICAgICAgICAgICAgICBpbmRleCsrOyAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy/liJ3lp4vljJbnorDniYxcclxuICAgICAgICAgICAgdmFyIHBlbmdzID0gdXNlckRhdGEucGVuZ3NcclxuICAgICAgICAgICAgaWYocGVuZ3Mpe1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IHBlbmdzLmxlbmd0aDsgKytrKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWppZCA9IHBlbmdzW2tdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdFBlbmdBbmRHYW5ncyhzZWF0VmlldyxpbmRleCxtamlkLFwicGVuZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCsrOyAgICBcclxuICAgICAgICAgICAgICAgIH0gICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBpbml0UGVuZ0FuZEdhbmdzOmZ1bmN0aW9uKHNlYXRWaWV3LGluZGV4LG1qaWQsZmxhZyl7XHJcbiAgICAgICAgdmFyIHBncm9vdCA9IG51bGw7XHJcbiAgICAgICAgaWYoc2VhdFZpZXcuX3BlbmdhbmRnYW5nLmxlbmd0aCA8PSBpbmRleCl7XHJcbiAgICAgICAgICAgIHBncm9vdCA9IGNjLmluc3RhbnRpYXRlKGNjLnZ2Lm1haGpvbmdtZ3IucGVuZ1ByZWZhYlNlbGYpO1xyXG4gICAgICAgICAgICBzZWF0Vmlldy5fcGVuZ2FuZGdhbmcucHVzaChwZ3Jvb3QpO1xyXG4gICAgICAgICAgICBzZWF0Vmlldy5tYWhqb25ncy5hZGRDaGlsZChwZ3Jvb3QpOyAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgcGdyb290ID0gc2VhdFZpZXcuX3BlbmdhbmRnYW5nW2luZGV4XTtcclxuICAgICAgICAgICAgcGdyb290LmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICBcclxuICAgICAgICB2YXIgc3ByaXRlcyA9IHBncm9vdC5nZXRDb21wb25lbnRzSW5DaGlsZHJlbihjYy5TcHJpdGUpO1xyXG4gICAgICAgIGZvcih2YXIgcyA9IDA7IHMgPCBzcHJpdGVzLmxlbmd0aDsgKytzKXtcclxuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHNwcml0ZXNbc107XHJcbiAgICAgICAgICAgIGlmKHNwcml0ZS5ub2RlLm5hbWUgPT0gXCJnYW5nXCIpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzR2FuZyA9IGZsYWcgIT0gXCJwZW5nXCI7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGUubm9kZS5hY3RpdmUgPSBpc0dhbmc7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGUubm9kZS5zY2FsZVggPSAxLjA7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGUubm9kZS5zY2FsZVkgPSAxLjA7XHJcbiAgICAgICAgICAgICAgICBpZihmbGFnID09IFwiYW5nYW5nXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0RW1wdHlTcHJpdGVGcmFtZShcIm15c2VsZlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGUubm9kZS5zY2FsZVggPSAxLjQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlLm5vZGUuc2NhbGVZID0gMS40OyAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfSAgIFxyXG4gICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKFwiQl9cIixtamlkKTsgICAgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXsgXHJcbiAgICAgICAgICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKFwiQl9cIixtamlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwZ3Jvb3QueCA9IGluZGV4ICogNTUgKiAzICsgaW5kZXggKiAxMDtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uQnRuUmVhZHlDbGlja2VkOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJvbkJ0blJlYWR5Q2xpY2tlZFwiKTtcclxuICAgICAgICBpZih0aGlzLl9pc0dhbWVFbmQpe1xyXG4gICAgICAgICAgICB0aGlzLl9nYW1lcmVzdWx0LmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGNjLnZ2Lm5ldC5zZW5kKCdyZWFkeScpOyAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9nYW1lb3Zlci5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uQnRuU2hhcmVDbGlja2VkOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJvbkJ0blNoYXJlQ2xpY2tlZFwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xyXG4gICAgLy8gdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcclxuXHJcbiAgICAvLyB9LFxyXG59KTtcclxuIiwiY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAvLyBmb286IHtcclxuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLFxyXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcclxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXHJcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxyXG4gICAgICAgIC8vIH0sXHJcbiAgICAgICAgLy8gLi4uXHJcbiAgICAgICAgX2dhbWVyZXN1bHQ6bnVsbCxcclxuICAgICAgICBfc2VhdHM6W10sXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYoY2MudnYgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5fZ2FtZXJlc3VsdCA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImdhbWVfcmVzdWx0XCIpO1xyXG4gICAgICAgIC8vdGhpcy5fZ2FtZXJlc3VsdC5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgc2VhdHMgPSB0aGlzLl9nYW1lcmVzdWx0LmdldENoaWxkQnlOYW1lKFwic2VhdHNcIik7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNlYXRzLmNoaWxkcmVuLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdGhpcy5fc2VhdHMucHVzaChzZWF0cy5jaGlsZHJlbltpXS5nZXRDb21wb25lbnQoXCJTZWF0XCIpKTsgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGJ0bkNsb3NlID0gY2MuZmluZChcIkNhbnZhcy9nYW1lX3Jlc3VsdC9idG5DbG9zZVwiKTtcclxuICAgICAgICBpZihidG5DbG9zZSl7XHJcbiAgICAgICAgICAgIGNjLnZ2LnV0aWxzLmFkZENsaWNrRXZlbnQoYnRuQ2xvc2UsdGhpcy5ub2RlLFwiR2FtZVJlc3VsdFwiLFwib25CdG5DbG9zZUNsaWNrZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBidG5TaGFyZSA9IGNjLmZpbmQoXCJDYW52YXMvZ2FtZV9yZXN1bHQvYnRuU2hhcmVcIik7XHJcbiAgICAgICAgaWYoYnRuU2hhcmUpe1xyXG4gICAgICAgICAgICBjYy52di51dGlscy5hZGRDbGlja0V2ZW50KGJ0blNoYXJlLHRoaXMubm9kZSxcIkdhbWVSZXN1bHRcIixcIm9uQnRuU2hhcmVDbGlja2VkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvL+WIneWni+WMlue9kee7nOS6i+S7tuebkeWQrOWZqFxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfZW5kJyxmdW5jdGlvbihkYXRhKXtzZWxmLm9uR2FtZUVuZChkYXRhLmRldGFpbCk7fSk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzaG93UmVzdWx0OmZ1bmN0aW9uKHNlYXQsaW5mbyxpc1p1aUppYVBhb1Nob3Upe1xyXG4gICAgICAgIHNlYXQubm9kZS5nZXRDaGlsZEJ5TmFtZShcInp1aWppYXBhb3Nob3VcIikuYWN0aXZlID0gaXNadWlKaWFQYW9TaG91O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHNlYXQubm9kZS5nZXRDaGlsZEJ5TmFtZShcInppbW9jaXNodVwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IGluZm8ubnVtemltbztcclxuICAgICAgICBzZWF0Lm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJqaWVwYW9jaXNodVwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IGluZm8ubnVtamllcGFvO1xyXG4gICAgICAgIHNlYXQubm9kZS5nZXRDaGlsZEJ5TmFtZShcImRpYW5wYW9jaXNodVwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IGluZm8ubnVtZGlhbnBhbztcclxuICAgICAgICBzZWF0Lm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJhbmdhbmdjaXNodVwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IGluZm8ubnVtYW5nYW5nO1xyXG4gICAgICAgIHNlYXQubm9kZS5nZXRDaGlsZEJ5TmFtZShcIm1pbmdnYW5nY2lzaHVcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBpbmZvLm51bW1pbmdnYW5nO1xyXG4gICAgICAgIHNlYXQubm9kZS5nZXRDaGlsZEJ5TmFtZShcImNoYWppYW9jaXNodVwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IGluZm8ubnVtY2hhZGFqaWFvO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25HYW1lRW5kOmZ1bmN0aW9uKGVuZGluZm8pe1xyXG4gICAgICAgIHZhciBzZWF0cyA9IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdHM7XHJcbiAgICAgICAgdmFyIG1heHNjb3JlID0gLTE7XHJcbiAgICAgICAgdmFyIG1heGRpYW5wYW8gPSAwO1xyXG4gICAgICAgIHZhciBkaWFucGFvZ2Fvc2hvdSA9IC0xO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZWF0cy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBzZWF0ID0gc2VhdHNbaV07XHJcbiAgICAgICAgICAgIGlmKHNlYXQuc2NvcmUgPiBtYXhzY29yZSl7XHJcbiAgICAgICAgICAgICAgICBtYXhzY29yZSA9IHNlYXQuc2NvcmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoZW5kaW5mb1tpXS5udW1kaWFucGFvID4gbWF4ZGlhbnBhbyl7XHJcbiAgICAgICAgICAgICAgICBtYXhkaWFucGFvID0gZW5kaW5mb1tpXS5udW1kaWFucGFvO1xyXG4gICAgICAgICAgICAgICAgZGlhbnBhb2dhb3Nob3UgPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZWF0cy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBzZWF0ID0gc2VhdHNbaV07XHJcbiAgICAgICAgICAgIHZhciBpc0JpZ3dpbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZihzZWF0LnNjb3JlID4gMCl7XHJcbiAgICAgICAgICAgICAgICBpc0JpZ3dpbiA9IHNlYXQuc2NvcmUgPT0gbWF4c2NvcmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2VhdHNbaV0uc2V0SW5mbyhzZWF0Lm5hbWUsc2VhdC5zY29yZSwgaXNCaWd3aW4pO1xyXG4gICAgICAgICAgICB0aGlzLl9zZWF0c1tpXS5zZXRJRChzZWF0LnVzZXJpZCk7XHJcbiAgICAgICAgICAgIHZhciBpc1p1aUppYVBhb1Nob3UgPSBkaWFucGFvZ2Fvc2hvdSA9PSBpO1xyXG4gICAgICAgICAgICB0aGlzLnNob3dSZXN1bHQodGhpcy5fc2VhdHNbaV0sZW5kaW5mb1tpXSxpc1p1aUppYVBhb1Nob3UpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uQnRuQ2xvc2VDbGlja2VkOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MuZGlyZWN0b3IubG9hZFNjZW5lKFwiaGFsbFwiKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uQnRuU2hhcmVDbGlja2VkOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MudnYuYW55c2RrTWdyLnNoYXJlUmVzdWx0KCk7XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJ2YXIgR2xvYmFsID0gY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIGlzc3RhcnRlZDpmYWxzZSxcbiAgICAgICAgbmV0aW5pdGVkOmZhbHNlLFxuICAgICAgICB1c2VyZ3VpZDowLFxuICAgICAgICBuaWNrbmFtZTpcIlwiLFxuICAgICAgICBtb25leTowLFxuICAgICAgICBsdjowLFxuICAgICAgICByb29tSWQ6MCxcbiAgICB9LFxufSk7IiwiLy92YXIgVVJMID0gXCJodHRwOi8vMTE4Ljg5LjIzNS4zNDo5MDAwXCI7XHJcbi8vdmFyIFVSTCA9IFwiaHR0cDovLzEyMC4yNC4xODEuMTQ1OjkwMDBcIjtcclxuLy92YXIgVVJMID0gXCJodHRwOi8vMTIwLjI0LjU5LjcwOjkwMDBcIjtcclxudmFyIFVSTCA9IFwiaHR0cDovLzEyMS40MS40My4xMDQ6OTkwMFwiO1xyXG5cclxuY2MuVkVSU0lPTiA9IDIwMTYxMjI3O1xyXG52YXIgSFRUUCA9IGNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBzdGF0aWNzOntcclxuICAgICAgICBzZXNzaW9uSWQgOiAwLFxyXG4gICAgICAgIHVzZXJJZCA6IDAsXHJcbiAgICAgICAgbWFzdGVyX3VybDpVUkwsXHJcbiAgICAgICAgdXJsOlVSTCxcclxuICAgICAgICBzZW5kUmVxdWVzdCA6IGZ1bmN0aW9uKHBhdGgsZGF0YSxoYW5kbGVyLGV4dHJhVXJsKXtcclxuICAgICAgICAgICAgdmFyIHhociA9IGNjLmxvYWRlci5nZXRYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICB4aHIudGltZW91dCA9IDUwMDA7XHJcbiAgICAgICAgICAgIHZhciBzdHIgPSBcIj9cIjtcclxuICAgICAgICAgICAgZm9yKHZhciBrIGluIGRhdGEpe1xyXG4gICAgICAgICAgICAgICAgaWYoc3RyICE9IFwiP1wiKXtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gXCImXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gayArIFwiPVwiICsgZGF0YVtrXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihleHRyYVVybCA9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgIGV4dHJhVXJsID0gSFRUUC51cmw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlcXVlc3RVUkwgPSBleHRyYVVybCArIHBhdGggKyBlbmNvZGVVUkkoc3RyKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJSZXF1ZXN0VVJMOlwiICsgcmVxdWVzdFVSTCk7XHJcbiAgICAgICAgICAgIHhoci5vcGVuKFwiR0VUXCIscmVxdWVzdFVSTCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChjYy5zeXMuaXNOYXRpdmUpe1xyXG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHQtRW5jb2RpbmdcIixcImd6aXAsZGVmbGF0ZVwiLFwidGV4dC9odG1sO2NoYXJzZXQ9VVRGLThcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmKHhoci5yZWFkeVN0YXRlID09PSA0ICYmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJodHRwIHJlcyhcIisgeGhyLnJlc3BvbnNlVGV4dC5sZW5ndGggKyBcIik6XCIgKyB4aHIucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaGFuZGxlciAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKHJldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlICovXHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImVycjpcIiArIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2hhbmRsZXIobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNjLnZ2ICYmIGNjLnZ2LndjKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgY2MudnYud2MuaGlkZSgpOyAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKGNjLnZ2ICYmIGNjLnZ2LndjKXtcclxuICAgICAgICAgICAgICAgIC8vY2MudnYud2Muc2hvdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHhoci5zZW5kKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB4aHI7XHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcbn0pOyIsInZhciBOZXQgPSByZXF1aXJlKFwiTmV0XCIpXHJcbnZhciBHbG9iYWwgPSByZXF1aXJlKFwiR2xvYmFsXCIpXHJcbmNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgbGJsTmFtZTpjYy5MYWJlbCxcclxuICAgICAgICBsYmxNb25leTpjYy5MYWJlbCxcclxuICAgICAgICBsYmxHZW1zOmNjLkxhYmVsLFxyXG4gICAgICAgIGxibElEOmNjLkxhYmVsLFxyXG4gICAgICAgIGxibE5vdGljZTpjYy5MYWJlbCxcclxuICAgICAgICBqb2luR2FtZVdpbjpjYy5Ob2RlLFxyXG4gICAgICAgIGNyZWF0ZVJvb21XaW46Y2MuTm9kZSxcclxuICAgICAgICBzZXR0aW5nc1dpbjpjYy5Ob2RlLFxyXG4gICAgICAgIGhlbHBXaW46Y2MuTm9kZSxcclxuICAgICAgICB4aWFveGlXaW46Y2MuTm9kZSxcclxuICAgICAgICBidG5Kb2luR2FtZTpjYy5Ob2RlLFxyXG4gICAgICAgIGJ0blJldHVybkdhbWU6Y2MuTm9kZSxcclxuICAgICAgICBzcHJIZWFkSW1nOmNjLlNwcml0ZSxcclxuICAgICAgICAvLyBmb286IHtcclxuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLFxyXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcclxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXHJcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxyXG4gICAgICAgIC8vIH0sXHJcbiAgICAgICAgLy8gLi4uXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBpbml0TmV0SGFuZGxlcnM6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvblNoYXJlOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MudnYuYW55c2RrTWdyLnNoYXJlKFwi6L6+6L6+6bq75bCGXCIsXCLovr7ovr7purvlsIbvvIzljIXlkKvkuobooYDmiJjliLDlupXjgIHooYDmtYHmiJDmsrPnrYnlpJrnp43lm5vlt53mtYHooYzpurvlsIbnjqnms5XjgIJcIik7ICAgXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYoIWNjLnN5cy5pc05hdGl2ZSAmJiBjYy5zeXMuaXNNb2JpbGUpe1xyXG4gICAgICAgICAgICB2YXIgY3ZzID0gdGhpcy5ub2RlLmdldENvbXBvbmVudChjYy5DYW52YXMpO1xyXG4gICAgICAgICAgICBjdnMuZml0SGVpZ2h0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgY3ZzLmZpdFdpZHRoID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoIWNjLnZ2KXtcclxuICAgICAgICAgICAgY2MuZGlyZWN0b3IubG9hZFNjZW5lKFwibG9hZGluZ1wiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmluaXRMYWJlbHMoKTtcclxuICAgICAgICBcclxuICAgICAgICBpZihjYy52di5nYW1lTmV0TWdyLnJvb21JZCA9PSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5idG5Kb2luR2FtZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmJ0blJldHVybkdhbWUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuYnRuSm9pbkdhbWUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYnRuUmV0dXJuR2FtZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvL3ZhciBwYXJhbXMgPSBjYy52di5hcmdzO1xyXG4gICAgICAgIHZhciByb29tSWQgPSBjYy52di51c2VyTWdyLm9sZFJvb21JZCBcclxuICAgICAgICBpZiggcm9vbUlkICE9IG51bGwpe1xyXG4gICAgICAgICAgICBjYy52di51c2VyTWdyLm9sZFJvb21JZCA9IG51bGw7XHJcbiAgICAgICAgICAgIGNjLnZ2LnVzZXJNZ3IuZW50ZXJSb29tKHJvb21JZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBpbWdMb2FkZXIgPSB0aGlzLnNwckhlYWRJbWcubm9kZS5nZXRDb21wb25lbnQoXCJJbWFnZUxvYWRlclwiKTtcclxuICAgICAgICBpbWdMb2FkZXIuc2V0VXNlcklEKGNjLnZ2LnVzZXJNZ3IudXNlcklkKTtcclxuICAgICAgICBjYy52di51dGlscy5hZGRDbGlja0V2ZW50KHRoaXMuc3BySGVhZEltZy5ub2RlLHRoaXMubm9kZSxcIkhhbGxcIixcIm9uQnRuQ2xpY2tlZFwiKTtcclxuICAgICAgICBcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChcIlVzZXJJbmZvU2hvd1wiKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmluaXRCdXR0b25IYW5kbGVyKFwiQ2FudmFzL3JpZ2h0X2JvdHRvbS9idG5fc2hlemhpXCIpO1xyXG4gICAgICAgIHRoaXMuaW5pdEJ1dHRvbkhhbmRsZXIoXCJDYW52YXMvcmlnaHRfYm90dG9tL2J0bl9oZWxwXCIpO1xyXG4gICAgICAgIHRoaXMuaW5pdEJ1dHRvbkhhbmRsZXIoXCJDYW52YXMvcmlnaHRfYm90dG9tL2J0bl94aWFveGlcIik7XHJcbiAgICAgICAgdGhpcy5oZWxwV2luLmFkZENvbXBvbmVudChcIk9uQmFja1wiKTtcclxuICAgICAgICB0aGlzLnhpYW94aVdpbi5hZGRDb21wb25lbnQoXCJPbkJhY2tcIik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoIWNjLnZ2LnVzZXJNZ3Iubm90aWNlKXtcclxuICAgICAgICAgICAgY2MudnYudXNlck1nci5ub3RpY2UgPSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOm51bGwsXHJcbiAgICAgICAgICAgICAgICBtc2c6XCLmlbDmja7or7fmsYLkuK0uLi5cIixcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZighY2MudnYudXNlck1nci5nZW1zdGlwKXtcclxuICAgICAgICAgICAgY2MudnYudXNlck1nci5nZW1zdGlwID0ge1xyXG4gICAgICAgICAgICAgICAgdmVyc2lvbjpudWxsLFxyXG4gICAgICAgICAgICAgICAgbXNnOlwi5pWw5o2u6K+35rGC5LitLi4uXCIsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5sYmxOb3RpY2Uuc3RyaW5nID0gY2MudnYudXNlck1nci5ub3RpY2UubXNnO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMucmVmcmVzaEluZm8oKTtcclxuICAgICAgICB0aGlzLnJlZnJlc2hOb3RpY2UoKTtcclxuICAgICAgICB0aGlzLnJlZnJlc2hHZW1zVGlwKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MudnYuYXVkaW9NZ3IucGxheUJHTShcImJnTWFpbi5tcDNcIik7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICByZWZyZXNoSW5mbzpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgb25HZXQgPSBmdW5jdGlvbihyZXQpe1xyXG4gICAgICAgICAgICBpZihyZXQuZXJyY29kZSAhPT0gMCl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXQuZXJybXNnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgaWYocmV0LmdlbXMgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYmxHZW1zLnN0cmluZyA9IHJldC5nZW1zOyAgICBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgICAgICAgIGFjY291bnQ6Y2MudnYudXNlck1nci5hY2NvdW50LFxyXG4gICAgICAgICAgICBzaWduOmNjLnZ2LnVzZXJNZ3Iuc2lnbixcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNjLnZ2Lmh0dHAuc2VuZFJlcXVlc3QoXCIvZ2V0X3VzZXJfc3RhdHVzXCIsZGF0YSxvbkdldC5iaW5kKHRoaXMpKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHJlZnJlc2hHZW1zVGlwOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBvbkdldCA9IGZ1bmN0aW9uKHJldCl7XHJcbiAgICAgICAgICAgIGlmKHJldC5lcnJjb2RlICE9PSAwKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJldC5lcnJtc2cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBjYy52di51c2VyTWdyLmdlbXN0aXAudmVyc2lvbiA9IHJldC52ZXJzaW9uO1xyXG4gICAgICAgICAgICAgICAgY2MudnYudXNlck1nci5nZW1zdGlwLm1zZyA9IHJldC5tc2cucmVwbGFjZShcIjxuZXdsaW5lPlwiLFwiXFxuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgZGF0YSA9IHtcclxuICAgICAgICAgICAgYWNjb3VudDpjYy52di51c2VyTWdyLmFjY291bnQsXHJcbiAgICAgICAgICAgIHNpZ246Y2MudnYudXNlck1nci5zaWduLFxyXG4gICAgICAgICAgICB0eXBlOlwiZmtnbVwiLFxyXG4gICAgICAgICAgICB2ZXJzaW9uOmNjLnZ2LnVzZXJNZ3IuZ2Vtc3RpcC52ZXJzaW9uXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjYy52di5odHRwLnNlbmRSZXF1ZXN0KFwiL2dldF9tZXNzYWdlXCIsZGF0YSxvbkdldC5iaW5kKHRoaXMpKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHJlZnJlc2hOb3RpY2U6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG9uR2V0ID0gZnVuY3Rpb24ocmV0KXtcclxuICAgICAgICAgICAgaWYocmV0LmVycmNvZGUgIT09IDApe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmV0LmVycm1zZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGNjLnZ2LnVzZXJNZ3Iubm90aWNlLnZlcnNpb24gPSByZXQudmVyc2lvbjtcclxuICAgICAgICAgICAgICAgIGNjLnZ2LnVzZXJNZ3Iubm90aWNlLm1zZyA9IHJldC5tc2c7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxibE5vdGljZS5zdHJpbmcgPSByZXQubXNnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgZGF0YSA9IHtcclxuICAgICAgICAgICAgYWNjb3VudDpjYy52di51c2VyTWdyLmFjY291bnQsXHJcbiAgICAgICAgICAgIHNpZ246Y2MudnYudXNlck1nci5zaWduLFxyXG4gICAgICAgICAgICB0eXBlOlwibm90aWNlXCIsXHJcbiAgICAgICAgICAgIHZlcnNpb246Y2MudnYudXNlck1nci5ub3RpY2UudmVyc2lvblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY2MudnYuaHR0cC5zZW5kUmVxdWVzdChcIi9nZXRfbWVzc2FnZVwiLGRhdGEsb25HZXQuYmluZCh0aGlzKSk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBpbml0QnV0dG9uSGFuZGxlcjpmdW5jdGlvbihidG5QYXRoKXtcclxuICAgICAgICB2YXIgYnRuID0gY2MuZmluZChidG5QYXRoKTtcclxuICAgICAgICBjYy52di51dGlscy5hZGRDbGlja0V2ZW50KGJ0bix0aGlzLm5vZGUsXCJIYWxsXCIsXCJvbkJ0bkNsaWNrZWRcIik7ICAgICAgICBcclxuICAgIH0sXHJcbiAgICBcclxuICAgIFxyXG4gICAgXHJcbiAgICBpbml0TGFiZWxzOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5sYmxOYW1lLnN0cmluZyA9IGNjLnZ2LnVzZXJNZ3IudXNlck5hbWU7XHJcbiAgICAgICAgdGhpcy5sYmxNb25leS5zdHJpbmcgPSBjYy52di51c2VyTWdyLmNvaW5zO1xyXG4gICAgICAgIHRoaXMubGJsR2Vtcy5zdHJpbmcgPSBjYy52di51c2VyTWdyLmdlbXM7XHJcbiAgICAgICAgdGhpcy5sYmxJRC5zdHJpbmcgPSBcIklEOlwiICsgY2MudnYudXNlck1nci51c2VySWQ7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbkJ0bkNsaWNrZWQ6ZnVuY3Rpb24oZXZlbnQpe1xyXG4gICAgICAgIGlmKGV2ZW50LnRhcmdldC5uYW1lID09IFwiYnRuX3NoZXpoaVwiKXtcclxuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc1dpbi5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIH0gICBcclxuICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldC5uYW1lID09IFwiYnRuX2hlbHBcIil7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscFdpbi5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldC5uYW1lID09IFwiYnRuX3hpYW94aVwiKXtcclxuICAgICAgICAgICAgdGhpcy54aWFveGlXaW4uYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihldmVudC50YXJnZXQubmFtZSA9PSBcImhlYWRcIil7XHJcbiAgICAgICAgICAgIGNjLnZ2LnVzZXJpbmZvU2hvdy5zaG93KGNjLnZ2LnVzZXJNZ3IudXNlck5hbWUsY2MudnYudXNlck1nci51c2VySWQsdGhpcy5zcHJIZWFkSW1nLGNjLnZ2LnVzZXJNZ3Iuc2V4LGNjLnZ2LnVzZXJNZ3IuaXApO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uSm9pbkdhbWVDbGlja2VkOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5qb2luR2FtZVdpbi5hY3RpdmUgPSB0cnVlO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25SZXR1cm5HYW1lQ2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLmRpcmVjdG9yLmxvYWRTY2VuZShcIm1qZ2FtZVwiKTsgIFxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25CdG5BZGRHZW1zQ2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLnZ2LmFsZXJ0LnNob3coXCLmj5DnpLpcIixjYy52di51c2VyTWdyLmdlbXN0aXAubXNnKTtcclxuICAgICAgICB0aGlzLnJlZnJlc2hJbmZvKCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbkNyZWF0ZVJvb21DbGlja2VkOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYoY2MudnYuZ2FtZU5ldE1nci5yb29tSWQgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgIGNjLnZ2LmFsZXJ0LnNob3coXCLmj5DnpLpcIixcIuaIv+mXtOW3sue7j+WIm+W7uiFcXG7lv4Xpobvop6PmlaPlvZPliY3miL/pl7TmiY3og73liJvlu7rmlrDnmoTmiL/pl7RcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJvbkNyZWF0ZVJvb21DbGlja2VkXCIpO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlUm9vbVdpbi5hY3RpdmUgPSB0cnVlOyAgIFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcclxuICAgICAgICB2YXIgeCA9IHRoaXMubGJsTm90aWNlLm5vZGUueDtcclxuICAgICAgICB4IC09IGR0KjEwMDtcclxuICAgICAgICBpZih4ICsgdGhpcy5sYmxOb3RpY2Uubm9kZS53aWR0aCA8IC0xMDAwKXtcclxuICAgICAgICAgICAgeCA9IDUwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sYmxOb3RpY2Uubm9kZS54ID0geDtcclxuICAgICAgICBcclxuICAgICAgICBpZihjYy52diAmJiBjYy52di51c2VyTWdyLnJvb21EYXRhICE9IG51bGwpe1xyXG4gICAgICAgICAgICBjYy52di51c2VyTWdyLmVudGVyUm9vbShjYy52di51c2VyTWdyLnJvb21EYXRhKTtcclxuICAgICAgICAgICAgY2MudnYudXNlck1nci5yb29tRGF0YSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxufSk7XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgSGlzdG9yeUl0ZW1QcmVmYWI6e1xyXG4gICAgICAgICAgICBkZWZhdWx0Om51bGwsXHJcbiAgICAgICAgICAgIHR5cGU6Y2MuUHJlZmFiLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCxcclxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XHJcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxyXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcclxuICAgICAgICAvLyB9LFxyXG4gICAgICAgIC8vIC4uLlxyXG4gICAgICAgIF9oaXN0b3J5Om51bGwsXHJcbiAgICAgICAgX3ZpZXdsaXN0Om51bGwsXHJcbiAgICAgICAgX2NvbnRlbnQ6bnVsbCxcclxuICAgICAgICBfdmlld2l0ZW1UZW1wOm51bGwsXHJcbiAgICAgICAgX2hpc3RvcnlEYXRhOm51bGwsXHJcbiAgICAgICAgX2N1clJvb21JbmZvOm51bGwsXHJcbiAgICAgICAgX2VtcHR5VGlwOm51bGwsXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5faGlzdG9yeSA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImhpc3RvcnlcIik7XHJcbiAgICAgICAgdGhpcy5faGlzdG9yeS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9lbXB0eVRpcCA9IHRoaXMuX2hpc3RvcnkuZ2V0Q2hpbGRCeU5hbWUoXCJlbXB0eVRpcFwiKTtcclxuICAgICAgICB0aGlzLl9lbXB0eVRpcC5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX3ZpZXdsaXN0ID0gdGhpcy5faGlzdG9yeS5nZXRDaGlsZEJ5TmFtZShcInZpZXdsaXN0XCIpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjYy5maW5kKFwidmlldy9jb250ZW50XCIsdGhpcy5fdmlld2xpc3QpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX3ZpZXdpdGVtVGVtcCA9IHRoaXMuX2NvbnRlbnQuY2hpbGRyZW5bMF07XHJcbiAgICAgICAgdGhpcy5fY29udGVudC5yZW1vdmVDaGlsZCh0aGlzLl92aWV3aXRlbVRlbXApO1xyXG5cclxuICAgICAgICB2YXIgbm9kZSA9IGNjLmZpbmQoXCJDYW52YXMvYnRuX3poYW5qaVwiKTsgICAgICAgIFxyXG4gICAgICAgIHRoaXMuYWRkQ2xpY2tFdmVudChub2RlLHRoaXMubm9kZSxcIkhpc3RvcnlcIixcIm9uQnRuSGlzdG9yeUNsaWNrZWRcIik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG5vZGUgPSBjYy5maW5kKFwiQ2FudmFzL2hpc3RvcnkvYnRuX2JhY2tcIik7ICBcclxuICAgICAgICB0aGlzLmFkZENsaWNrRXZlbnQobm9kZSx0aGlzLm5vZGUsXCJIaXN0b3J5XCIsXCJvbkJ0bkJhY2tDbGlja2VkXCIpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgYWRkQ2xpY2tFdmVudDpmdW5jdGlvbihub2RlLHRhcmdldCxjb21wb25lbnQsaGFuZGxlcil7XHJcbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlciA9IG5ldyBjYy5Db21wb25lbnQuRXZlbnRIYW5kbGVyKCk7XHJcbiAgICAgICAgZXZlbnRIYW5kbGVyLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICBldmVudEhhbmRsZXIuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIGV2ZW50SGFuZGxlci5oYW5kbGVyID0gaGFuZGxlcjtcclxuXHJcbiAgICAgICAgdmFyIGNsaWNrRXZlbnRzID0gbm9kZS5nZXRDb21wb25lbnQoY2MuQnV0dG9uKS5jbGlja0V2ZW50cztcclxuICAgICAgICBjbGlja0V2ZW50cy5wdXNoKGV2ZW50SGFuZGxlcik7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbkJ0bkJhY2tDbGlja2VkOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYodGhpcy5fY3VyUm9vbUluZm8gPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHRoaXMuX2hpc3RvcnlEYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5faGlzdG9yeS5hY3RpdmUgPSBmYWxzZTsgICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5pbml0Um9vbUhpc3RvcnlMaXN0KHRoaXMuX2hpc3RvcnlEYXRhKTsgICBcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbkJ0bkhpc3RvcnlDbGlja2VkOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5faGlzdG9yeS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICBjYy52di51c2VyTWdyLmdldEhpc3RvcnlMaXN0KGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBkYXRhLnNvcnQoZnVuY3Rpb24oYSxiKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLnRpbWUgPCBiLnRpbWU7IFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2VsZi5faGlzdG9yeURhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgNDsgKytqKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGRhdGFbaV0uc2VhdHNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgcy5uYW1lID0gbmV3IEJ1ZmZlcihzLm5hbWUsJ2Jhc2U2NCcpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5pbml0Um9vbUhpc3RvcnlMaXN0KGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgZGF0ZUZvcm1hdDpmdW5jdGlvbih0aW1lKXtcclxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHRpbWUpO1xyXG4gICAgICAgIHZhciBkYXRldGltZSA9IFwiezB9LXsxfS17Mn0gezN9Ons0fTp7NX1cIjtcclxuICAgICAgICB2YXIgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICB2YXIgbW9udGggPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xyXG4gICAgICAgIG1vbnRoID0gbW9udGggPj0gMTA/IG1vbnRoIDogKFwiMFwiK21vbnRoKTtcclxuICAgICAgICB2YXIgZGF5ID0gZGF0ZS5nZXREYXRlKCk7XHJcbiAgICAgICAgZGF5ID0gZGF5ID49IDEwPyBkYXkgOiAoXCIwXCIrZGF5KTtcclxuICAgICAgICB2YXIgaCA9IGRhdGUuZ2V0SG91cnMoKTtcclxuICAgICAgICBoID0gaCA+PSAxMD8gaCA6IChcIjBcIitoKTtcclxuICAgICAgICB2YXIgbSA9IGRhdGUuZ2V0TWludXRlcygpO1xyXG4gICAgICAgIG0gPSBtID49IDEwPyBtIDogKFwiMFwiK20pO1xyXG4gICAgICAgIHZhciBzID0gZGF0ZS5nZXRTZWNvbmRzKCk7XHJcbiAgICAgICAgcyA9IHMgPj0gMTA/IHMgOiAoXCIwXCIrcyk7XHJcbiAgICAgICAgZGF0ZXRpbWUgPSBkYXRldGltZS5mb3JtYXQoeWVhcixtb250aCxkYXksaCxtLHMpO1xyXG4gICAgICAgIHJldHVybiBkYXRldGltZTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGluaXRSb29tSGlzdG9yeUxpc3Q6ZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0Vmlld0l0ZW0oaSk7XHJcbiAgICAgICAgICAgIG5vZGUuaWR4ID0gaTtcclxuICAgICAgICAgICAgdmFyIHRpdGxlSWQgPSBcIlwiICsgKGkgKyAxKTtcclxuICAgICAgICAgICAgbm9kZS5nZXRDaGlsZEJ5TmFtZShcInRpdGxlXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gdGl0bGVJZDtcclxuICAgICAgICAgICAgbm9kZS5nZXRDaGlsZEJ5TmFtZShcInJvb21Ob1wiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IFwi5oi/6Ze0SUQ6XCIgKyBkYXRhW2ldLmlkO1xyXG4gICAgICAgICAgICB2YXIgZGF0ZXRpbWUgPSB0aGlzLmRhdGVGb3JtYXQoZGF0YVtpXS50aW1lICogMTAwMCk7XHJcbiAgICAgICAgICAgIG5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJ0aW1lXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gZGF0ZXRpbWU7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgYnRuT3AgPSBub2RlLmdldENoaWxkQnlOYW1lKFwiYnRuT3BcIik7XHJcbiAgICAgICAgICAgIGJ0bk9wLmlkeCA9IGk7XHJcbiAgICAgICAgICAgIGJ0bk9wLmdldENoaWxkQnlOYW1lKFwiTGFiZWxcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBcIuivpuaDhVwiO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IDQ7ICsrail7XHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IGRhdGFbaV0uc2VhdHNbal07XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IHMubmFtZSArIFwiOlwiICsgIHMuc2NvcmU7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGluZm8pO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5nZXRDaGlsZEJ5TmFtZShcImluZm9cIiArIGopLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gaW5mbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9lbXB0eVRpcC5hY3RpdmUgPSBkYXRhLmxlbmd0aCA9PSAwO1xyXG4gICAgICAgIHRoaXMuc2hyaW5rQ29udGVudChkYXRhLmxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5fY3VyUm9vbUluZm8gPSBudWxsO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgaW5pdEdhbWVIaXN0b3J5TGlzdDpmdW5jdGlvbihyb29tSW5mbyxkYXRhKXtcclxuICAgICAgICBkYXRhLnNvcnQoZnVuY3Rpb24oYSxiKXtcclxuICAgICAgICAgICByZXR1cm4gYS5jcmVhdGVfdGltZSA8IGIuY3JlYXRlX3RpbWU7IFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldFZpZXdJdGVtKGkpO1xyXG4gICAgICAgICAgICB2YXIgaWR4ID0gZGF0YS5sZW5ndGggLSBpIC0gMTtcclxuICAgICAgICAgICAgbm9kZS5pZHggPSBpZHg7XHJcbiAgICAgICAgICAgIHZhciB0aXRsZUlkID0gXCJcIiArIChpZHggKyAxKTtcclxuICAgICAgICAgICAgbm9kZS5nZXRDaGlsZEJ5TmFtZShcInRpdGxlXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gdGl0bGVJZDtcclxuICAgICAgICAgICAgbm9kZS5nZXRDaGlsZEJ5TmFtZShcInJvb21Ob1wiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IFwi5oi/6Ze0SUQ6XCIgKyByb29tSW5mby5pZDtcclxuICAgICAgICAgICAgdmFyIGRhdGV0aW1lID0gdGhpcy5kYXRlRm9ybWF0KGRhdGFbaV0uY3JlYXRlX3RpbWUgKiAxMDAwKTtcclxuICAgICAgICAgICAgbm9kZS5nZXRDaGlsZEJ5TmFtZShcInRpbWVcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBkYXRldGltZTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBidG5PcCA9IG5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJidG5PcFwiKTtcclxuICAgICAgICAgICAgYnRuT3AuaWR4ID0gaWR4OyBcclxuICAgICAgICAgICAgYnRuT3AuZ2V0Q2hpbGRCeU5hbWUoXCJMYWJlbFwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IFwi5Zue5pS+XCI7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gSlNPTi5wYXJzZShkYXRhW2ldLnJlc3VsdCk7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCA0OyArK2ope1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSByb29tSW5mby5zZWF0c1tqXTtcclxuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gcy5uYW1lICsgXCI6XCIgKyByZXN1bHRbal07XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGluZm8pO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5nZXRDaGlsZEJ5TmFtZShcImluZm9cIiArIGopLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gaW5mbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNocmlua0NvbnRlbnQoZGF0YS5sZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX2N1clJvb21JbmZvID0gcm9vbUluZm87XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBnZXRWaWV3SXRlbTpmdW5jdGlvbihpbmRleCl7XHJcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLl9jb250ZW50O1xyXG4gICAgICAgIGlmKGNvbnRlbnQuY2hpbGRyZW5Db3VudCA+IGluZGV4KXtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQuY2hpbGRyZW5baW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbm9kZSA9IGNjLmluc3RhbnRpYXRlKHRoaXMuX3ZpZXdpdGVtVGVtcCk7XHJcbiAgICAgICAgY29udGVudC5hZGRDaGlsZChub2RlKTtcclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH0sXHJcbiAgICBzaHJpbmtDb250ZW50OmZ1bmN0aW9uKG51bSl7XHJcbiAgICAgICAgd2hpbGUodGhpcy5fY29udGVudC5jaGlsZHJlbkNvdW50ID4gbnVtKXtcclxuICAgICAgICAgICAgdmFyIGxhc3RPbmUgPSB0aGlzLl9jb250ZW50LmNoaWxkcmVuW3RoaXMuX2NvbnRlbnQuY2hpbGRyZW5Db3VudCAtMV07XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnQucmVtb3ZlQ2hpbGQobGFzdE9uZSx0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBnZXRHYW1lTGlzdE9mUm9vbTpmdW5jdGlvbihpZHgpe1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgcm9vbUluZm8gPSB0aGlzLl9oaXN0b3J5RGF0YVtpZHhdOyAgICAgICAgXHJcbiAgICAgICAgY2MudnYudXNlck1nci5nZXRHYW1lc09mUm9vbShyb29tSW5mby51dWlkLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBpZihkYXRhICE9IG51bGwgJiYgZGF0YS5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgICAgIHNlbGYuaW5pdEdhbWVIaXN0b3J5TGlzdChyb29tSW5mbyxkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgZ2V0RGV0YWlsT2ZHYW1lOmZ1bmN0aW9uKGlkeCl7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciByb29tVVVJRCA9IHRoaXMuX2N1clJvb21JbmZvLnV1aWQ7XHJcbiAgICAgICAgY2MudnYudXNlck1nci5nZXREZXRhaWxPZkdhbWUocm9vbVVVSUQsaWR4LGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBkYXRhLmJhc2VfaW5mbyA9IEpTT04ucGFyc2UoZGF0YS5iYXNlX2luZm8pO1xyXG4gICAgICAgICAgICBkYXRhLmFjdGlvbl9yZWNvcmRzID0gSlNPTi5wYXJzZShkYXRhLmFjdGlvbl9yZWNvcmRzKTtcclxuICAgICAgICAgICAgY2MudnYuZ2FtZU5ldE1nci5wcmVwYXJlUmVwbGF5KHNlbGYuX2N1clJvb21JbmZvLGRhdGEpO1xyXG4gICAgICAgICAgICBjYy52di5yZXBsYXlNZ3IuaW5pdChkYXRhKTtcclxuICAgICAgICAgICAgY2MuZGlyZWN0b3IubG9hZFNjZW5lKFwibWpnYW1lXCIpOyBcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uVmlld0l0ZW1DbGlja2VkOmZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICB2YXIgaWR4ID0gZXZlbnQudGFyZ2V0LmlkeDtcclxuICAgICAgICBjb25zb2xlLmxvZyhpZHgpO1xyXG4gICAgICAgIGlmKHRoaXMuX2N1clJvb21JbmZvID09IG51bGwpe1xyXG4gICAgICAgICAgICB0aGlzLmdldEdhbWVMaXN0T2ZSb29tKGlkeCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0RGV0YWlsT2ZHYW1lKGlkeCk7ICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25CdG5PcENsaWNrZWQ6ZnVuY3Rpb24oZXZlbnQpe1xyXG4gICAgICAgIHZhciBpZHggPSBldmVudC50YXJnZXQucGFyZW50LmlkeDtcclxuICAgICAgICBjb25zb2xlLmxvZyhpZHgpO1xyXG4gICAgICAgIGlmKHRoaXMuX2N1clJvb21JbmZvID09IG51bGwpe1xyXG4gICAgICAgICAgICB0aGlzLmdldEdhbWVMaXN0T2ZSb29tKGlkeCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0RGV0YWlsT2ZHYW1lKGlkeCk7ICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xyXG4gICAgLy8gdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcclxuXHJcbiAgICAvLyB9LFxyXG59KTtcclxuIiwiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgdXBkYXRlUGFuZWw6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICB0eXBlOiBjYy5Ob2RlXG4gICAgICAgIH0sXG4gICAgICAgIG1hbmlmZXN0VXJsOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgdXJsOiBjYy5SYXdBc3NldFxuICAgICAgICB9LFxuICAgICAgICBwZXJjZW50OiB7XG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgdHlwZTogY2MuTGFiZWxcbiAgICAgICAgfSxcbiAgICAgICAgbGJsRXJyOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgdHlwZTogY2MuTGFiZWxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjaGVja0NiOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgY2MubG9nKCdDb2RlOiAnICsgZXZlbnQuZ2V0RXZlbnRDb2RlKCkpO1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmdldEV2ZW50Q29kZSgpKVxuICAgICAgICB7XG4gICAgICAgICAgICBjYXNlIGpzYi5FdmVudEFzc2V0c01hbmFnZXIuRVJST1JfTk9fTE9DQUxfTUFOSUZFU1Q6XG4gICAgICAgICAgICAgICAgY2MubG9nKFwiTm8gbG9jYWwgbWFuaWZlc3QgZmlsZSBmb3VuZCwgaG90IHVwZGF0ZSBza2lwcGVkLlwiKTtcbiAgICAgICAgICAgICAgICBjYy5ldmVudE1hbmFnZXIucmVtb3ZlTGlzdGVuZXIodGhpcy5fY2hlY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGpzYi5FdmVudEFzc2V0c01hbmFnZXIuRVJST1JfRE9XTkxPQURfTUFOSUZFU1Q6XG4gICAgICAgICAgICBjYXNlIGpzYi5FdmVudEFzc2V0c01hbmFnZXIuRVJST1JfUEFSU0VfTUFOSUZFU1Q6XG4gICAgICAgICAgICAgICAgY2MubG9nKFwiRmFpbCB0byBkb3dubG9hZCBtYW5pZmVzdCBmaWxlLCBob3QgdXBkYXRlIHNraXBwZWQuXCIpO1xuICAgICAgICAgICAgICAgIGNjLmV2ZW50TWFuYWdlci5yZW1vdmVMaXN0ZW5lcih0aGlzLl9jaGVja0xpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UganNiLkV2ZW50QXNzZXRzTWFuYWdlci5BTFJFQURZX1VQX1RPX0RBVEU6XG4gICAgICAgICAgICAgICAgY2MubG9nKFwiQWxyZWFkeSB1cCB0byBkYXRlIHdpdGggdGhlIGxhdGVzdCByZW1vdGUgdmVyc2lvbi5cIik7XG4gICAgICAgICAgICAgICAgY2MuZXZlbnRNYW5hZ2VyLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2NoZWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMubGJsRXJyLnN0cmluZyArPSBcIua4uOaIj+S4jemcgOimgeabtOaWsFxcblwiO1xuICAgICAgICAgICAgICAgIGNjLmRpcmVjdG9yLmxvYWRTY2VuZShcImxvYWRpbmdcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGpzYi5FdmVudEFzc2V0c01hbmFnZXIuTkVXX1ZFUlNJT05fRk9VTkQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQYW5lbC5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucGVyY2VudC5zdHJpbmcgPSAnMDAuMDAlJztcbiAgICAgICAgICAgICAgICBjYy5ldmVudE1hbmFnZXIucmVtb3ZlTGlzdGVuZXIodGhpcy5fY2hlY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaG90VXBkYXRlKCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZUNiOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIG5lZWRSZXN0YXJ0ID0gZmFsc2U7XG4gICAgICAgIHZhciBmYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChldmVudC5nZXRFdmVudENvZGUoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgY2FzZSBqc2IuRXZlbnRBc3NldHNNYW5hZ2VyLkVSUk9SX05PX0xPQ0FMX01BTklGRVNUOlxuICAgICAgICAgICAgICAgIGNjLmxvZygnTm8gbG9jYWwgbWFuaWZlc3QgZmlsZSBmb3VuZCwgaG90IHVwZGF0ZSBza2lwcGVkLicpO1xuICAgICAgICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGpzYi5FdmVudEFzc2V0c01hbmFnZXIuVVBEQVRFX1BST0dSRVNTSU9OOlxuICAgICAgICAgICAgICAgIHZhciBwZXJjZW50ID0gZXZlbnQuZ2V0UGVyY2VudCgpO1xuICAgICAgICAgICAgICAgIHZhciBwZXJjZW50QnlGaWxlID0gZXZlbnQuZ2V0UGVyY2VudEJ5RmlsZSgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IGV2ZW50LmdldE1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICBpZiAobXNnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNjLmxvZyhtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYy5sb2cocGVyY2VudC50b0ZpeGVkKDIpICsgJyUnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmNlbnQuc3RyaW5nID0gcGVyY2VudCArICclJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UganNiLkV2ZW50QXNzZXRzTWFuYWdlci5FUlJPUl9ET1dOTE9BRF9NQU5JRkVTVDpcbiAgICAgICAgICAgIGNhc2UganNiLkV2ZW50QXNzZXRzTWFuYWdlci5FUlJPUl9QQVJTRV9NQU5JRkVTVDpcbiAgICAgICAgICAgICAgICBjYy5sb2coJ0ZhaWwgdG8gZG93bmxvYWQgbWFuaWZlc3QgZmlsZSwgaG90IHVwZGF0ZSBza2lwcGVkLicpO1xuICAgICAgICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGpzYi5FdmVudEFzc2V0c01hbmFnZXIuQUxSRUFEWV9VUF9UT19EQVRFOlxuICAgICAgICAgICAgICAgIGNjLmxvZygnQWxyZWFkeSB1cCB0byBkYXRlIHdpdGggdGhlIGxhdGVzdCByZW1vdGUgdmVyc2lvbi4nKTtcbiAgICAgICAgICAgICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBqc2IuRXZlbnRBc3NldHNNYW5hZ2VyLlVQREFURV9GSU5JU0hFRDpcbiAgICAgICAgICAgICAgICBjYy5sb2coJ1VwZGF0ZSBmaW5pc2hlZC4gJyArIGV2ZW50LmdldE1lc3NhZ2UoKSk7XG5cbiAgICAgICAgICAgICAgICBuZWVkUmVzdGFydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGpzYi5FdmVudEFzc2V0c01hbmFnZXIuVVBEQVRFX0ZBSUxFRDpcbiAgICAgICAgICAgICAgICBjYy5sb2coJ1VwZGF0ZSBmYWlsZWQuICcgKyBldmVudC5nZXRNZXNzYWdlKCkpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZmFpbENvdW50ICsrO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9mYWlsQ291bnQgPCA1KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW0uZG93bmxvYWRGYWlsZWRBc3NldHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2MubG9nKCdSZWFjaCBtYXhpbXVtIGZhaWwgY291bnQsIGV4aXQgdXBkYXRlIHByb2Nlc3MnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFpbENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGpzYi5FdmVudEFzc2V0c01hbmFnZXIuRVJST1JfVVBEQVRJTkc6XG4gICAgICAgICAgICAgICAgY2MubG9nKCdBc3NldCB1cGRhdGUgZXJyb3I6ICcgKyBldmVudC5nZXRBc3NldElkKCkgKyAnLCAnICsgZXZlbnQuZ2V0TWVzc2FnZSgpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UganNiLkV2ZW50QXNzZXRzTWFuYWdlci5FUlJPUl9ERUNPTVBSRVNTOlxuICAgICAgICAgICAgICAgIGNjLmxvZyhldmVudC5nZXRNZXNzYWdlKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmYWlsZWQpIHtcbiAgICAgICAgICAgIGNjLmV2ZW50TWFuYWdlci5yZW1vdmVMaXN0ZW5lcih0aGlzLl91cGRhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBhbmVsLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5lZWRSZXN0YXJ0KSB7XG4gICAgICAgICAgICBjYy5ldmVudE1hbmFnZXIucmVtb3ZlTGlzdGVuZXIodGhpcy5fdXBkYXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgLy8gUHJlcGVuZCB0aGUgbWFuaWZlc3QncyBzZWFyY2ggcGF0aFxuICAgICAgICAgICAgdmFyIHNlYXJjaFBhdGhzID0ganNiLmZpbGVVdGlscy5nZXRTZWFyY2hQYXRocygpO1xuICAgICAgICAgICAgdmFyIG5ld1BhdGhzID0gdGhpcy5fYW0uZ2V0TG9jYWxNYW5pZmVzdCgpLmdldFNlYXJjaFBhdGhzKCk7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdChzZWFyY2hQYXRocywgbmV3UGF0aHMpO1xuICAgICAgICAgICAgLy8gVGhpcyB2YWx1ZSB3aWxsIGJlIHJldHJpZXZlZCBhbmQgYXBwZW5kZWQgdG8gdGhlIGRlZmF1bHQgc2VhcmNoIHBhdGggZHVyaW5nIGdhbWUgc3RhcnR1cCxcbiAgICAgICAgICAgIC8vIHBsZWFzZSByZWZlciB0byBzYW1wbGVzL2pzLXRlc3RzL21haW4uanMgZm9yIGRldGFpbGVkIHVzYWdlLlxuICAgICAgICAgICAgLy8gISEhIFJlLWFkZCB0aGUgc2VhcmNoIHBhdGhzIGluIG1haW4uanMgaXMgdmVyeSBpbXBvcnRhbnQsIG90aGVyd2lzZSwgbmV3IHNjcmlwdHMgd29uJ3QgdGFrZSBlZmZlY3QuXG4gICAgICAgICAgICBjYy5zeXMubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ0hvdFVwZGF0ZVNlYXJjaFBhdGhzJywgSlNPTi5zdHJpbmdpZnkoc2VhcmNoUGF0aHMpKTtcblxuICAgICAgICAgICAganNiLmZpbGVVdGlscy5zZXRTZWFyY2hQYXRocyhzZWFyY2hQYXRocyk7XG4gICAgICAgICAgICB0aGlzLmxibEVyci5zdHJpbmcgKz0gXCLmuLjmiI/otYTmupDmm7TmlrDlrozmr5VcXG5cIjtcbiAgICAgICAgICAgIGNjLmdhbWUucmVzdGFydCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGhvdFVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fYW0gJiYgdGhpcy5fbmVlZFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5sYmxFcnIuc3RyaW5nICs9IFwi5byA5aeL5pu05paw5ri45oiP6LWE5rqQLi4uXFxuXCI7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMaXN0ZW5lciA9IG5ldyBqc2IuRXZlbnRMaXN0ZW5lckFzc2V0c01hbmFnZXIodGhpcy5fYW0sIHRoaXMudXBkYXRlQ2IuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICBjYy5ldmVudE1hbmFnZXIuYWRkTGlzdGVuZXIodGhpcy5fdXBkYXRlTGlzdGVuZXIsIDEpO1xuXG4gICAgICAgICAgICB0aGlzLl9mYWlsQ291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5fYW0udXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEhvdCB1cGRhdGUgaXMgb25seSBhdmFpbGFibGUgaW4gTmF0aXZlIGJ1aWxkXG4gICAgICAgIGlmICghY2Muc3lzLmlzTmF0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYmxFcnIuc3RyaW5nICs9IFwi5qOA5p+l5ri45oiP6LWE5rqQLi4uXFxuXCI7XG4gICAgICAgIHZhciBzdG9yYWdlUGF0aCA9ICgoanNiLmZpbGVVdGlscyA/IGpzYi5maWxlVXRpbHMuZ2V0V3JpdGFibGVQYXRoKCkgOiAnLycpICsgJ3RpYW50aWFucWlwYWktYXNzZXQnKTtcbiAgICAgICAgY2MubG9nKCdTdG9yYWdlIHBhdGggZm9yIHJlbW90ZSBhc3NldCA6ICcgKyBzdG9yYWdlUGF0aCk7XG4gICAgICAgIHRoaXMubGJsRXJyLnN0cmluZyArPSBzdG9yYWdlUGF0aCArIFwiXFxuXCI7XG4gICAgICAgIGNjLmxvZygnTG9jYWwgbWFuaWZlc3QgVVJMIDogJyArIHRoaXMubWFuaWZlc3RVcmwpO1xuICAgICAgICB0aGlzLl9hbSA9IG5ldyBqc2IuQXNzZXRzTWFuYWdlcih0aGlzLm1hbmlmZXN0VXJsLCBzdG9yYWdlUGF0aCk7XG4gICAgICAgIHRoaXMuX2FtLnJldGFpbigpO1xuXG4gICAgICAgIHRoaXMuX25lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2FtLmdldExvY2FsTWFuaWZlc3QoKS5pc0xvYWRlZCgpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja0xpc3RlbmVyID0gbmV3IGpzYi5FdmVudExpc3RlbmVyQXNzZXRzTWFuYWdlcih0aGlzLl9hbSwgdGhpcy5jaGVja0NiLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgY2MuZXZlbnRNYW5hZ2VyLmFkZExpc3RlbmVyKHRoaXMuX2NoZWNrTGlzdGVuZXIsIDEpO1xuXG4gICAgICAgICAgICB0aGlzLl9hbS5jaGVja1VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uRGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9hbSAmJiB0aGlzLl9hbS5yZWxlYXNlKCk7XG4gICAgfVxufSk7XG4iLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIC8vIGZvbzoge1xyXG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgY29tcG9uZW50IGF0dGFjaGluZ1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYSBub2RlIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcclxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXHJcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxyXG4gICAgICAgIC8vIH0sXHJcbiAgICAgICAgLy8gLi4uXHJcbiAgICAgICAgX2h1YW5wYWl0aXA6bnVsbCxcclxuICAgICAgICBfaHVhbnBhaUFycjpbXVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2h1YW5wYWl0aXAgPSBjYy5maW5kKFwiQ2FudmFzL2h1YW5zYW56aGFuZ1wiKTtcclxuICAgICAgICB0aGlzLl9odWFucGFpdGlwLmFjdGl2ZSA9IGNjLnZ2LmdhbWVOZXRNZ3IuaXNIdWFuU2FuWmhhbmc7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodGhpcy5faHVhbnBhaXRpcC5hY3RpdmUpe1xyXG4gICAgICAgICAgICB0aGlzLnNob3dIdWFucGFpKGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0U2VsZkRhdGEoKS5odWFucGFpcyA9PSBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbml0SHVhaXBhaUluZm8oKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgYnRuT2sgPSBjYy5maW5kKFwiQ2FudmFzL2h1YW5zYW56aGFuZy9idG5fb2tcIik7XHJcbiAgICAgICAgaWYoYnRuT2spe1xyXG4gICAgICAgICAgICBjYy52di51dGlscy5hZGRDbGlja0V2ZW50KGJ0bk9rLHRoaXMubm9kZSxcIkh1YW5TYW5aaGFuZ1wiLFwib25IdWFuU2FuWmhhbmdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfaHVhbnBhaScsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgc2VsZi5faHVhbnBhaXRpcC5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgIHNlbGYuc2hvd0h1YW5wYWkodHJ1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdodWFucGFpX25vdGlmeScsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIGlmKGRhdGEuZGV0YWlsLnNlYXRpbmRleCA9PSBjYy52di5nYW1lTmV0TWdyLnNlYXRJbmRleCl7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmluaXRIdWFpcGFpSW5mbygpOyAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubm9kZS5vbignZ2FtZV9odWFucGFpX292ZXInLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBzZWxmLl9odWFucGFpdGlwLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VsZi5faHVhbnBhaUFyci5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9odWFucGFpQXJyW2ldLnkgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYuX2h1YW5wYWlBcnIgPSBbXTtcclxuICAgICAgICAgICAgc2VsZi5pbml0SHVhaXBhaUluZm8oKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfaHVhbnBhaV9yZXN1bHQnLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBjYy52di5nYW1lTmV0TWdyLmlzSHVhblNhblpoYW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNlbGYuX2h1YW5wYWl0aXAuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZWxmLl9odWFucGFpQXJyLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIHNlbGYuX2h1YW5wYWlBcnJbaV0ueSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZi5faHVhbnBhaUFyciA9IFtdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubm9kZS5vbignbWpfY2xpY2tlZCcsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBkYXRhLmRldGFpbDtcclxuICAgICAgICAgICAgLy/lpoLmnpzlt7Lnu4/ngrnotbfmnaXvvIzliJnlj5bmtohcclxuICAgICAgICAgICAgdmFyIGlkeCA9IHNlbGYuX2h1YW5wYWlBcnIuaW5kZXhPZih0YXJnZXQpOyBcclxuICAgICAgICAgICAgaWYoaWR4ICE9IC0xKXtcclxuICAgICAgICAgICAgICAgIHRhcmdldC55ID0gMDtcclxuICAgICAgICAgICAgICAgIHNlbGYuX2h1YW5wYWlBcnIuc3BsaWNlKGlkeCwxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgLy/lpoLmnpzmmK/mlrDnmoTvvIzliJnliqDlhaVcclxuICAgICAgICAgICAgICAgIGlmKHNlbGYuX2h1YW5wYWlBcnIubGVuZ3RoIDwgMyl7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faHVhbnBhaUFyci5wdXNoKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnkgPSAxNTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNob3dIdWFucGFpOmZ1bmN0aW9uKGludGVyYWN0YWJsZSl7XHJcbiAgICAgICAgdGhpcy5faHVhbnBhaXRpcC5nZXRDaGlsZEJ5TmFtZShcImluZm9cIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBcIuivt+mAieaLqeS4ieW8oOS4gOagt+iKseiJsueahOeJjFwiO1xyXG4gICAgICAgIHRoaXMuX2h1YW5wYWl0aXAuZ2V0Q2hpbGRCeU5hbWUoXCJidG5fb2tcIikuZ2V0Q29tcG9uZW50KGNjLkJ1dHRvbikuaW50ZXJhY3RhYmxlID0gaW50ZXJhY3RhYmxlO1xyXG4gICAgICAgIHRoaXMuX2h1YW5wYWl0aXAuZ2V0Q2hpbGRCeU5hbWUoXCJtYXNrXCIpLmFjdGl2ZSA9IGZhbHNlOyAgICAgICAgXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBpbml0SHVhaXBhaUluZm86ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgaHVhaXBhaWluZm8gPSBjYy5maW5kKFwiQ2FudmFzL2dhbWUvaHVhbnBhaWluZm9cIik7XHJcbiAgICAgICAgdmFyIHNlYXQgPSBjYy52di5nYW1lTmV0TWdyLmdldFNlbGZEYXRhKCk7XHJcbiAgICAgICAgaWYoc2VhdC5odWFucGFpcyA9PSBudWxsKXtcclxuICAgICAgICAgICAgaHVhaXBhaWluZm8uYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaHVhaXBhaWluZm8uYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VhdC5odWFucGFpcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIGh1YWlwYWlpbmZvLmdldENoaWxkQnlOYW1lKFwiaHBcIiArIChpICsgMSkpLmdldENvbXBvbmVudChjYy5TcHJpdGUpLnNwcml0ZUZyYW1lID0gY2MudnYubWFoam9uZ21nci5nZXRTcHJpdGVGcmFtZUJ5TUpJRChcIk1fXCIsc2VhdC5odWFucGFpc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBocG0gPSBodWFpcGFpaW5mby5nZXRDaGlsZEJ5TmFtZShcImhwbVwiKTtcclxuICAgICAgICBocG0uYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICBpZihjYy52di5nYW1lTmV0TWdyLmh1YW5wYWltZXRob2QgPT0gMCl7XHJcbiAgICAgICAgICAgIGhwbS5yb3RhdGlvbiA9IDkwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGNjLnZ2LmdhbWVOZXRNZ3IuaHVhbnBhaW1ldGhvZCA9PSAxKXtcclxuICAgICAgICAgICAgaHBtLnJvdGF0aW9uID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihjYy52di5nYW1lTmV0TWdyLmh1YW5wYWltZXRob2QgPT0gMil7XHJcbiAgICAgICAgICAgIGhwbS5yb3RhdGlvbiA9IDE4MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgaHBtLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uSHVhblNhblpoYW5nOmZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICBpZih0aGlzLl9odWFucGFpQXJyLmxlbmd0aCAhPSAzKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgdHlwZSA9IG51bGw7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2h1YW5wYWlBcnIubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgcGFpID0gdGhpcy5faHVhbnBhaUFycltpXS5taklkO1xyXG4gICAgICAgICAgICB2YXIgbnQgPSBjYy52di5tYWhqb25nbWdyLmdldE1haGpvbmdUeXBlKHBhaSk7IFxyXG4gICAgICAgICAgICBpZih0eXBlID09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IG50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBpZih0eXBlICE9IG50KXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgICAgICAgIHAxOnRoaXMuX2h1YW5wYWlBcnJbMF0ubWpJZCxcclxuICAgICAgICAgICAgcDI6dGhpcy5faHVhbnBhaUFyclsxXS5taklkLFxyXG4gICAgICAgICAgICBwMzp0aGlzLl9odWFucGFpQXJyWzJdLm1qSWQsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX2h1YW5wYWl0aXAuZ2V0Q2hpbGRCeU5hbWUoXCJpbmZvXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gXCLnrYnlvoXlhbbku5bnjqnlrrbpgInniYwuLi5cIjtcclxuICAgICAgICB0aGlzLl9odWFucGFpdGlwLmdldENoaWxkQnlOYW1lKFwiYnRuX29rXCIpLmdldENvbXBvbmVudChjYy5CdXR0b24pLmludGVyYWN0YWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2h1YW5wYWl0aXAuZ2V0Q2hpbGRCeU5hbWUoXCJtYXNrXCIpLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MudnYubmV0LnNlbmQoXCJodWFucGFpXCIsZGF0YSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG5cclxuICAgIC8vIH0sXHJcbn0pO1xyXG4iLCJmdW5jdGlvbiBsb2FkSW1hZ2UodXJsLGNvZGUsY2FsbGJhY2spe1xyXG4gICAgLypcclxuICAgIGlmKGNjLnZ2LmltYWdlcyA9PSBudWxsKXtcclxuICAgICAgICBjYy52di5pbWFnZXMgPSB7fTtcclxuICAgIH1cclxuICAgIHZhciBpbWFnZUluZm8gPSBjYy52di5pbWFnZXNbdXJsXTtcclxuICAgIGlmKGltYWdlSW5mbyA9PSBudWxsKXtcclxuICAgICAgICBpbWFnZUluZm8gPSB7XHJcbiAgICAgICAgICAgIGltYWdlOm51bGwsXHJcbiAgICAgICAgICAgIHF1ZXVlOltdLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY2MudnYuaW1hZ2VzW3VybF0gPSBpbWFnZUluZm87XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNjLmxvYWRlci5sb2FkKHVybCxmdW5jdGlvbiAoZXJyLHRleCkge1xyXG4gICAgICAgIGltYWdlSW5mby5pbWFnZSA9IHRleDtcclxuICAgICAgICB2YXIgc3ByaXRlRnJhbWUgPSBuZXcgY2MuU3ByaXRlRnJhbWUodGV4LCBjYy5SZWN0KDAsIDAsIHRleC53aWR0aCwgdGV4LmhlaWdodCkpO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpbWFnZUluZm8ucXVldWUubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgaXRtID0gaW1hZ2VJbmZvLnF1ZXVlW2ldO1xyXG4gICAgICAgICAgICBpdG0uY2FsbGJhY2soaXRtLmNvZGUsc3ByaXRlRnJhbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpdG0ucXVldWUgPSBbXTtcclxuICAgIH0pO1xyXG4gICAgaWYoaW1hZ2VJbmZvLmltYWdlICE9IG51bGwpe1xyXG4gICAgICAgIHZhciB0ZXggPSBpbWFnZUluZm8uaW1hZ2U7XHJcbiAgICAgICAgdmFyIHNwcml0ZUZyYW1lID0gbmV3IGNjLlNwcml0ZUZyYW1lKHRleCwgY2MuUmVjdCgwLCAwLCB0ZXgud2lkdGgsIHRleC5oZWlnaHQpKTtcclxuICAgICAgICBjYWxsYmFjayhjb2RlLHNwcml0ZUZyYW1lKTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgICAgaW1hZ2VJbmZvLnF1ZXVlLnB1c2goe2NvZGU6Y29kZSxjYWxsYmFjazpjYWxsYmFja30pO1xyXG4gICAgfSovXHJcbiAgICBjYy5sb2FkZXIubG9hZCh1cmwsZnVuY3Rpb24gKGVycix0ZXgpIHtcclxuICAgICAgICB2YXIgc3ByaXRlRnJhbWUgPSBuZXcgY2MuU3ByaXRlRnJhbWUodGV4LCBjYy5SZWN0KDAsIDAsIHRleC53aWR0aCwgdGV4LmhlaWdodCkpO1xyXG4gICAgICAgIGNhbGxiYWNrKGNvZGUsc3ByaXRlRnJhbWUpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXRCYXNlSW5mbyh1c2VyaWQsY2FsbGJhY2spe1xyXG4gICAgaWYoY2MudnYuYmFzZUluZm9NYXAgPT0gbnVsbCl7XHJcbiAgICAgICAgY2MudnYuYmFzZUluZm9NYXAgPSB7fTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYoY2MudnYuYmFzZUluZm9NYXBbdXNlcmlkXSAhPSBudWxsKXtcclxuICAgICAgICBjYWxsYmFjayh1c2VyaWQsY2MudnYuYmFzZUluZm9NYXBbdXNlcmlkXSk7XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgICAgIGNjLnZ2Lmh0dHAuc2VuZFJlcXVlc3QoJy9iYXNlX2luZm8nLHt1c2VyaWQ6dXNlcmlkfSxmdW5jdGlvbihyZXQpe1xyXG4gICAgICAgICAgICB2YXIgdXJsID0gbnVsbDtcclxuICAgICAgICAgICAgaWYocmV0LmhlYWRpbWd1cmwpe1xyXG4gICAgICAgICAgICAgICB1cmwgPSByZXQuaGVhZGltZ3VybCArIFwiLmpwZ1wiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTpyZXQubmFtZSxcclxuICAgICAgICAgICAgICAgIHNleDpyZXQuc2V4LFxyXG4gICAgICAgICAgICAgICAgdXJsOnVybCxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYy52di5iYXNlSW5mb01hcFt1c2VyaWRdID0gaW5mbztcclxuICAgICAgICAgICAgY2FsbGJhY2sodXNlcmlkLGluZm8pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9LGNjLnZ2Lmh0dHAubWFzdGVyX3VybCk7ICAgXHJcbiAgICB9ICBcclxufTtcclxuXHJcbmNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAvLyBmb286IHtcclxuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLCAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdXNlZCBvbmx5IHdoZW4gdGhlIGNvbXBvbmVudCBhdHRhY2hpbmdcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGEgbm9kZSBmb3IgdGhlIGZpcnN0IHRpbWVcclxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XHJcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxyXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcclxuICAgICAgICAvLyB9LFxyXG4gICAgICAgIC8vIC4uLlxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2V0dXBTcHJpdGVGcmFtZSgpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc2V0VXNlcklEOmZ1bmN0aW9uKHVzZXJpZCl7XHJcbiAgICAgICAgaWYoY2Muc3lzLmlzTmF0aXZlID09IGZhbHNlKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZighdXNlcmlkKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihjYy52di5pbWFnZXMgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIGNjLnZ2LmltYWdlcyA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgZ2V0QmFzZUluZm8odXNlcmlkLGZ1bmN0aW9uKGNvZGUsaW5mbyl7XHJcbiAgICAgICAgICAgaWYoaW5mbyAmJiBpbmZvLnVybCl7XHJcbiAgICAgICAgICAgICAgICBsb2FkSW1hZ2UoaW5mby51cmwsdXNlcmlkLGZ1bmN0aW9uIChlcnIsc3ByaXRlRnJhbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9zcHJpdGVGcmFtZSA9IHNwcml0ZUZyYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0dXBTcHJpdGVGcmFtZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7ICAgXHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzZXR1cFNwcml0ZUZyYW1lOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYodGhpcy5fc3ByaXRlRnJhbWUpe1xyXG4gICAgICAgICAgICB2YXIgc3ByID0gdGhpcy5nZXRDb21wb25lbnQoY2MuU3ByaXRlKTtcclxuICAgICAgICAgICAgaWYoc3ByKXtcclxuICAgICAgICAgICAgICAgIHNwci5zcHJpdGVGcmFtZSA9IHRoaXMuX3Nwcml0ZUZyYW1lOyAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG5cclxuICAgIC8vIH0sXHJcbn0pO1xyXG4iLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIG51bXM6e1xyXG4gICAgICAgICAgICBkZWZhdWx0OltdLFxyXG4gICAgICAgICAgICB0eXBlOltjYy5MYWJlbF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pbnB1dEluZGV4OjAsXHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCxcclxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XHJcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxyXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcclxuICAgICAgICAvLyB9LFxyXG4gICAgICAgIC8vIC4uLlxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25FbmFibGU6ZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLm9uUmVzZXRDbGlja2VkKCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbklucHV0RmluaXNoZWQ6ZnVuY3Rpb24ocm9vbUlkKXtcclxuICAgICAgICBjYy52di51c2VyTWdyLmVudGVyUm9vbShyb29tSWQsZnVuY3Rpb24ocmV0KXtcclxuICAgICAgICAgICAgaWYocmV0LmVycmNvZGUgPT0gMCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gXCLmiL/pl7RbXCIrIHJvb21JZCArXCJd5LiN5a2Y5Zyo77yM6K+36YeN5paw6L6T5YWlIVwiO1xyXG4gICAgICAgICAgICAgICAgaWYocmV0LmVycmNvZGUgPT0gNCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IFwi5oi/6Ze0W1wiKyByb29tSWQgKyBcIl3lt7Lmu6EhXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYy52di5hbGVydC5zaG93KFwi5o+Q56S6XCIsY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uUmVzZXRDbGlja2VkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcykpOyBcclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uSW5wdXQ6ZnVuY3Rpb24obnVtKXtcclxuICAgICAgICBpZih0aGlzLl9pbnB1dEluZGV4ID49IHRoaXMubnVtcy5sZW5ndGgpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubnVtc1t0aGlzLl9pbnB1dEluZGV4XS5zdHJpbmcgPSBudW07XHJcbiAgICAgICAgdGhpcy5faW5wdXRJbmRleCArPSAxO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHRoaXMuX2lucHV0SW5kZXggPT0gdGhpcy5udW1zLmxlbmd0aCl7XHJcbiAgICAgICAgICAgIHZhciByb29tSWQgPSB0aGlzLnBhcnNlUm9vbUlEKCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwib2s6XCIgKyByb29tSWQpO1xyXG4gICAgICAgICAgICB0aGlzLm9uSW5wdXRGaW5pc2hlZChyb29tSWQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uTjBDbGlja2VkOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5vbklucHV0KDApOyAgXHJcbiAgICB9LFxyXG4gICAgb25OMUNsaWNrZWQ6ZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLm9uSW5wdXQoMSk7ICBcclxuICAgIH0sXHJcbiAgICBvbk4yQ2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMub25JbnB1dCgyKTtcclxuICAgIH0sXHJcbiAgICBvbk4zQ2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMub25JbnB1dCgzKTtcclxuICAgIH0sXHJcbiAgICBvbk40Q2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMub25JbnB1dCg0KTtcclxuICAgIH0sXHJcbiAgICBvbk41Q2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMub25JbnB1dCg1KTtcclxuICAgIH0sXHJcbiAgICBvbk42Q2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMub25JbnB1dCg2KTtcclxuICAgIH0sXHJcbiAgICBvbk43Q2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMub25JbnB1dCg3KTtcclxuICAgIH0sXHJcbiAgICBvbk44Q2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMub25JbnB1dCg4KTtcclxuICAgIH0sXHJcbiAgICBvbk45Q2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMub25JbnB1dCg5KTtcclxuICAgIH0sXHJcbiAgICBvblJlc2V0Q2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLm51bXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB0aGlzLm51bXNbaV0uc3RyaW5nID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faW5wdXRJbmRleCA9IDA7XHJcbiAgICB9LFxyXG4gICAgb25EZWxDbGlja2VkOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYodGhpcy5faW5wdXRJbmRleCA+IDApe1xyXG4gICAgICAgICAgICB0aGlzLl9pbnB1dEluZGV4IC09IDE7XHJcbiAgICAgICAgICAgIHRoaXMubnVtc1t0aGlzLl9pbnB1dEluZGV4XS5zdHJpbmcgPSBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBvbkNsb3NlQ2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHBhcnNlUm9vbUlEOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubnVtcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHN0ciArPSB0aGlzLm51bXNbaV0uc3RyaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG5cclxuICAgIC8vIH0sXHJcbn0pO1xyXG4iLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIHRpcExhYmVsOmNjLkxhYmVsLFxyXG4gICAgICAgIF9zdGF0ZVN0cjonJyxcclxuICAgICAgICBfcHJvZ3Jlc3M6MC4wLFxyXG4gICAgICAgIF9zcGxhc2g6bnVsbCxcclxuICAgICAgICBfaXNMb2FkaW5nOmZhbHNlLFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmKCFjYy5zeXMuaXNOYXRpdmUgJiYgY2Muc3lzLmlzTW9iaWxlKXtcclxuICAgICAgICAgICAgdmFyIGN2cyA9IHRoaXMubm9kZS5nZXRDb21wb25lbnQoY2MuQ2FudmFzKTtcclxuICAgICAgICAgICAgY3ZzLmZpdEhlaWdodCA9IHRydWU7XHJcbiAgICAgICAgICAgIGN2cy5maXRXaWR0aCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW5pdE1ncigpO1xyXG4gICAgICAgIHRoaXMudGlwTGFiZWwuc3RyaW5nID0gdGhpcy5fc3RhdGVTdHI7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5fc3BsYXNoID0gY2MuZmluZChcIkNhbnZhcy9zcGxhc2hcIik7XHJcbiAgICAgICAgdGhpcy5fc3BsYXNoLmFjdGl2ZSA9IHRydWU7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzdGFydDpmdW5jdGlvbigpeyAgICAgICAgXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBTSE9XX1RJTUUgPSAzMDAwO1xyXG4gICAgICAgIHZhciBGQURFX1RJTUUgPSA1MDA7XHJcbiAgICAgICAgaWYoY2Muc3lzLm9zICE9IGNjLnN5cy5PU19JT1MgfHwgIWNjLnN5cy5pc05hdGl2ZSl7XHJcbiAgICAgICAgICAgIHNlbGYuX3NwbGFzaC5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgdCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHQgPSBEYXRlLm5vdygpIC0gdDtcclxuICAgICAgICAgICAgICAgIGlmKGR0IDwgU0hPV19USU1FKXtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZuLDMzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcCA9ICgxIC0gKChkdCAtIFNIT1dfVElNRSkgLyBGQURFX1RJTUUpKSAqIDI1NTtcclxuICAgICAgICAgICAgICAgICAgICBpZihvcCA8IDApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9zcGxhc2gub3BhY2l0eSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2hlY2tWZXJzaW9uKCk7ICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9zcGxhc2gub3BhY2l0eSA9IG9wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZuLDMzKTsgICBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZm4sMzMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB0aGlzLl9zcGxhc2guYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tWZXJzaW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgaW5pdE1ncjpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLnZ2ID0ge307XHJcbiAgICAgICAgdmFyIFVzZXJNZ3IgPSByZXF1aXJlKFwiVXNlck1nclwiKTtcclxuICAgICAgICBjYy52di51c2VyTWdyID0gbmV3IFVzZXJNZ3IoKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgUmVwbGF5TWdyID0gcmVxdWlyZShcIlJlcGxheU1nclwiKTtcclxuICAgICAgICBjYy52di5yZXBsYXlNZ3IgPSBuZXcgUmVwbGF5TWdyKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MudnYuaHR0cCA9IHJlcXVpcmUoXCJIVFRQXCIpO1xyXG4gICAgICAgIGNjLnZ2Lmdsb2JhbCA9IHJlcXVpcmUoXCJHbG9iYWxcIik7XHJcbiAgICAgICAgY2MudnYubmV0ID0gcmVxdWlyZShcIk5ldFwiKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgR2FtZU5ldE1nciA9IHJlcXVpcmUoXCJHYW1lTmV0TWdyXCIpO1xyXG4gICAgICAgIGNjLnZ2LmdhbWVOZXRNZ3IgPSBuZXcgR2FtZU5ldE1ncigpO1xyXG4gICAgICAgIGNjLnZ2LmdhbWVOZXRNZ3IuaW5pdEhhbmRsZXJzKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIEFueXNka01nciA9IHJlcXVpcmUoXCJBbnlzZGtNZ3JcIik7XHJcbiAgICAgICAgY2MudnYuYW55c2RrTWdyID0gbmV3IEFueXNka01ncigpO1xyXG4gICAgICAgIGNjLnZ2LmFueXNka01nci5pbml0KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIFZvaWNlTWdyID0gcmVxdWlyZShcIlZvaWNlTWdyXCIpO1xyXG4gICAgICAgIGNjLnZ2LnZvaWNlTWdyID0gbmV3IFZvaWNlTWdyKCk7XHJcbiAgICAgICAgY2MudnYudm9pY2VNZ3IuaW5pdCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBBdWRpb01nciA9IHJlcXVpcmUoXCJBdWRpb01nclwiKTtcclxuICAgICAgICBjYy52di5hdWRpb01nciA9IG5ldyBBdWRpb01ncigpO1xyXG4gICAgICAgIGNjLnZ2LmF1ZGlvTWdyLmluaXQoKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgVXRpbHMgPSByZXF1aXJlKFwiVXRpbHNcIik7XHJcbiAgICAgICAgY2MudnYudXRpbHMgPSBuZXcgVXRpbHMoKTtcclxuICAgICAgICBcclxuICAgICAgICBjYy5hcmdzID0gdGhpcy51cmxQYXJzZSgpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgdXJsUGFyc2U6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgaWYod2luZG93LmxvY2F0aW9uID09IG51bGwpe1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmFtZSx2YWx1ZTsgXHJcbiAgICAgICAgdmFyIHN0cj13aW5kb3cubG9jYXRpb24uaHJlZjsgLy/lj5blvpfmlbTkuKrlnLDlnYDmoI9cclxuICAgICAgICB2YXIgbnVtPXN0ci5pbmRleE9mKFwiP1wiKSBcclxuICAgICAgICBzdHI9c3RyLnN1YnN0cihudW0rMSk7IC8v5Y+W5b6X5omA5pyJ5Y+C5pWwICAgc3RyaW5ndmFyLnN1YnN0cihzdGFydCBbLCBsZW5ndGggXVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBhcnI9c3RyLnNwbGl0KFwiJlwiKTsgLy/lkITkuKrlj4LmlbDmlL7liLDmlbDnu4Tph4xcclxuICAgICAgICBmb3IodmFyIGk9MDtpIDwgYXJyLmxlbmd0aDtpKyspeyBcclxuICAgICAgICAgICAgbnVtPWFycltpXS5pbmRleE9mKFwiPVwiKTsgXHJcbiAgICAgICAgICAgIGlmKG51bT4wKXsgXHJcbiAgICAgICAgICAgICAgICBuYW1lPWFycltpXS5zdWJzdHJpbmcoMCxudW0pO1xyXG4gICAgICAgICAgICAgICAgdmFsdWU9YXJyW2ldLnN1YnN0cihudW0rMSk7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXNbbmFtZV09dmFsdWU7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBjaGVja1ZlcnNpb246ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG9uR2V0VmVyc2lvbiA9IGZ1bmN0aW9uKHJldCl7XHJcbiAgICAgICAgICAgIGlmKHJldC52ZXJzaW9uID09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJlcnJvci5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGNjLnZ2LlNJID0gcmV0O1xyXG4gICAgICAgICAgICAgICAgaWYocmV0LnZlcnNpb24gIT0gY2MuVkVSU0lPTil7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MuZmluZChcIkNhbnZhcy9hbGVydFwiKS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnN0YXJ0UHJlbG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgeGhyID0gbnVsbDtcclxuICAgICAgICB2YXIgY29tcGxldGUgPSBmYWxzZTtcclxuICAgICAgICB2YXIgZm5SZXF1ZXN0ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgc2VsZi5fc3RhdGVTdHIgPSBcIuato+WcqOi/nuaOpeacjeWKoeWZqFwiO1xyXG4gICAgICAgICAgICB4aHIgPSBjYy52di5odHRwLnNlbmRSZXF1ZXN0KFwiL2dldF9zZXJ2ZXJpbmZvXCIsbnVsbCxmdW5jdGlvbihyZXQpe1xyXG4gICAgICAgICAgICAgICAgeGhyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIG9uR2V0VmVyc2lvbihyZXQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmbiw1MDAwKTsgICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgaWYoIWNvbXBsZXRlKXtcclxuICAgICAgICAgICAgICAgIGlmKHhocil7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fc3RhdGVTdHIgPSBcIui/nuaOpeWksei0pe+8jOWNs+WwhumHjeivlVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm5SZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSw1MDAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgZm5SZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGZuKCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbkJ0bkRvd25sb2FkQ2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLnN5cy5vcGVuVVJMKGNjLnZ2LlNJLmFwcHdlYik7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzdGFydFByZWxvYWRpbmc6ZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLl9zdGF0ZVN0ciA9IFwi5q2j5Zyo5Yqg6L296LWE5rqQ77yM6K+356iN5YCZXCI7XHJcbiAgICAgICAgdGhpcy5faXNMb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MubG9hZGVyLm9uUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoIGNvbXBsZXRlZENvdW50LCB0b3RhbENvdW50LCAgaXRlbSApe1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY29tcGxldGVkQ291bnQ6XCIgKyBjb21wbGV0ZWRDb3VudCArIFwiLHRvdGFsQ291bnQ6XCIgKyB0b3RhbENvdW50ICk7XHJcbiAgICAgICAgICAgIGlmKHNlbGYuX2lzTG9hZGluZyl7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9wcm9ncmVzcyA9IGNvbXBsZXRlZENvdW50L3RvdGFsQ291bnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNjLmxvYWRlci5sb2FkUmVzQWxsKFwidGV4dHVyZXNcIiwgZnVuY3Rpb24gKGVyciwgYXNzZXRzKSB7XHJcbiAgICAgICAgICAgIHNlbGYub25Mb2FkQ29tcGxldGUoKTtcclxuICAgICAgICB9KTsgICAgICBcclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uTG9hZENvbXBsZXRlOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5faXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RhdGVTdHIgPSBcIuWHhuWkh+eZu+mZhlwiO1xyXG4gICAgICAgIGNjLmRpcmVjdG9yLmxvYWRTY2VuZShcImxvZ2luXCIpO1xyXG4gICAgICAgIGNjLmxvYWRlci5vbkNvbXBsZXRlID0gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcbiAgICAgICAgaWYodGhpcy5fc3RhdGVTdHIubGVuZ3RoID09IDApe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGlwTGFiZWwuc3RyaW5nID0gdGhpcy5fc3RhdGVTdHIgKyAnICc7XHJcbiAgICAgICAgaWYodGhpcy5faXNMb2FkaW5nKXtcclxuICAgICAgICAgICAgdGhpcy50aXBMYWJlbC5zdHJpbmcgKz0gTWF0aC5mbG9vcih0aGlzLl9wcm9ncmVzcyAqIDEwMCkgKyBcIiVcIjsgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgdmFyIHQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSAlIDQ7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0OyArKyBpKXtcclxuICAgICAgICAgICAgICAgIHRoaXMudGlwTGFiZWwuc3RyaW5nICs9ICcuJztcclxuICAgICAgICAgICAgfSAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7IiwiU3RyaW5nLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbihhcmdzKSB7IFxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGg+MCkgeyBcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpczsgXHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiB0eXBlb2YgKGFyZ3MpID09IFwib2JqZWN0XCIpIHsgXHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhcmdzKSB7IFxyXG4gICAgICAgICAgICAgICAgdmFyIHJlZz1uZXcgUmVnRXhwIChcIih7XCIra2V5K1wifSlcIixcImdcIik7IFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UocmVnLCBhcmdzW2tleV0pOyBcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICB9IFxyXG4gICAgICAgIGVsc2UgeyBcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgXHJcbiAgICAgICAgICAgICAgICBpZihhcmd1bWVudHNbaV09PXVuZGVmaW5lZCkgeyBcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjsgXHJcbiAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgZWxzZSB7IFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWc9bmV3IFJlZ0V4cCAoXCIoe1tcIitpK1wiXX0pXCIsXCJnXCIpOyBcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShyZWcsIGFyZ3VtZW50c1tpXSk7IFxyXG4gICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICB9IFxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7IFxyXG4gICAgfSBcclxuICAgIGVsc2UgeyBcclxuICAgICAgICByZXR1cm4gdGhpczsgXHJcbiAgICB9IFxyXG59O1xyXG4gXHJcbmNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCxcclxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XHJcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxyXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcclxuICAgICAgICAvLyB9LFxyXG4gICAgICAgIC8vIC4uLlxyXG4gICAgICAgIF9taW1hOm51bGwsXHJcbiAgICAgICAgX21pbWFJbmRleDowLFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmKCFjYy5zeXMuaXNOYXRpdmUgJiYgY2Muc3lzLmlzTW9iaWxlKXtcclxuICAgICAgICAgICAgdmFyIGN2cyA9IHRoaXMubm9kZS5nZXRDb21wb25lbnQoY2MuQ2FudmFzKTtcclxuICAgICAgICAgICAgY3ZzLmZpdEhlaWdodCA9IHRydWU7XHJcbiAgICAgICAgICAgIGN2cy5maXRXaWR0aCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKCFjYy52dil7XHJcbiAgICAgICAgICAgIGNjLmRpcmVjdG9yLmxvYWRTY2VuZShcImxvYWRpbmdcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2MudnYuaHR0cC51cmwgPSBjYy52di5odHRwLm1hc3Rlcl91cmw7XHJcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoJ3B1c2hfbmVlZF9jcmVhdGVfcm9sZScsZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJvbkxvYWQ6cHVzaF9uZWVkX2NyZWF0ZV9yb2xlXCIpO1xyXG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5sb2FkU2NlbmUoXCJjcmVhdGVyb2xlXCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNjLnZ2LmF1ZGlvTWdyLnBsYXlCR00oXCJiZ01haW4ubXAzXCIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX21pbWEgPSBbXCJBXCIsXCJBXCIsXCJCXCIsXCJCXCIsXCJBXCIsXCJCXCIsXCJBXCIsXCJCXCIsXCJBXCIsXCJBXCIsXCJBXCIsXCJCXCIsXCJCXCIsXCJCXCJdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKCFjYy5zeXMuaXNOYXRpdmUgfHwgY2Muc3lzLm9zID09IGNjLnN5cy5PU19XSU5ET1dTKXtcclxuICAgICAgICAgICAgY2MuZmluZChcIkNhbnZhcy9idG5feWtcIikuYWN0aXZlID0gdHJ1ZTsgICAgXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc3RhcnQ6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgYWNjb3VudCA9ICBjYy5zeXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ3eF9hY2NvdW50XCIpO1xyXG4gICAgICAgIHZhciBzaWduID0gY2Muc3lzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwid3hfc2lnblwiKTtcclxuICAgICAgICBpZihhY2NvdW50ICE9IG51bGwgJiYgc2lnbiAhPSBudWxsKXtcclxuICAgICAgICAgICAgdmFyIHJldCA9IHtcclxuICAgICAgICAgICAgICAgIGVycmNvZGU6MCxcclxuICAgICAgICAgICAgICAgIGFjY291bnQ6YWNjb3VudCxcclxuICAgICAgICAgICAgICAgIHNpZ246c2lnblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNjLnZ2LnVzZXJNZ3Iub25BdXRoKHJldCk7XHJcbiAgICAgICAgfSAgIFxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25CdG5RdWlja1N0YXJ0Q2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLnZ2LnVzZXJNZ3IuZ3Vlc3RBdXRoKCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbkJ0bldlaWNoYXRDbGlja2VkOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGNjLnZ2LmFueXNka01nci5sb2dpbigpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25CdG5NSU1BQ2xpY2tlZDpmdW5jdGlvbihldmVudCl7XHJcbiAgICAgICAgaWYodGhpcy5fbWltYVt0aGlzLl9taW1hSW5kZXhdID09IGV2ZW50LnRhcmdldC5uYW1lKXtcclxuICAgICAgICAgICAgdGhpcy5fbWltYUluZGV4Kys7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuX21pbWFJbmRleCA9PSB0aGlzLl9taW1hLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICBjYy5maW5kKFwiQ2FudmFzL2J0bl95a1wiKS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwib2ggaG9+fn5cIik7XHJcbiAgICAgICAgICAgIHRoaXMuX21pbWFJbmRleCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG5cclxuICAgIC8vIH0sXHJcbn0pO1xyXG4iLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczogeyAgICAgICAgXHJcbiAgICAgICAgZ2FtZVJvb3Q6e1xyXG4gICAgICAgICAgICBkZWZhdWx0Om51bGwsXHJcbiAgICAgICAgICAgIHR5cGU6Y2MuTm9kZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgcHJlcGFyZVJvb3Q6e1xyXG4gICAgICAgICAgICBkZWZhdWx0Om51bGwsXHJcbiAgICAgICAgICAgIHR5cGU6Y2MuTm9kZSAgIFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgX215TUpBcnI6W10sXHJcbiAgICAgICAgX29wdGlvbnM6bnVsbCxcclxuICAgICAgICBfc2VsZWN0ZWRNSjpudWxsLFxyXG4gICAgICAgIF9jaHVwYWlTcHJpdGU6W10sXHJcbiAgICAgICAgX21qY291bnQ6bnVsbCxcclxuICAgICAgICBfZ2FtZWNvdW50Om51bGwsXHJcbiAgICAgICAgX2h1cGFpVGlwczpbXSxcclxuICAgICAgICBfaHVwYWlMaXN0czpbXSxcclxuICAgICAgICBfcGxheUVmeHM6W10sXHJcbiAgICAgICAgX29wdHM6W10sXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZighY2Muc3lzLmlzTmF0aXZlICYmIGNjLnN5cy5pc01vYmlsZSl7XHJcbiAgICAgICAgICAgIHZhciBjdnMgPSB0aGlzLm5vZGUuZ2V0Q29tcG9uZW50KGNjLkNhbnZhcyk7XHJcbiAgICAgICAgICAgIGN2cy5maXRIZWlnaHQgPSB0cnVlO1xyXG4gICAgICAgICAgICBjdnMuZml0V2lkdGggPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZighY2MudnYpe1xyXG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5sb2FkU2NlbmUoXCJsb2FkaW5nXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KFwiTm90aWNlVGlwXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KFwiR2FtZU92ZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoXCJEaW5nUXVlXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KFwiUGVuZ0dhbmdzXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KFwiTUpSb29tXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KFwiVGltZVBvaW50ZXJcIik7XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoXCJHYW1lUmVzdWx0XCIpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KFwiQ2hhdFwiKTtcclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChcIkZvbGRzXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KFwiUmVwbGF5Q3RybFwiKTtcclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChcIlBvcHVwTWdyXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KFwiSHVhblNhblpoYW5nXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KFwiUmVDb25uZWN0XCIpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KFwiVm9pY2VcIik7XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoXCJVc2VySW5mb1Nob3dcIik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5pbml0VmlldygpO1xyXG4gICAgICAgIHRoaXMuaW5pdEV2ZW50SGFuZGxlcnMoKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmdhbWVSb290LmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucHJlcGFyZVJvb3QuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmluaXRXYW5mYUxhYmVsKCk7XHJcbiAgICAgICAgdGhpcy5vbkdhbWVCZWlnbigpO1xyXG4gICAgICAgIGNjLnZ2LmF1ZGlvTWdyLnBsYXlCR00oXCJiZ0ZpZ2h0Lm1wM1wiKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGluaXRWaWV3OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy/mkJzntKLpnIDopoHnmoTlrZDoioLngrlcclxuICAgICAgICB2YXIgZ2FtZUNoaWxkID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiZ2FtZVwiKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9tamNvdW50ID0gZ2FtZUNoaWxkLmdldENoaWxkQnlOYW1lKCdtamNvdW50JykuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKTtcclxuICAgICAgICB0aGlzLl9tamNvdW50LnN0cmluZyA9IFwi5Ymp5L2ZXCIgKyBjYy52di5nYW1lTmV0TWdyLm51bU9mTUogKyBcIuW8oFwiO1xyXG4gICAgICAgIHRoaXMuX2dhbWVjb3VudCA9IGdhbWVDaGlsZC5nZXRDaGlsZEJ5TmFtZSgnZ2FtZWNvdW50JykuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKTtcclxuICAgICAgICB0aGlzLl9nYW1lY291bnQuc3RyaW5nID0gXCJcIiArIGNjLnZ2LmdhbWVOZXRNZ3IubnVtT2ZHYW1lcyArIFwiL1wiICsgY2MudnYuZ2FtZU5ldE1nci5tYXhOdW1PZkdhbWVzICsgXCLlsYBcIjtcclxuXHJcbiAgICAgICAgdmFyIG15c2VsZkNoaWxkID0gZ2FtZUNoaWxkLmdldENoaWxkQnlOYW1lKFwibXlzZWxmXCIpO1xyXG4gICAgICAgIHZhciBteWhvbGRzID0gbXlzZWxmQ2hpbGQuZ2V0Q2hpbGRCeU5hbWUoXCJob2xkc1wiKTtcclxuICAgICAgICBcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbXlob2xkcy5jaGlsZHJlbi5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBzcHJpdGUgPSBteWhvbGRzLmNoaWxkcmVuW2ldLmdldENvbXBvbmVudChjYy5TcHJpdGUpO1xyXG4gICAgICAgICAgICB0aGlzLl9teU1KQXJyLnB1c2goc3ByaXRlKTtcclxuICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlYWx3aWR0aCA9IGNjLmRpcmVjdG9yLmdldFZpc2libGVTaXplKCkud2lkdGg7XHJcbiAgICAgICAgbXlob2xkcy5zY2FsZVggKj0gcmVhbHdpZHRoLzEyODA7XHJcbiAgICAgICAgbXlob2xkcy5zY2FsZVkgKj0gcmVhbHdpZHRoLzEyODA7ICBcclxuICAgICAgICBcclxuICAgICAgICB2YXIgc2lkZXMgPSBbXCJteXNlbGZcIixcInJpZ2h0XCIsXCJ1cFwiLFwibGVmdFwiXTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2lkZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgc2lkZSA9IHNpZGVzW2ldO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHNpZGVDaGlsZCA9IGdhbWVDaGlsZC5nZXRDaGlsZEJ5TmFtZShzaWRlKTtcclxuICAgICAgICAgICAgdGhpcy5faHVwYWlUaXBzLnB1c2goc2lkZUNoaWxkLmdldENoaWxkQnlOYW1lKFwiSHVQYWlcIikpO1xyXG4gICAgICAgICAgICB0aGlzLl9odXBhaUxpc3RzLnB1c2goc2lkZUNoaWxkLmdldENoaWxkQnlOYW1lKFwiaHVwYWlsaXN0XCIpKTtcclxuICAgICAgICAgICAgdGhpcy5fcGxheUVmeHMucHVzaChzaWRlQ2hpbGQuZ2V0Q2hpbGRCeU5hbWUoXCJwbGF5X2VmeFwiKS5nZXRDb21wb25lbnQoY2MuQW5pbWF0aW9uKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NodXBhaVNwcml0ZS5wdXNoKHNpZGVDaGlsZC5nZXRDaGlsZEJ5TmFtZShcIkNodVBhaVwiKS5jaGlsZHJlblswXS5nZXRDb21wb25lbnQoY2MuU3ByaXRlKSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgb3B0ID0gc2lkZUNoaWxkLmdldENoaWxkQnlOYW1lKFwib3B0XCIpO1xyXG4gICAgICAgICAgICBvcHQuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBzcHJpdGUgPSBvcHQuZ2V0Q2hpbGRCeU5hbWUoXCJwYWlcIikuZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgbm9kZTpvcHQsXHJcbiAgICAgICAgICAgICAgICBzcHJpdGU6c3ByaXRlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuX29wdHMucHVzaChkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG9wdHMgPSBnYW1lQ2hpbGQuZ2V0Q2hpbGRCeU5hbWUoXCJvcHNcIik7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdHM7XHJcbiAgICAgICAgdGhpcy5oaWRlT3B0aW9ucygpO1xyXG4gICAgICAgIHRoaXMuaGlkZUNodXBhaSgpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgaGlkZUNodXBhaTpmdW5jdGlvbigpe1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaHVwYWlTcHJpdGUubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB0aGlzLl9jaHVwYWlTcHJpdGVbaV0ubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9ICAgICAgICBcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGluaXRFdmVudEhhbmRsZXJzOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MudnYuZ2FtZU5ldE1nci5kYXRhRXZlbnRIYW5kbGVyID0gdGhpcy5ub2RlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8v5Yid5aeL5YyW5LqL5Lu255uR5ZCs5ZmoXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubm9kZS5vbignZ2FtZV9ob2xkcycsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgc2VsZi5pbml0TWFoam9uZ3MoKTtcclxuICAgICAgICAgICBzZWxmLmNoZWNrUXVlWWlNZW4oKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW1lX2JlZ2luJyxmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgc2VsZi5vbkdhbWVCZWlnbigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubm9kZS5vbignZ2FtZV9zeW5jJyxmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgc2VsZi5vbkdhbWVCZWlnbigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubm9kZS5vbignZ2FtZV9jaHVwYWknLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBkYXRhID0gZGF0YS5kZXRhaWw7XHJcbiAgICAgICAgICAgIHNlbGYuaGlkZUNodXBhaSgpO1xyXG4gICAgICAgICAgICBzZWxmLmNoZWNrUXVlWWlNZW4oKTtcclxuICAgICAgICAgICAgaWYoZGF0YS5sYXN0ICE9IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdEluZGV4KXtcclxuICAgICAgICAgICAgICAgIHNlbGYuaW5pdE1vcGFpKGRhdGEubGFzdCxudWxsKTsgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZighY2MudnYucmVwbGF5TWdyLmlzUmVwbGF5KCkgJiYgZGF0YS50dXJuICE9IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdEluZGV4KXtcclxuICAgICAgICAgICAgICAgIHNlbGYuaW5pdE1vcGFpKGRhdGEudHVybiwtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfbW9wYWknLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBzZWxmLmhpZGVDaHVwYWkoKTtcclxuICAgICAgICAgICAgZGF0YSA9IGRhdGEuZGV0YWlsO1xyXG4gICAgICAgICAgICB2YXIgcGFpID0gZGF0YS5wYWk7XHJcbiAgICAgICAgICAgIHZhciBsb2NhbEluZGV4ID0gY2MudnYuZ2FtZU5ldE1nci5nZXRMb2NhbEluZGV4KGRhdGEuc2VhdEluZGV4KTtcclxuICAgICAgICAgICAgaWYobG9jYWxJbmRleCA9PSAwKXtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDEzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHNlbGYuX215TUpBcnJbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5zZXRTcHJpdGVGcmFtZUJ5TUpJRChcIk1fXCIsc3ByaXRlLHBhaSxpbmRleCk7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGUubm9kZS5taklkID0gcGFpOyAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGNjLnZ2LnJlcGxheU1nci5pc1JlcGxheSgpKXtcclxuICAgICAgICAgICAgICAgIHNlbGYuaW5pdE1vcGFpKGRhdGEuc2VhdEluZGV4LHBhaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfYWN0aW9uJyxmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgc2VsZi5zaG93QWN0aW9uKGRhdGEuZGV0YWlsKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm5vZGUub24oJ2h1cGFpJyxmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhLmRldGFpbDtcclxuICAgICAgICAgICAgLy/lpoLmnpzkuI3mmK/njqnlrrboh6rlt7HvvIzliJnlsIbnjqnlrrbnmoTniYzpg73mlL7lgJJcclxuICAgICAgICAgICAgdmFyIHNlYXRJbmRleCA9IGRhdGEuc2VhdGluZGV4O1xyXG4gICAgICAgICAgICB2YXIgbG9jYWxJbmRleCA9IGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0TG9jYWxJbmRleChzZWF0SW5kZXgpO1xyXG4gICAgICAgICAgICB2YXIgaHVwYWkgPSBzZWxmLl9odXBhaVRpcHNbbG9jYWxJbmRleF07XHJcbiAgICAgICAgICAgIGh1cGFpLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihsb2NhbEluZGV4ID09IDApe1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oaWRlT3B0aW9ucygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzZWF0RGF0YSA9IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdHNbc2VhdEluZGV4XTtcclxuICAgICAgICAgICAgc2VhdERhdGEuaHVlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmKGNjLnZ2LmdhbWVOZXRNZ3IuY29uZi50eXBlID09IFwieGxjaFwiKXtcclxuICAgICAgICAgICAgICAgIGh1cGFpLmdldENoaWxkQnlOYW1lKFwic3BySHVcIikuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGh1cGFpLmdldENoaWxkQnlOYW1lKFwic3ByWmltb1wiKS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHNlbGYuaW5pdEh1cGFpKGxvY2FsSW5kZXgsZGF0YS5odXBhaSk7XHJcbiAgICAgICAgICAgICAgICBpZihkYXRhLmlzemltbyl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc2VhdERhdGEuc2VhdGluZGV4ID09IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdEluZGV4KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VhdERhdGEuaG9sZHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW5pdE1haGpvbmdzKCk7ICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmluaXRPdGhlck1haGpvbmdzKHNlYXREYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBodXBhaS5nZXRDaGlsZEJ5TmFtZShcInNwckh1XCIpLmFjdGl2ZSA9ICFkYXRhLmlzemltbztcclxuICAgICAgICAgICAgICAgIGh1cGFpLmdldENoaWxkQnlOYW1lKFwic3ByWmltb1wiKS5hY3RpdmUgPSBkYXRhLmlzemltbztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYoIShkYXRhLmlzemltbyAmJiBsb2NhbEluZGV4PT0wKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2lmKGNjLnZ2LnJlcGxheU1nci5pc1JlcGxheSgpID09IGZhbHNlICYmIGxvY2FsSW5kZXggIT0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgc2VsZi5pbml0RW1wdHlTcHJpdGVzKHNlYXRJbmRleCk7ICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vfVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5pdE1vcGFpKHNlYXRJbmRleCxkYXRhLmh1cGFpKTtcclxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihjYy52di5yZXBsYXlNZ3IuaXNSZXBsYXkoKSA9PSB0cnVlICYmIGNjLnZ2LmdhbWVOZXRNZ3IuY29uZi50eXBlICE9IFwieGxjaFwiKXtcclxuICAgICAgICAgICAgICAgIHZhciBvcHQgPSBzZWxmLl9vcHRzW2xvY2FsSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgb3B0Lm5vZGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIG9wdC5zcHJpdGUuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKFwiTV9cIixkYXRhLmh1cGFpKTsgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKGRhdGEuaXN6aW1vKXtcclxuICAgICAgICAgICAgICAgIHNlbGYucGxheUVmeChsb2NhbEluZGV4LFwicGxheV96aW1vXCIpOyAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgc2VsZi5wbGF5RWZ4KGxvY2FsSW5kZXgsXCJwbGF5X2h1XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjYy52di5hdWRpb01nci5wbGF5U0ZYKFwibnYvaHUubXAzXCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubm9kZS5vbignbWpfY291bnQnLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBzZWxmLl9tamNvdW50LnN0cmluZyA9IFwi5Ymp5L2ZXCIgKyBjYy52di5nYW1lTmV0TWdyLm51bU9mTUogKyBcIuW8oFwiO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubm9kZS5vbignZ2FtZV9udW0nLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBzZWxmLl9nYW1lY291bnQuc3RyaW5nID0gXCJcIiArIGNjLnZ2LmdhbWVOZXRNZ3IubnVtT2ZHYW1lcyArIFwiL1wiICsgY2MudnYuZ2FtZU5ldE1nci5tYXhOdW1PZkdhbWVzICsgXCLlsYBcIjtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfb3ZlcicsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHNlbGYuZ2FtZVJvb3QuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNlbGYucHJlcGFyZVJvb3QuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfY2h1cGFpX25vdGlmeScsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHNlbGYuaGlkZUNodXBhaSgpO1xyXG4gICAgICAgICAgICB2YXIgc2VhdERhdGEgPSBkYXRhLmRldGFpbC5zZWF0RGF0YTtcclxuICAgICAgICAgICAgLy/lpoLmnpzmmK/oh6rlt7HvvIzliJnliLfmlrDmiYvniYxcclxuICAgICAgICAgICAgaWYoc2VhdERhdGEuc2VhdGluZGV4ID09IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdEluZGV4KXtcclxuICAgICAgICAgICAgICAgIHNlbGYuaW5pdE1haGpvbmdzKCk7ICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmluaXRPdGhlck1haGpvbmdzKHNlYXREYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWxmLnNob3dDaHVwYWkoKTtcclxuICAgICAgICAgICAgdmFyIGF1ZGlvVXJsID0gY2MudnYubWFoam9uZ21nci5nZXRBdWRpb1VSTEJ5TUpJRChkYXRhLmRldGFpbC5wYWkpO1xyXG4gICAgICAgICAgICBjYy52di5hdWRpb01nci5wbGF5U0ZYKGF1ZGlvVXJsKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm5vZGUub24oJ2d1b19ub3RpZnknLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBzZWxmLmhpZGVDaHVwYWkoKTtcclxuICAgICAgICAgICAgc2VsZi5oaWRlT3B0aW9ucygpO1xyXG4gICAgICAgICAgICB2YXIgc2VhdERhdGEgPSBkYXRhLmRldGFpbDtcclxuICAgICAgICAgICAgLy/lpoLmnpzmmK/oh6rlt7HvvIzliJnliLfmlrDmiYvniYxcclxuICAgICAgICAgICAgaWYoc2VhdERhdGEuc2VhdGluZGV4ID09IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdEluZGV4KXtcclxuICAgICAgICAgICAgICAgIHNlbGYuaW5pdE1haGpvbmdzKCk7ICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNjLnZ2LmF1ZGlvTWdyLnBsYXlTRlgoXCJnaXZlLm1wM1wiKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm5vZGUub24oJ2d1b19yZXN1bHQnLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBzZWxmLmhpZGVPcHRpb25zKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW1lX2RpbmdxdWVfZmluaXNoJyxmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgc2VsZi5pbml0TWFoam9uZ3MoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm5vZGUub24oJ3Blbmdfbm90aWZ5JyxmdW5jdGlvbihkYXRhKXsgICAgXHJcbiAgICAgICAgICAgIHNlbGYuaGlkZUNodXBhaSgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHNlYXREYXRhID0gZGF0YS5kZXRhaWw7XHJcbiAgICAgICAgICAgIGlmKHNlYXREYXRhLnNlYXRpbmRleCA9PSBjYy52di5nYW1lTmV0TWdyLnNlYXRJbmRleCl7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmluaXRNYWhqb25ncygpOyAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgc2VsZi5pbml0T3RoZXJNYWhqb25ncyhzZWF0RGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxvY2FsSW5kZXggPSBzZWxmLmdldExvY2FsSW5kZXgoc2VhdERhdGEuc2VhdGluZGV4KTtcclxuICAgICAgICAgICAgc2VsZi5wbGF5RWZ4KGxvY2FsSW5kZXgsXCJwbGF5X3BlbmdcIik7XHJcbiAgICAgICAgICAgIGNjLnZ2LmF1ZGlvTWdyLnBsYXlTRlgoXCJudi9wZW5nLm1wM1wiKTtcclxuICAgICAgICAgICAgc2VsZi5oaWRlT3B0aW9ucygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubm9kZS5vbignZ2FuZ19ub3RpZnknLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBzZWxmLmhpZGVDaHVwYWkoKTtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhLmRldGFpbDtcclxuICAgICAgICAgICAgdmFyIHNlYXREYXRhID0gZGF0YS5zZWF0RGF0YTtcclxuICAgICAgICAgICAgdmFyIGdhbmd0eXBlID0gZGF0YS5nYW5ndHlwZTtcclxuICAgICAgICAgICAgaWYoc2VhdERhdGEuc2VhdGluZGV4ID09IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdEluZGV4KXtcclxuICAgICAgICAgICAgICAgIHNlbGYuaW5pdE1haGpvbmdzKCk7ICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmluaXRPdGhlck1haGpvbmdzKHNlYXREYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGxvY2FsSW5kZXggPSBzZWxmLmdldExvY2FsSW5kZXgoc2VhdERhdGEuc2VhdGluZGV4KTtcclxuICAgICAgICAgICAgaWYoZ2FuZ3R5cGUgPT0gXCJ3YW5nYW5nXCIpe1xyXG4gICAgICAgICAgICAgICAgc2VsZi5wbGF5RWZ4KGxvY2FsSW5kZXgsXCJwbGF5X2d1YWZlbmdcIik7XHJcbiAgICAgICAgICAgICAgICBjYy52di5hdWRpb01nci5wbGF5U0ZYKFwiZ3VhZmVuZy5tcDNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHNlbGYucGxheUVmeChsb2NhbEluZGV4LFwicGxheV94aWF5dVwiKTtcclxuICAgICAgICAgICAgICAgIGNjLnZ2LmF1ZGlvTWdyLnBsYXlTRlgoXCJyYWluLm1wM1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubm9kZS5vbihcImhhbmdhbmdfbm90aWZ5XCIsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gZGF0YS5kZXRhaWw7XHJcbiAgICAgICAgICAgIHZhciBsb2NhbEluZGV4ID0gc2VsZi5nZXRMb2NhbEluZGV4KGRhdGEpO1xyXG4gICAgICAgICAgICBzZWxmLnBsYXlFZngobG9jYWxJbmRleCxcInBsYXlfZ2FuZ1wiKTtcclxuICAgICAgICAgICAgY2MudnYuYXVkaW9NZ3IucGxheVNGWChcIm52L2dhbmcubXAzXCIpO1xyXG4gICAgICAgICAgICBzZWxmLmhpZGVPcHRpb25zKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzaG93Q2h1cGFpOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHBhaSA9IGNjLnZ2LmdhbWVOZXRNZ3IuY2h1cGFpOyBcclxuICAgICAgICBpZiggcGFpID49IDAgKXtcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgdmFyIGxvY2FsSW5kZXggPSB0aGlzLmdldExvY2FsSW5kZXgoY2MudnYuZ2FtZU5ldE1nci50dXJuKTtcclxuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHRoaXMuX2NodXBhaVNwcml0ZVtsb2NhbEluZGV4XTtcclxuICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gY2MudnYubWFoam9uZ21nci5nZXRTcHJpdGVGcmFtZUJ5TUpJRChcIk1fXCIscGFpKTtcclxuICAgICAgICAgICAgc3ByaXRlLm5vZGUuYWN0aXZlID0gdHJ1ZTsgICBcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBhZGRPcHRpb246ZnVuY3Rpb24oYnRuTmFtZSxwYWkpe1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9vcHRpb25zLmNoaWxkcmVuQ291bnQ7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuX29wdGlvbnMuY2hpbGRyZW5baV07IFxyXG4gICAgICAgICAgICBpZihjaGlsZC5uYW1lID09IFwib3BcIiAmJiBjaGlsZC5hY3RpdmUgPT0gZmFsc2Upe1xyXG4gICAgICAgICAgICAgICAgY2hpbGQuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBzcHJpdGUgPSBjaGlsZC5nZXRDaGlsZEJ5TmFtZShcIm9wVGFyZ2V0XCIpLmdldENvbXBvbmVudChjYy5TcHJpdGUpO1xyXG4gICAgICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gY2MudnYubWFoam9uZ21nci5nZXRTcHJpdGVGcmFtZUJ5TUpJRChcIk1fXCIscGFpKTtcclxuICAgICAgICAgICAgICAgIHZhciBidG4gPSBjaGlsZC5nZXRDaGlsZEJ5TmFtZShidG5OYW1lKTsgXHJcbiAgICAgICAgICAgICAgICBidG4uYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJ0bi5wYWkgPSBwYWk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBoaWRlT3B0aW9uczpmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICB0aGlzLl9vcHRpb25zLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9vcHRpb25zLmNoaWxkcmVuQ291bnQ7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuX29wdGlvbnMuY2hpbGRyZW5baV07IFxyXG4gICAgICAgICAgICBpZihjaGlsZC5uYW1lID09IFwib3BcIil7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNoaWxkLmdldENoaWxkQnlOYW1lKFwiYnRuUGVuZ1wiKS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNoaWxkLmdldENoaWxkQnlOYW1lKFwiYnRuR2FuZ1wiKS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNoaWxkLmdldENoaWxkQnlOYW1lKFwiYnRuSHVcIikuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzaG93QWN0aW9uOmZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgIGlmKHRoaXMuX29wdGlvbnMuYWN0aXZlKXtcclxuICAgICAgICAgICAgdGhpcy5oaWRlT3B0aW9ucygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZihkYXRhICYmIChkYXRhLmh1IHx8IGRhdGEuZ2FuZyB8fCBkYXRhLnBlbmcpKXtcclxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZihkYXRhLmh1KXtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkT3B0aW9uKFwiYnRuSHVcIixkYXRhLnBhaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoZGF0YS5wZW5nKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkT3B0aW9uKFwiYnRuUGVuZ1wiLGRhdGEucGFpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYoZGF0YS5nYW5nKXtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkYXRhLmdhbmdwYWkubGVuZ3RoOysraSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdwID0gZGF0YS5nYW5ncGFpW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkT3B0aW9uKFwiYnRuR2FuZ1wiLGdwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSAgIFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIGluaXRXYW5mYUxhYmVsOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHdhbmZhID0gY2MuZmluZChcIkNhbnZhcy9pbmZvYmFyL3dhbmZhXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCk7XHJcbiAgICAgICAgd2FuZmEuc3RyaW5nID0gY2MudnYuZ2FtZU5ldE1nci5nZXRXYW5mYSgpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgaW5pdEh1cGFpOmZ1bmN0aW9uKGxvY2FsSW5kZXgscGFpKXtcclxuICAgICAgICBpZihjYy52di5nYW1lTmV0TWdyLmNvbmYudHlwZSA9PSBcInhsY2hcIil7XHJcbiAgICAgICAgICAgIHZhciBodXBhaWxpc3QgPSB0aGlzLl9odXBhaUxpc3RzW2xvY2FsSW5kZXhdO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgaHVwYWlsaXN0LmNoaWxkcmVuLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIHZhciBodXBhaW5vZGUgPSBodXBhaWxpc3QuY2hpbGRyZW5baV07IFxyXG4gICAgICAgICAgICAgICAgaWYoaHVwYWlub2RlLmFjdGl2ZSA9PSBmYWxzZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0Rm9sZFByZShsb2NhbEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBodXBhaW5vZGUuZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSkuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKHByZSxwYWkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGh1cGFpbm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ICAgXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgcGxheUVmeDpmdW5jdGlvbihpbmRleCxuYW1lKXtcclxuICAgICAgICB0aGlzLl9wbGF5RWZ4c1tpbmRleF0ubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3BsYXlFZnhzW2luZGV4XS5wbGF5KG5hbWUpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25HYW1lQmVpZ246ZnVuY3Rpb24oKXtcclxuICAgICAgICBcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fcGxheUVmeHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5RWZ4c1tpXS5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faHVwYWlMaXN0cy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCB0aGlzLl9odXBhaUxpc3RzW2ldLmNoaWxkcmVuQ291bnQ7ICsrail7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9odXBhaUxpc3RzW2ldLmNoaWxkcmVuW2pdLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjYy52di5nYW1lTmV0TWdyLnNlYXRzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIHNlYXREYXRhID0gY2MudnYuZ2FtZU5ldE1nci5zZWF0c1tpXTtcclxuICAgICAgICAgICAgdmFyIGxvY2FsSW5kZXggPSBjYy52di5nYW1lTmV0TWdyLmdldExvY2FsSW5kZXgoaSk7ICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGh1cGFpID0gdGhpcy5faHVwYWlUaXBzW2xvY2FsSW5kZXhdO1xyXG4gICAgICAgICAgICBodXBhaS5hY3RpdmUgPSBzZWF0RGF0YS5odWVkO1xyXG4gICAgICAgICAgICBpZihzZWF0RGF0YS5odWVkKXtcclxuICAgICAgICAgICAgICAgIGh1cGFpLmdldENoaWxkQnlOYW1lKFwic3BySHVcIikuYWN0aXZlID0gIXNlYXREYXRhLmlzemltbztcclxuICAgICAgICAgICAgICAgIGh1cGFpLmdldENoaWxkQnlOYW1lKFwic3ByWmltb1wiKS5hY3RpdmUgPSBzZWF0RGF0YS5pc3ppbW87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKHNlYXREYXRhLmh1aW5mbyl7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgc2VhdERhdGEuaHVpbmZvLmxlbmd0aDsgKytqKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IHNlYXREYXRhLmh1aW5mb1tqXTtcclxuICAgICAgICAgICAgICAgICAgICBpZihpbmZvLmlzaHVwYWkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRIdXBhaShsb2NhbEluZGV4LGluZm8ucGFpKTsgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuaGlkZUNodXBhaSgpO1xyXG4gICAgICAgIHRoaXMuaGlkZU9wdGlvbnMoKTtcclxuICAgICAgICB2YXIgc2lkZXMgPSBbXCJyaWdodFwiLFwidXBcIixcImxlZnRcIl07ICAgICAgICBcclxuICAgICAgICB2YXIgZ2FtZUNoaWxkID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiZ2FtZVwiKTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2lkZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgc2lkZUNoaWxkID0gZ2FtZUNoaWxkLmdldENoaWxkQnlOYW1lKHNpZGVzW2ldKTtcclxuICAgICAgICAgICAgdmFyIGhvbGRzID0gc2lkZUNoaWxkLmdldENoaWxkQnlOYW1lKFwiaG9sZHNcIik7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBob2xkcy5jaGlsZHJlbkNvdW50OyArK2ope1xyXG4gICAgICAgICAgICAgICAgdmFyIG5jID0gaG9sZHMuY2hpbGRyZW5bal07XHJcbiAgICAgICAgICAgICAgICBuYy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgbmMuc2NhbGVYID0gMS4wO1xyXG4gICAgICAgICAgICAgICAgbmMuc2NhbGVZID0gMS4wO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwcml0ZSA9IG5jLmdldENvbXBvbmVudChjYy5TcHJpdGUpOyBcclxuICAgICAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuaG9sZHNFbXB0eVtpKzFdO1xyXG4gICAgICAgICAgICB9ICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICBcclxuICAgICAgICBpZihjYy52di5nYW1lTmV0TWdyLmdhbWVzdGF0ZSA9PSBcIlwiICYmIGNjLnZ2LnJlcGxheU1nci5pc1JlcGxheSgpID09IGZhbHNlKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5nYW1lUm9vdC5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucHJlcGFyZVJvb3QuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pbml0TWFoam9uZ3MoKTtcclxuICAgICAgICB2YXIgc2VhdHMgPSBjYy52di5nYW1lTmV0TWdyLnNlYXRzO1xyXG4gICAgICAgIGZvcih2YXIgaSBpbiBzZWF0cyl7XHJcbiAgICAgICAgICAgIHZhciBzZWF0RGF0YSA9IHNlYXRzW2ldO1xyXG4gICAgICAgICAgICB2YXIgbG9jYWxJbmRleCA9IGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0TG9jYWxJbmRleChpKTtcclxuICAgICAgICAgICAgaWYobG9jYWxJbmRleCAhPSAwKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdE90aGVyTWFoam9uZ3Moc2VhdERhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYoaSA9PSBjYy52di5nYW1lTmV0TWdyLnR1cm4pe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdE1vcGFpKGksLTEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRNb3BhaShpLG51bGwpOyAgICBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNob3dDaHVwYWkoKTtcclxuICAgICAgICBpZihjYy52di5nYW1lTmV0TWdyLmN1cmFjdGlvbiAhPSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5zaG93QWN0aW9uKGNjLnZ2LmdhbWVOZXRNZ3IuY3VyYWN0aW9uKTtcclxuICAgICAgICAgICAgY2MudnYuZ2FtZU5ldE1nci5jdXJhY3Rpb24gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmNoZWNrUXVlWWlNZW4oKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uTUpDbGlja2VkOmZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICBpZihjYy52di5nYW1lTmV0TWdyLmlzSHVhblNhblpoYW5nKXtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLmVtaXQoXCJtal9jbGlja2VkXCIsZXZlbnQudGFyZ2V0KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvL+WmguaenOS4jeaYr+iHquW3seeahOi9ruWtkO+8jOWImeW/veeVpVxyXG4gICAgICAgIGlmKGNjLnZ2LmdhbWVOZXRNZ3IudHVybiAhPSBjYy52di5nYW1lTmV0TWdyLnNlYXRJbmRleCl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibm90IHlvdXIgdHVybi5cIiArIGNjLnZ2LmdhbWVOZXRNZ3IudHVybik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX215TUpBcnIubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICBpZihldmVudC50YXJnZXQgPT0gdGhpcy5fbXlNSkFycltpXS5ub2RlKXtcclxuICAgICAgICAgICAgICAgIC8v5aaC5p6c5piv5YaN5qyh54K55Ye777yM5YiZ5Ye654mMXHJcbiAgICAgICAgICAgICAgICBpZihldmVudC50YXJnZXQgPT0gdGhpcy5fc2VsZWN0ZWRNSil7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG9vdCh0aGlzLl9zZWxlY3RlZE1KLm1qSWQpOyBcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZE1KLnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkTUogPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3NlbGVjdGVkTUogIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRNSi55ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC55ID0gMTU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZE1KID0gZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgLy/lh7rniYxcclxuICAgIHNob290OmZ1bmN0aW9uKG1qSWQpe1xyXG4gICAgICAgIGlmKG1qSWQgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2MudnYubmV0LnNlbmQoJ2NodXBhaScsbWpJZCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBnZXRNSkluZGV4OmZ1bmN0aW9uKHNpZGUsaW5kZXgpe1xyXG4gICAgICAgIGlmKHNpZGUgPT0gXCJyaWdodFwiIHx8IHNpZGUgPT0gXCJ1cFwiKXtcclxuICAgICAgICAgICAgcmV0dXJuIDEzIC0gaW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbmRleDtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGluaXRNb3BhaTpmdW5jdGlvbihzZWF0SW5kZXgscGFpKXtcclxuICAgICAgICB2YXIgbG9jYWxJbmRleCA9IGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0TG9jYWxJbmRleChzZWF0SW5kZXgpO1xyXG4gICAgICAgIHZhciBzaWRlID0gY2MudnYubWFoam9uZ21nci5nZXRTaWRlKGxvY2FsSW5kZXgpO1xyXG4gICAgICAgIHZhciBwcmUgPSBjYy52di5tYWhqb25nbWdyLmdldEZvbGRQcmUobG9jYWxJbmRleCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGdhbWVDaGlsZCA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImdhbWVcIik7XHJcbiAgICAgICAgdmFyIHNpZGVDaGlsZCA9IGdhbWVDaGlsZC5nZXRDaGlsZEJ5TmFtZShzaWRlKTtcclxuICAgICAgICB2YXIgaG9sZHMgPSBzaWRlQ2hpbGQuZ2V0Q2hpbGRCeU5hbWUoXCJob2xkc1wiKTtcclxuXHJcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IHRoaXMuZ2V0TUpJbmRleChzaWRlLDEzKTtcclxuICAgICAgICB2YXIgbmMgPSBob2xkcy5jaGlsZHJlbltsYXN0SW5kZXhdO1xyXG5cclxuICAgICAgICBuYy5zY2FsZVggPSAxLjA7XHJcbiAgICAgICAgbmMuc2NhbGVZID0gMS4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICBpZihwYWkgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIG5jLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHBhaSA+PSAwKXtcclxuICAgICAgICAgICAgbmMuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYoc2lkZSA9PSBcInVwXCIpe1xyXG4gICAgICAgICAgICAgICAgbmMuc2NhbGVYID0gMC43MztcclxuICAgICAgICAgICAgICAgIG5jLnNjYWxlWSA9IDAuNzM7ICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gbmMuZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7IFxyXG4gICAgICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKHByZSxwYWkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHBhaSAhPSBudWxsKXtcclxuICAgICAgICAgICAgbmMuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYoc2lkZSA9PSBcInVwXCIpe1xyXG4gICAgICAgICAgICAgICAgbmMuc2NhbGVYID0gMS4wO1xyXG4gICAgICAgICAgICAgICAgbmMuc2NhbGVZID0gMS4wOyAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IG5jLmdldENvbXBvbmVudChjYy5TcHJpdGUpOyBcclxuICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gY2MudnYubWFoam9uZ21nci5nZXRIb2xkc0VtcHR5U3ByaXRlRnJhbWUoc2lkZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgaW5pdEVtcHR5U3ByaXRlczpmdW5jdGlvbihzZWF0SW5kZXgpe1xyXG4gICAgICAgIHZhciBsb2NhbEluZGV4ID0gY2MudnYuZ2FtZU5ldE1nci5nZXRMb2NhbEluZGV4KHNlYXRJbmRleCk7XHJcbiAgICAgICAgdmFyIHNpZGUgPSBjYy52di5tYWhqb25nbWdyLmdldFNpZGUobG9jYWxJbmRleCk7XHJcbiAgICAgICAgdmFyIHByZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0Rm9sZFByZShsb2NhbEluZGV4KTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgZ2FtZUNoaWxkID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiZ2FtZVwiKTtcclxuICAgICAgICB2YXIgc2lkZUNoaWxkID0gZ2FtZUNoaWxkLmdldENoaWxkQnlOYW1lKHNpZGUpO1xyXG4gICAgICAgIHZhciBob2xkcyA9IHNpZGVDaGlsZC5nZXRDaGlsZEJ5TmFtZShcImhvbGRzXCIpO1xyXG4gICAgICAgIHZhciBzcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0RW1wdHlTcHJpdGVGcmFtZShzaWRlKTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgaG9sZHMuY2hpbGRyZW5Db3VudDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIG5jID0gaG9sZHMuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIG5jLnNjYWxlWCA9IDEuMDtcclxuICAgICAgICAgICAgbmMuc2NhbGVZID0gMS4wO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IG5jLmdldENvbXBvbmVudChjYy5TcHJpdGUpOyBcclxuICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gc3ByaXRlRnJhbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgaW5pdE90aGVyTWFoam9uZ3M6ZnVuY3Rpb24oc2VhdERhdGEpe1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJzZWF0OlwiICsgc2VhdERhdGEuc2VhdGluZGV4KTtcclxuICAgICAgICB2YXIgbG9jYWxJbmRleCA9IHRoaXMuZ2V0TG9jYWxJbmRleChzZWF0RGF0YS5zZWF0aW5kZXgpO1xyXG4gICAgICAgIGlmKGxvY2FsSW5kZXggPT0gMCl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNpZGUgPSBjYy52di5tYWhqb25nbWdyLmdldFNpZGUobG9jYWxJbmRleCk7XHJcbiAgICAgICAgdmFyIGdhbWUgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJnYW1lXCIpO1xyXG4gICAgICAgIHZhciBzaWRlUm9vdCA9IGdhbWUuZ2V0Q2hpbGRCeU5hbWUoc2lkZSk7XHJcbiAgICAgICAgdmFyIHNpZGVIb2xkcyA9IHNpZGVSb290LmdldENoaWxkQnlOYW1lKFwiaG9sZHNcIik7XHJcbiAgICAgICAgdmFyIG51bSA9IHNlYXREYXRhLnBlbmdzLmxlbmd0aCArIHNlYXREYXRhLmFuZ2FuZ3MubGVuZ3RoICsgc2VhdERhdGEuZGlhbmdhbmdzLmxlbmd0aCArIHNlYXREYXRhLndhbmdhbmdzLmxlbmd0aDtcclxuICAgICAgICBudW0gKj0gMztcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgaWR4ID0gdGhpcy5nZXRNSkluZGV4KHNpZGUsaSk7XHJcbiAgICAgICAgICAgIHNpZGVIb2xkcy5jaGlsZHJlbltpZHhdLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgcHJlID0gY2MudnYubWFoam9uZ21nci5nZXRGb2xkUHJlKGxvY2FsSW5kZXgpO1xyXG4gICAgICAgIHZhciBob2xkcyA9IHRoaXMuc29ydEhvbGRzKHNlYXREYXRhKTtcclxuICAgICAgICBpZihob2xkcyAhPSBudWxsICYmIGhvbGRzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgaG9sZHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IHRoaXMuZ2V0TUpJbmRleChzaWRlLGkgKyBudW0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHNpZGVIb2xkcy5jaGlsZHJlbltpZHhdLmdldENvbXBvbmVudChjYy5TcHJpdGUpOyBcclxuICAgICAgICAgICAgICAgIGlmKHNpZGUgPT0gXCJ1cFwiKXtcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGUubm9kZS5zY2FsZVggPSAwLjczO1xyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZS5ub2RlLnNjYWxlWSA9IDAuNzM7ICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNwcml0ZS5ub2RlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKHByZSxob2xkc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKGhvbGRzLmxlbmd0aCArIG51bSA9PSAxMyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFzZXRJZHggPSB0aGlzLmdldE1KSW5kZXgoc2lkZSwxMyk7XHJcbiAgICAgICAgICAgICAgICBzaWRlSG9sZHMuY2hpbGRyZW5bbGFzZXRJZHhdLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc29ydEhvbGRzOmZ1bmN0aW9uKHNlYXREYXRhKXtcclxuICAgICAgICB2YXIgaG9sZHMgPSBzZWF0RGF0YS5ob2xkcztcclxuICAgICAgICBpZihob2xkcyA9PSBudWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8v5aaC5p6c5omL5LiK55qE54mM55qE5pWw55uu5pivMiw1LDgsMTEsMTTvvIzooajnpLrmnIDlkI7kuIDlvKDniYzmmK/liJrmkbjliLDnmoTniYxcclxuICAgICAgICB2YXIgbW9wYWkgPSBudWxsO1xyXG4gICAgICAgIHZhciBsID0gaG9sZHMubGVuZ3RoIFxyXG4gICAgICAgIGlmKCBsID09IDIgfHwgbCA9PSA1IHx8IGwgPT0gOCB8fCBsID09IDExIHx8IGwgPT0gMTQpe1xyXG4gICAgICAgICAgICBtb3BhaSA9IGhvbGRzLnBvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgZGluZ3F1ZSA9IHNlYXREYXRhLmRpbmdxdWU7XHJcbiAgICAgICAgY2MudnYubWFoam9uZ21nci5zb3J0TUooaG9sZHMsZGluZ3F1ZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy/lsIbmkbjniYzmt7vliqDliLDmnIDlkI5cclxuICAgICAgICBpZihtb3BhaSAhPSBudWxsKXtcclxuICAgICAgICAgICAgaG9sZHMucHVzaChtb3BhaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBob2xkcztcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGluaXRNYWhqb25nczpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBzZWF0cyA9IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdHM7XHJcbiAgICAgICAgdmFyIHNlYXREYXRhID0gc2VhdHNbY2MudnYuZ2FtZU5ldE1nci5zZWF0SW5kZXhdO1xyXG4gICAgICAgIHZhciBob2xkcyA9IHRoaXMuc29ydEhvbGRzKHNlYXREYXRhKTtcclxuICAgICAgICBpZihob2xkcyA9PSBudWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvL+WIneWni+WMluaJi+eJjFxyXG4gICAgICAgIHZhciBsYWNraW5nTnVtID0gKHNlYXREYXRhLnBlbmdzLmxlbmd0aCArIHNlYXREYXRhLmFuZ2FuZ3MubGVuZ3RoICsgc2VhdERhdGEuZGlhbmdhbmdzLmxlbmd0aCArIHNlYXREYXRhLndhbmdhbmdzLmxlbmd0aCkqMztcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgaG9sZHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgbWppZCA9IGhvbGRzW2ldO1xyXG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5fbXlNSkFycltpICsgbGFja2luZ051bV07XHJcbiAgICAgICAgICAgIHNwcml0ZS5ub2RlLm1qSWQgPSBtamlkO1xyXG4gICAgICAgICAgICBzcHJpdGUubm9kZS55ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5zZXRTcHJpdGVGcmFtZUJ5TUpJRChcIk1fXCIsc3ByaXRlLG1qaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGFja2luZ051bTsgKytpKXtcclxuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHRoaXMuX215TUpBcnJbaV07IFxyXG4gICAgICAgICAgICBzcHJpdGUubm9kZS5taklkID0gbnVsbDtcclxuICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gbnVsbDtcclxuICAgICAgICAgICAgc3ByaXRlLm5vZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcih2YXIgaSA9IGxhY2tpbmdOdW0gKyBob2xkcy5sZW5ndGg7IGkgPCB0aGlzLl9teU1KQXJyLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHRoaXMuX215TUpBcnJbaV07IFxyXG4gICAgICAgICAgICBzcHJpdGUubm9kZS5taklkID0gbnVsbDtcclxuICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gbnVsbDtcclxuICAgICAgICAgICAgc3ByaXRlLm5vZGUuYWN0aXZlID0gZmFsc2U7ICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc2V0U3ByaXRlRnJhbWVCeU1KSUQ6ZnVuY3Rpb24ocHJlLHNwcml0ZSxtamlkKXtcclxuICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKHByZSxtamlkKTtcclxuICAgICAgICBzcHJpdGUubm9kZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgLy/lpoLmnpznjqnlrrbmiYvkuIrov5jmnInnvLrnmoTniYzmsqHmnInmiZPvvIzliJnlj6rog73miZPnvLrniYxcclxuICAgIGNoZWNrUXVlWWlNZW46ZnVuY3Rpb24oKXtcclxuICAgICAgICBpZihjYy52di5nYW1lTmV0TWdyLmNvbmY9PW51bGwgfHwgY2MudnYuZ2FtZU5ldE1nci5jb25mLnR5cGUgIT0gXCJ4bGNoXCIgfHwgIWNjLnZ2LmdhbWVOZXRNZ3IuZ2V0U2VsZkRhdGEoKS5odWVkKXtcclxuICAgICAgICAgICAgLy/pgY3ljobmo4Dmn6XnnIvmmK/lkKbmnInmnKrmiZPnvLrnmoTniYwg5aaC5p6c5pyJ77yM5YiZ6ZyA6KaB5bCG5LiN5piv5a6a57y655qE54mM6K6+572u5Li65LiN5Y+v55SoXHJcbiAgICAgICAgICAgIHZhciBkaW5ncXVlID0gY2MudnYuZ2FtZU5ldE1nci5kaW5ncXVlO1xyXG4gICAgLy8gICAgICAgIGNvbnNvbGUubG9nKGRpbmdxdWUpXHJcbiAgICAgICAgICAgIHZhciBoYXNRdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYoY2MudnYuZ2FtZU5ldE1nci5zZWF0SW5kZXggPT0gY2MudnYuZ2FtZU5ldE1nci50dXJuKXtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9teU1KQXJyLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5fbXlNSkFycltpXTtcclxuICAgIC8vICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic3ByaXRlLm5vZGUubWpJZDpcIiArIHNwcml0ZS5ub2RlLm1qSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHNwcml0ZS5ub2RlLm1qSWQgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gY2MudnYubWFoam9uZ21nci5nZXRNYWhqb25nVHlwZShzcHJpdGUubm9kZS5taklkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZSA9PSBkaW5ncXVlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1F1ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgIC8vICAgICAgICBjb25zb2xlLmxvZyhcImhhc1F1ZTpcIiArIGhhc1F1ZSk7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9teU1KQXJyLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIHZhciBzcHJpdGUgPSB0aGlzLl9teU1KQXJyW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYoc3ByaXRlLm5vZGUubWpJZCAhPSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0TWFoam9uZ1R5cGUoc3ByaXRlLm5vZGUubWpJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaGFzUXVlICYmIHR5cGUgIT0gZGluZ3F1ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5ub2RlLmdldENvbXBvbmVudChjYy5CdXR0b24pLmludGVyYWN0YWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUubm9kZS5nZXRDb21wb25lbnQoY2MuQnV0dG9uKS5pbnRlcmFjdGFibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICBpZihjYy52di5nYW1lTmV0TWdyLnNlYXRJbmRleCA9PSBjYy52di5nYW1lTmV0TWdyLnR1cm4pe1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDE0OyArK2kpe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcHJpdGUgPSB0aGlzLl9teU1KQXJyW2ldOyBcclxuICAgICAgICAgICAgICAgICAgICBpZihzcHJpdGUubm9kZS5hY3RpdmUgPT0gdHJ1ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5ub2RlLmdldENvbXBvbmVudChjYy5CdXR0b24pLmludGVyYWN0YWJsZSA9IGkgPT0gMTM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTQ7ICsraSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHRoaXMuX215TUpBcnJbaV07IFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHNwcml0ZS5ub2RlLmFjdGl2ZSA9PSB0cnVlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLm5vZGUuZ2V0Q29tcG9uZW50KGNjLkJ1dHRvbikuaW50ZXJhY3RhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBnZXRMb2NhbEluZGV4OmZ1bmN0aW9uKGluZGV4KXtcclxuICAgICAgICB2YXIgcmV0ID0gKGluZGV4IC0gY2MudnYuZ2FtZU5ldE1nci5zZWF0SW5kZXggKyA0KSAlIDQ7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIm9sZDpcIiArIGluZGV4ICsgXCIsYmFzZTpcIiArIGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdEluZGV4ICsgXCIsbmV3OlwiICsgcmV0KTtcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25PcHRpb25DbGlja2VkOmZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICBjb25zb2xlLmxvZyhldmVudC50YXJnZXQucGFpKTtcclxuICAgICAgICBpZihldmVudC50YXJnZXQubmFtZSA9PSBcImJ0blBlbmdcIil7XHJcbiAgICAgICAgICAgIGNjLnZ2Lm5ldC5zZW5kKFwicGVuZ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihldmVudC50YXJnZXQubmFtZSA9PSBcImJ0bkdhbmdcIil7XHJcbiAgICAgICAgICAgIGNjLnZ2Lm5ldC5zZW5kKFwiZ2FuZ1wiLGV2ZW50LnRhcmdldC5wYWkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldC5uYW1lID09IFwiYnRuSHVcIil7XHJcbiAgICAgICAgICAgIGNjLnZ2Lm5ldC5zZW5kKFwiaHVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZXZlbnQudGFyZ2V0Lm5hbWUgPT0gXCJidG5HdW9cIil7XHJcbiAgICAgICAgICAgIGNjLnZ2Lm5ldC5zZW5kKFwiZ3VvXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25EZXN0cm95OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJvbkRlc3Ryb3lcIik7XHJcbiAgICAgICAgaWYoY2MudnYpe1xyXG4gICAgICAgICAgICBjYy52di5nYW1lTmV0TWdyLmNsZWFyKCk7ICAgXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwiY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICBsYmxSb29tTm86e1xyXG4gICAgICAgICAgICBkZWZhdWx0Om51bGwsXHJcbiAgICAgICAgICAgIHR5cGU6Y2MuTGFiZWxcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIGZvbzoge1xyXG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuICAgICAgICBfc2VhdHM6W10sXHJcbiAgICAgICAgX3NlYXRzMjpbXSxcclxuICAgICAgICBfdGltZUxhYmVsOm51bGwsXHJcbiAgICAgICAgX3ZvaWNlTXNnUXVldWU6W10sXHJcbiAgICAgICAgX2xhc3RQbGF5aW5nU2VhdDpudWxsLFxyXG4gICAgICAgIF9wbGF5aW5nU2VhdDpudWxsLFxyXG4gICAgICAgIF9sYXN0UGxheVRpbWU6bnVsbCxcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZihjYy52diA9PSBudWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmluaXRWaWV3KCk7XHJcbiAgICAgICAgdGhpcy5pbml0U2VhdHMoKTtcclxuICAgICAgICB0aGlzLmluaXRFdmVudEhhbmRsZXJzKCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBpbml0VmlldzpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBwcmVwYXJlID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwicHJlcGFyZVwiKTtcclxuICAgICAgICB2YXIgc2VhdHMgPSBwcmVwYXJlLmdldENoaWxkQnlOYW1lKFwic2VhdHNcIik7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNlYXRzLmNoaWxkcmVuLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdGhpcy5fc2VhdHMucHVzaChzZWF0cy5jaGlsZHJlbltpXS5nZXRDb21wb25lbnQoXCJTZWF0XCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5yZWZyZXNoQnRucygpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubGJsUm9vbU5vID0gY2MuZmluZChcIkNhbnZhcy9pbmZvYmFyL1pfcm9vbV90eHQvTmV3IExhYmVsXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCk7XHJcbiAgICAgICAgdGhpcy5fdGltZUxhYmVsID0gY2MuZmluZChcIkNhbnZhcy9pbmZvYmFyL3RpbWVcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKTtcclxuICAgICAgICB0aGlzLmxibFJvb21Oby5zdHJpbmcgPSBjYy52di5nYW1lTmV0TWdyLnJvb21JZDtcclxuICAgICAgICB2YXIgZ2FtZUNoaWxkID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiZ2FtZVwiKTtcclxuICAgICAgICB2YXIgc2lkZXMgPSBbXCJteXNlbGZcIixcInJpZ2h0XCIsXCJ1cFwiLFwibGVmdFwiXTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2lkZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgc2lkZU5vZGUgPSBnYW1lQ2hpbGQuZ2V0Q2hpbGRCeU5hbWUoc2lkZXNbaV0pO1xyXG4gICAgICAgICAgICB2YXIgc2VhdCA9IHNpZGVOb2RlLmdldENoaWxkQnlOYW1lKFwic2VhdFwiKTtcclxuICAgICAgICAgICAgdGhpcy5fc2VhdHMyLnB1c2goc2VhdC5nZXRDb21wb25lbnQoXCJTZWF0XCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGJ0bldlY2hhdCA9IGNjLmZpbmQoXCJDYW52YXMvcHJlcGFyZS9idG5XZWljaGF0XCIpO1xyXG4gICAgICAgIGlmKGJ0bldlY2hhdCl7XHJcbiAgICAgICAgICAgIGNjLnZ2LnV0aWxzLmFkZENsaWNrRXZlbnQoYnRuV2VjaGF0LHRoaXMubm9kZSxcIk1KUm9vbVwiLFwib25CdG5XZWljaGF0Q2xpY2tlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHRpdGxlcyA9IGNjLmZpbmQoXCJDYW52YXMvdHlwZVRpdGxlXCIpO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aXRsZXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB0aXRsZXMuY2hpbGRyZW5baV0uYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKGNjLnZ2LmdhbWVOZXRNZ3IuY29uZil7XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gY2MudnYuZ2FtZU5ldE1nci5jb25mLnR5cGU7XHJcbiAgICAgICAgICAgIGlmKHR5cGUgPT0gbnVsbCB8fCB0eXBlID09IFwiXCIpe1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IFwieHpkZFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aXRsZXMuZ2V0Q2hpbGRCeU5hbWUodHlwZSkuYWN0aXZlID0gdHJ1ZTsgICBcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICByZWZyZXNoQnRuczpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBwcmVwYXJlID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwicHJlcGFyZVwiKTtcclxuICAgICAgICB2YXIgYnRuRXhpdCA9IHByZXBhcmUuZ2V0Q2hpbGRCeU5hbWUoXCJidG5FeGl0XCIpO1xyXG4gICAgICAgIHZhciBidG5EaXNwcmVzcyA9IHByZXBhcmUuZ2V0Q2hpbGRCeU5hbWUoXCJidG5EaXNzb2x2ZVwiKTtcclxuICAgICAgICB2YXIgYnRuV2VpY2hhdCA9IHByZXBhcmUuZ2V0Q2hpbGRCeU5hbWUoXCJidG5XZWljaGF0XCIpO1xyXG4gICAgICAgIHZhciBidG5CYWNrID0gcHJlcGFyZS5nZXRDaGlsZEJ5TmFtZShcImJ0bkJhY2tcIik7XHJcbiAgICAgICAgdmFyIGlzSWRsZSA9IGNjLnZ2LmdhbWVOZXRNZ3IubnVtT2ZHYW1lcyA9PSAwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGJ0bkV4aXQuYWN0aXZlID0gIWNjLnZ2LmdhbWVOZXRNZ3IuaXNPd25lcigpICYmIGlzSWRsZTtcclxuICAgICAgICBidG5EaXNwcmVzcy5hY3RpdmUgPSBjYy52di5nYW1lTmV0TWdyLmlzT3duZXIoKSAmJiBpc0lkbGU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgYnRuV2VpY2hhdC5hY3RpdmUgPSBpc0lkbGU7XHJcbiAgICAgICAgYnRuQmFjay5hY3RpdmUgPSBpc0lkbGU7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBpbml0RXZlbnRIYW5kbGVyczpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB0aGlzLm5vZGUub24oJ25ld191c2VyJyxmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgc2VsZi5pbml0U2luZ2xlU2VhdChkYXRhLmRldGFpbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5ub2RlLm9uKCd1c2VyX3N0YXRlX2NoYW5nZWQnLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBzZWxmLmluaXRTaW5nbGVTZWF0KGRhdGEuZGV0YWlsKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfYmVnaW4nLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBzZWxmLnJlZnJlc2hCdG5zKCk7XHJcbiAgICAgICAgICAgIHNlbGYuaW5pdFNlYXRzKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW1lX251bScsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHNlbGYucmVmcmVzaEJ0bnMoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW1lX2h1YW5wYWknLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgaW4gc2VsZi5fc2VhdHMyKXtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3NlYXRzMltpXS5yZWZyZXNoWHVhblBhaVN0YXRlKCk7ICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICB0aGlzLm5vZGUub24oJ2h1YW5wYWlfbm90aWZ5JyxmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgdmFyIGlkeCA9IGRhdGEuZGV0YWlsLnNlYXRpbmRleDtcclxuICAgICAgICAgICAgdmFyIGxvY2FsSWR4ID0gY2MudnYuZ2FtZU5ldE1nci5nZXRMb2NhbEluZGV4KGlkeCk7XHJcbiAgICAgICAgICAgIHNlbGYuX3NlYXRzMltsb2NhbElkeF0ucmVmcmVzaFh1YW5QYWlTdGF0ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubm9kZS5vbignZ2FtZV9odWFucGFpX292ZXInLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgaW4gc2VsZi5fc2VhdHMyKXtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3NlYXRzMltpXS5yZWZyZXNoWHVhblBhaVN0YXRlKCk7ICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5ub2RlLm9uKCd2b2ljZV9tc2cnLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGRhdGEuZGV0YWlsO1xyXG4gICAgICAgICAgICBzZWxmLl92b2ljZU1zZ1F1ZXVlLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgIHNlbGYucGxheVZvaWNlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdjaGF0X3B1c2gnLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGRhdGEuZGV0YWlsO1xyXG4gICAgICAgICAgICB2YXIgaWR4ID0gY2MudnYuZ2FtZU5ldE1nci5nZXRTZWF0SW5kZXhCeUlEKGRhdGEuc2VuZGVyKTtcclxuICAgICAgICAgICAgdmFyIGxvY2FsSWR4ID0gY2MudnYuZ2FtZU5ldE1nci5nZXRMb2NhbEluZGV4KGlkeCk7XHJcbiAgICAgICAgICAgIHNlbGYuX3NlYXRzW2xvY2FsSWR4XS5jaGF0KGRhdGEuY29udGVudCk7XHJcbiAgICAgICAgICAgIHNlbGYuX3NlYXRzMltsb2NhbElkeF0uY2hhdChkYXRhLmNvbnRlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubm9kZS5vbigncXVpY2tfY2hhdF9wdXNoJyxmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhLmRldGFpbDtcclxuICAgICAgICAgICAgdmFyIGlkeCA9IGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0U2VhdEluZGV4QnlJRChkYXRhLnNlbmRlcik7XHJcbiAgICAgICAgICAgIHZhciBsb2NhbElkeCA9IGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0TG9jYWxJbmRleChpZHgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZGF0YS5jb250ZW50O1xyXG4gICAgICAgICAgICB2YXIgaW5mbyA9IGNjLnZ2LmNoYXQuZ2V0UXVpY2tDaGF0SW5mbyhpbmRleCk7XHJcbiAgICAgICAgICAgIHNlbGYuX3NlYXRzW2xvY2FsSWR4XS5jaGF0KGluZm8uY29udGVudCk7XHJcbiAgICAgICAgICAgIHNlbGYuX3NlYXRzMltsb2NhbElkeF0uY2hhdChpbmZvLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY2MudnYuYXVkaW9NZ3IucGxheVNGWChpbmZvLnNvdW5kKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm5vZGUub24oJ2Vtb2ppX3B1c2gnLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGRhdGEuZGV0YWlsO1xyXG4gICAgICAgICAgICB2YXIgaWR4ID0gY2MudnYuZ2FtZU5ldE1nci5nZXRTZWF0SW5kZXhCeUlEKGRhdGEuc2VuZGVyKTtcclxuICAgICAgICAgICAgdmFyIGxvY2FsSWR4ID0gY2MudnYuZ2FtZU5ldE1nci5nZXRMb2NhbEluZGV4KGlkeCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xyXG4gICAgICAgICAgICBzZWxmLl9zZWF0c1tsb2NhbElkeF0uZW1vamkoZGF0YS5jb250ZW50KTtcclxuICAgICAgICAgICAgc2VsZi5fc2VhdHMyW2xvY2FsSWR4XS5lbW9qaShkYXRhLmNvbnRlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgaW5pdFNlYXRzOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHNlYXRzID0gY2MudnYuZ2FtZU5ldE1nci5zZWF0cztcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VhdHMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB0aGlzLmluaXRTaW5nbGVTZWF0KHNlYXRzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBpbml0U2luZ2xlU2VhdDpmdW5jdGlvbihzZWF0KXtcclxuICAgICAgICB2YXIgaW5kZXggPSBjYy52di5nYW1lTmV0TWdyLmdldExvY2FsSW5kZXgoc2VhdC5zZWF0aW5kZXgpO1xyXG4gICAgICAgIHZhciBpc09mZmxpbmUgPSAhc2VhdC5vbmxpbmU7XHJcbiAgICAgICAgdmFyIGlzWmh1YW5nID0gc2VhdC5zZWF0aW5kZXggPT0gY2MudnYuZ2FtZU5ldE1nci5idXR0b247XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJpc09mZmxpbmU6XCIgKyBpc09mZmxpbmUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX3NlYXRzW2luZGV4XS5zZXRJbmZvKHNlYXQubmFtZSxzZWF0LnNjb3JlKTtcclxuICAgICAgICB0aGlzLl9zZWF0c1tpbmRleF0uc2V0UmVhZHkoc2VhdC5yZWFkeSk7XHJcbiAgICAgICAgdGhpcy5fc2VhdHNbaW5kZXhdLnNldE9mZmxpbmUoaXNPZmZsaW5lKTtcclxuICAgICAgICB0aGlzLl9zZWF0c1tpbmRleF0uc2V0SUQoc2VhdC51c2VyaWQpO1xyXG4gICAgICAgIHRoaXMuX3NlYXRzW2luZGV4XS52b2ljZU1zZyhmYWxzZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5fc2VhdHMyW2luZGV4XS5zZXRJbmZvKHNlYXQubmFtZSxzZWF0LnNjb3JlKTtcclxuICAgICAgICB0aGlzLl9zZWF0czJbaW5kZXhdLnNldFpodWFuZyhpc1podWFuZyk7XHJcbiAgICAgICAgdGhpcy5fc2VhdHMyW2luZGV4XS5zZXRPZmZsaW5lKGlzT2ZmbGluZSk7XHJcbiAgICAgICAgdGhpcy5fc2VhdHMyW2luZGV4XS5zZXRJRChzZWF0LnVzZXJpZCk7XHJcbiAgICAgICAgdGhpcy5fc2VhdHMyW2luZGV4XS52b2ljZU1zZyhmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5fc2VhdHMyW2luZGV4XS5yZWZyZXNoWHVhblBhaVN0YXRlKCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbkJ0blNldHRpbmdzQ2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLnZ2LnBvcHVwTWdyLnNob3dTZXR0aW5ncygpOyAgIFxyXG4gICAgfSxcclxuXHJcbiAgICBvbkJ0bkJhY2tDbGlja2VkOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MudnYuYWxlcnQuc2hvdyhcIui/lOWbnuWkp+WOhVwiLFwi6L+U5Zue5aSn5Y6F5oi/6Ze05LuN5Lya5L+d55WZ77yM5b+r5Y676YKA6K+35aSn5LyZ5p2l546p5ZCn77yBXCIsZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgY2MuZGlyZWN0b3IubG9hZFNjZW5lKFwiaGFsbFwiKTsgICAgXHJcbiAgICAgICAgfSx0cnVlKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uQnRuQ2hhdENsaWNrZWQ6ZnVuY3Rpb24oKXtcclxuICAgICAgICBcclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uQnRuV2VpY2hhdENsaWNrZWQ6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgdGl0bGUgPSBcIjzooYDmiJjliLDlupU+XCI7XHJcbiAgICAgICAgaWYoY2MudnYuZ2FtZU5ldE1nci5jb25mLnR5cGUgPT0gXCJ4bGNoXCIpe1xyXG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBcIjzooYDmtYHmiJDmsrM+XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNjLnZ2LmFueXNka01nci5zaGFyZShcIui+vui+vum6u+WwhlwiICsgdGl0bGUsXCLmiL/lj7c6XCIgKyBjYy52di5nYW1lTmV0TWdyLnJvb21JZCArIFwiIOeOqeazlTpcIiArIGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0V2FuZmEoKSk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbkJ0bkRpc3NvbHZlQ2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLnZ2LmFsZXJ0LnNob3coXCLop6PmlaPmiL/pl7RcIixcIuino+aVo+aIv+mXtOS4jeaJo+aIv+WNoe+8jOaYr+WQpuehruWumuino+aVo++8n1wiLGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGNjLnZ2Lm5ldC5zZW5kKFwiZGlzcHJlc3NcIik7ICAgIFxyXG4gICAgICAgIH0sdHJ1ZSk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbkJ0bkV4aXQ6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy52di5uZXQuc2VuZChcImV4aXRcIik7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBwbGF5Vm9pY2U6ZnVuY3Rpb24oKXtcclxuICAgICAgICBpZih0aGlzLl9wbGF5aW5nU2VhdCA9PSBudWxsICYmIHRoaXMuX3ZvaWNlTXNnUXVldWUubGVuZ3RoKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwbGF5Vm9pY2UyXCIpO1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX3ZvaWNlTXNnUXVldWUuc2hpZnQoKTtcclxuICAgICAgICAgICAgdmFyIGlkeCA9IGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0U2VhdEluZGV4QnlJRChkYXRhLnNlbmRlcik7XHJcbiAgICAgICAgICAgIHZhciBsb2NhbEluZGV4ID0gY2MudnYuZ2FtZU5ldE1nci5nZXRMb2NhbEluZGV4KGlkeCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlpbmdTZWF0ID0gbG9jYWxJbmRleDtcclxuICAgICAgICAgICAgdGhpcy5fc2VhdHNbbG9jYWxJbmRleF0udm9pY2VNc2codHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlYXRzMltsb2NhbEluZGV4XS52b2ljZU1zZyh0cnVlKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBtc2dJbmZvID0gSlNPTi5wYXJzZShkYXRhLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIG1zZ2ZpbGUgPSBcInZvaWNlbXNnLmFtclwiO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtc2dJbmZvLm1zZy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBjYy52di52b2ljZU1nci53cml0ZVZvaWNlKG1zZ2ZpbGUsbXNnSW5mby5tc2cpO1xyXG4gICAgICAgICAgICBjYy52di52b2ljZU1nci5wbGF5KG1zZ2ZpbGUpO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0UGxheVRpbWUgPSBEYXRlLm5vdygpICsgbXNnSW5mby50aW1lO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG4gICAgICAgIHZhciBtaW51dGVzID0gTWF0aC5mbG9vcihEYXRlLm5vdygpLzEwMDAvNjApO1xyXG4gICAgICAgIGlmKHRoaXMuX2xhc3RNaW51dGUgIT0gbWludXRlcyl7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RNaW51dGUgPSBtaW51dGVzO1xyXG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgIHZhciBoID0gZGF0ZS5nZXRIb3VycygpO1xyXG4gICAgICAgICAgICBoID0gaCA8IDEwPyBcIjBcIitoOmg7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgbSA9IGRhdGUuZ2V0TWludXRlcygpO1xyXG4gICAgICAgICAgICBtID0gbSA8IDEwPyBcIjBcIittOm07XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVMYWJlbC5zdHJpbmcgPSBcIlwiICsgaCArIFwiOlwiICsgbTsgICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHRoaXMuX2xhc3RQbGF5VGltZSAhPSBudWxsKXtcclxuICAgICAgICAgICAgaWYoRGF0ZS5ub3coKSA+IHRoaXMuX2xhc3RQbGF5VGltZSArIDIwMCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uUGxheWVyT3ZlcigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFBsYXlUaW1lID0gbnVsbDsgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5wbGF5Vm9pY2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICAgICAgXHJcbiAgICBvblBsYXllck92ZXI6ZnVuY3Rpb24oKXtcclxuICAgICAgICBjYy52di5hdWRpb01nci5yZXN1bWVBbGwoKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIm9uUGxheUNhbGxiYWNrOlwiICsgdGhpcy5fcGxheWluZ1NlYXQpO1xyXG4gICAgICAgIHZhciBsb2NhbEluZGV4ID0gdGhpcy5fcGxheWluZ1NlYXQ7XHJcbiAgICAgICAgdGhpcy5fcGxheWluZ1NlYXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3NlYXRzW2xvY2FsSW5kZXhdLnZvaWNlTXNnKGZhbHNlKTtcclxuICAgICAgICB0aGlzLl9zZWF0czJbbG9jYWxJbmRleF0udm9pY2VNc2coZmFsc2UpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25EZXN0cm95OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MudnYudm9pY2VNZ3Iuc3RvcCgpO1xyXG4vLyAgICAgICAgY2MudnYudm9pY2VNZ3Iub25QbGF5Q2FsbGJhY2sgPSBudWxsO1xyXG4gICAgfVxyXG59KTtcclxuIiwidmFyIG1haGpvbmdTcHJpdGVzID0gW107XHJcblxyXG5jYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIGxlZnRBdGxhczp7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6bnVsbCxcclxuICAgICAgICAgICAgdHlwZTpjYy5TcHJpdGVBdGxhc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgcmlnaHRBdGxhczp7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6bnVsbCxcclxuICAgICAgICAgICAgdHlwZTpjYy5TcHJpdGVBdGxhc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgYm90dG9tQXRsYXM6e1xyXG4gICAgICAgICAgICBkZWZhdWx0Om51bGwsXHJcbiAgICAgICAgICAgIHR5cGU6Y2MuU3ByaXRlQXRsYXNcclxuICAgICAgICB9LFxyXG4gICAgICAgIFxyXG4gICAgICAgIGJvdHRvbUZvbGRBdGxhczp7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6bnVsbCxcclxuICAgICAgICAgICAgdHlwZTpjYy5TcHJpdGVBdGxhc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgcGVuZ1ByZWZhYlNlbGY6e1xyXG4gICAgICAgICAgICBkZWZhdWx0Om51bGwsXHJcbiAgICAgICAgICAgIHR5cGU6Y2MuUHJlZmFiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcclxuICAgICAgICBwZW5nUHJlZmFiTGVmdDp7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6bnVsbCxcclxuICAgICAgICAgICAgdHlwZTpjYy5QcmVmYWJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFxyXG4gICAgICAgIGVtcHR5QXRsYXM6e1xyXG4gICAgICAgICAgICBkZWZhdWx0Om51bGwsXHJcbiAgICAgICAgICAgIHR5cGU6Y2MuU3ByaXRlQXRsYXNcclxuICAgICAgICB9LFxyXG4gICAgICAgIFxyXG4gICAgICAgIGhvbGRzRW1wdHk6e1xyXG4gICAgICAgICAgICBkZWZhdWx0OltdLFxyXG4gICAgICAgICAgICB0eXBlOltjYy5TcHJpdGVGcmFtZV1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFxyXG4gICAgICAgIF9zaWRlczpudWxsLFxyXG4gICAgICAgIF9wcmVzOm51bGwsXHJcbiAgICAgICAgX2ZvbGRQcmVzOm51bGwsXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbkxvYWQ6ZnVuY3Rpb24oKXtcclxuICAgICAgICBpZihjYy52diA9PSBudWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zaWRlcyA9IFtcIm15c2VsZlwiLFwicmlnaHRcIixcInVwXCIsXCJsZWZ0XCJdO1xyXG4gICAgICAgIHRoaXMuX3ByZXMgPSBbXCJNX1wiLFwiUl9cIixcIkJfXCIsXCJMX1wiXTtcclxuICAgICAgICB0aGlzLl9mb2xkUHJlcyA9IFtcIkJfXCIsXCJSX1wiLFwiQl9cIixcIkxfXCJdO1xyXG4gICAgICAgIGNjLnZ2Lm1haGpvbmdtZ3IgPSB0aGlzOyBcclxuICAgICAgICAvL+etklxyXG4gICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCAxMDsgKytpKXtcclxuICAgICAgICAgICAgbWFoam9uZ1Nwcml0ZXMucHVzaChcImRvdF9cIiArIGkpOyAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8v5p2hXHJcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IDEwOyArK2kpe1xyXG4gICAgICAgICAgICBtYWhqb25nU3ByaXRlcy5wdXNoKFwiYmFtYm9vX1wiICsgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8v5LiHXHJcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IDEwOyArK2kpe1xyXG4gICAgICAgICAgICBtYWhqb25nU3ByaXRlcy5wdXNoKFwiY2hhcmFjdGVyX1wiICsgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8v5Lit44CB5Y+R44CB55m9XHJcbiAgICAgICAgbWFoam9uZ1Nwcml0ZXMucHVzaChcInJlZFwiKTtcclxuICAgICAgICBtYWhqb25nU3ByaXRlcy5wdXNoKFwiZ3JlZW5cIik7XHJcbiAgICAgICAgbWFoam9uZ1Nwcml0ZXMucHVzaChcIndoaXRlXCIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8v5Lic6KW/5Y2X5YyX6aOOXHJcbiAgICAgICAgbWFoam9uZ1Nwcml0ZXMucHVzaChcIndpbmRfZWFzdFwiKTtcclxuICAgICAgICBtYWhqb25nU3ByaXRlcy5wdXNoKFwid2luZF93ZXN0XCIpO1xyXG4gICAgICAgIG1haGpvbmdTcHJpdGVzLnB1c2goXCJ3aW5kX3NvdXRoXCIpO1xyXG4gICAgICAgIG1haGpvbmdTcHJpdGVzLnB1c2goXCJ3aW5kX25vcnRoXCIpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgZ2V0TWFoam9uZ1Nwcml0ZUJ5SUQ6ZnVuY3Rpb24oaWQpe1xyXG4gICAgICAgIHJldHVybiBtYWhqb25nU3ByaXRlc1tpZF07XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBnZXRNYWhqb25nVHlwZTpmdW5jdGlvbihpZCl7XHJcbiAgICAgIGlmKGlkID49IDAgJiYgaWQgPCA5KXtcclxuICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYoaWQgPj0gOSAmJiBpZCA8IDE4KXtcclxuICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYoaWQgPj0gMTggJiYgaWQgPCAyNyl7XHJcbiAgICAgICAgICByZXR1cm4gMjtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgZ2V0U3ByaXRlRnJhbWVCeU1KSUQ6ZnVuY3Rpb24ocHJlLG1qaWQpe1xyXG4gICAgICAgIHZhciBzcHJpdGVGcmFtZU5hbWUgPSB0aGlzLmdldE1haGpvbmdTcHJpdGVCeUlEKG1qaWQpO1xyXG4gICAgICAgIHNwcml0ZUZyYW1lTmFtZSA9IHByZSArIHNwcml0ZUZyYW1lTmFtZTtcclxuICAgICAgICBpZihwcmUgPT0gXCJNX1wiKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tQXRsYXMuZ2V0U3ByaXRlRnJhbWUoc3ByaXRlRnJhbWVOYW1lKTsgICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihwcmUgPT0gXCJCX1wiKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tRm9sZEF0bGFzLmdldFNwcml0ZUZyYW1lKHNwcml0ZUZyYW1lTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYocHJlID09IFwiTF9cIil7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnRBdGxhcy5nZXRTcHJpdGVGcmFtZShzcHJpdGVGcmFtZU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHByZSA9PSBcIlJfXCIpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodEF0bGFzLmdldFNwcml0ZUZyYW1lKHNwcml0ZUZyYW1lTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgZ2V0QXVkaW9VUkxCeU1KSUQ6ZnVuY3Rpb24oaWQpe1xyXG4gICAgICAgIHZhciByZWFsSWQgPSAwO1xyXG4gICAgICAgIGlmKGlkID49IDAgJiYgaWQgPCA5KXtcclxuICAgICAgICAgICAgcmVhbElkID0gaWQgKyAyMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihpZCA+PSA5ICYmIGlkIDwgMTgpe1xyXG4gICAgICAgICAgICByZWFsSWQgPSBpZCAtIDg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoaWQgPj0gMTggJiYgaWQgPCAyNyl7XHJcbiAgICAgICAgICAgIHJlYWxJZCA9IGlkIC0gNztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwibnYvXCIgKyByZWFsSWQgKyBcIi5tcDNcIjtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGdldEVtcHR5U3ByaXRlRnJhbWU6ZnVuY3Rpb24oc2lkZSl7XHJcbiAgICAgICAgaWYoc2lkZSA9PSBcInVwXCIpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUF0bGFzLmdldFNwcml0ZUZyYW1lKFwiZV9tal9iX3VwXCIpO1xyXG4gICAgICAgIH0gICBcclxuICAgICAgICBlbHNlIGlmKHNpZGUgPT0gXCJteXNlbGZcIil7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtcHR5QXRsYXMuZ2V0U3ByaXRlRnJhbWUoXCJlX21qX2JfYm90dG9tXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHNpZGUgPT0gXCJsZWZ0XCIpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUF0bGFzLmdldFNwcml0ZUZyYW1lKFwiZV9tal9iX2xlZnRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoc2lkZSA9PSBcInJpZ2h0XCIpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUF0bGFzLmdldFNwcml0ZUZyYW1lKFwiZV9tal9iX3JpZ2h0XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIGdldEhvbGRzRW1wdHlTcHJpdGVGcmFtZTpmdW5jdGlvbihzaWRlKXtcclxuICAgICAgICBpZihzaWRlID09IFwidXBcIil7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtcHR5QXRsYXMuZ2V0U3ByaXRlRnJhbWUoXCJlX21qX3VwXCIpO1xyXG4gICAgICAgIH0gICBcclxuICAgICAgICBlbHNlIGlmKHNpZGUgPT0gXCJteXNlbGZcIil7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHNpZGUgPT0gXCJsZWZ0XCIpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUF0bGFzLmdldFNwcml0ZUZyYW1lKFwiZV9tal9sZWZ0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHNpZGUgPT0gXCJyaWdodFwiKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1wdHlBdGxhcy5nZXRTcHJpdGVGcmFtZShcImVfbWpfcmlnaHRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc29ydE1KOmZ1bmN0aW9uKG1haGpvbmdzLGRpbmdxdWUpe1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICBtYWhqb25ncy5zb3J0KGZ1bmN0aW9uKGEsYil7XHJcbiAgICAgICAgICAgIGlmKGRpbmdxdWUgPj0gMCl7XHJcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSBzZWxmLmdldE1haGpvbmdUeXBlKGEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHQyID0gc2VsZi5nZXRNYWhqb25nVHlwZShiKTtcclxuICAgICAgICAgICAgICAgIGlmKHQxICE9IHQyKXtcclxuICAgICAgICAgICAgICAgICAgICBpZihkaW5ncXVlID09IHQxKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZGluZ3F1ZSA9PSB0Mil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgZ2V0U2lkZTpmdW5jdGlvbihsb2NhbEluZGV4KXtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2lkZXNbbG9jYWxJbmRleF07XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBnZXRQcmU6ZnVuY3Rpb24obG9jYWxJbmRleCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZXNbbG9jYWxJbmRleF07XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBnZXRGb2xkUHJlOmZ1bmN0aW9uKGxvY2FsSW5kZXgpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mb2xkUHJlc1tsb2NhbEluZGV4XTtcclxuICAgIH1cclxufSk7XHJcbiIsImlmKHdpbmRvdy5pbyA9PSBudWxsKXtcbiAgICB3aW5kb3cuaW8gPSByZXF1aXJlKFwic29ja2V0LWlvXCIpO1xufVxuIFxudmFyIEdsb2JhbCA9IGNjLkNsYXNzKHtcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXG4gICAgc3RhdGljczoge1xuICAgICAgICBpcDpcIlwiLFxuICAgICAgICBzaW86bnVsbCxcbiAgICAgICAgaXNQaW5naW5nOmZhbHNlLFxuICAgICAgICBmbkRpc2Nvbm5lY3Q6bnVsbCxcbiAgICAgICAgaGFuZGxlcnM6e30sXG4gICAgICAgIGFkZEhhbmRsZXI6ZnVuY3Rpb24oZXZlbnQsZm4pe1xuICAgICAgICAgICAgaWYodGhpcy5oYW5kbGVyc1tldmVudF0pe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZXZlbnQ6XCIgKyBldmVudCArIFwiJyBoYW5kbGVyIGhhcyBiZWVuIHJlZ2lzdGVyZWQuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGV2ZW50ICsgXCIoXCIgKyB0eXBlb2YoZGF0YSkgKyBcIik6XCIgKyAoZGF0YT8gZGF0YS50b1N0cmluZygpOlwibnVsbFwiKSk7XG4gICAgICAgICAgICAgICAgaWYoZXZlbnQgIT0gXCJkaXNjb25uZWN0XCIgJiYgdHlwZW9mKGRhdGEpID09IFwic3RyaW5nXCIpe1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm4oZGF0YSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXI7IFxuICAgICAgICAgICAgaWYodGhpcy5zaW8pe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVnaXN0ZXI6ZnVuY3Rpb24gXCIgKyBldmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaW8ub24oZXZlbnQsaGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3Q6ZnVuY3Rpb24oZm5Db25uZWN0LGZuRXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgJ3JlY29ubmVjdGlvbic6ZmFsc2UsXG4gICAgICAgICAgICAgICAgJ2ZvcmNlIG5ldyBjb25uZWN0aW9uJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAndHJhbnNwb3J0cyc6Wyd3ZWJzb2NrZXQnLCAncG9sbGluZyddXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNpbyA9IHdpbmRvdy5pby5jb25uZWN0KHRoaXMuaXAsb3B0cyk7XG4gICAgICAgICAgICB0aGlzLnNpby5vbigncmVjb25uZWN0JyxmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZWNvbm5lY3Rpb24nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zaW8ub24oJ2Nvbm5lY3QnLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgICAgIHNlbGYuc2lvLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm5Db25uZWN0KGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuc2lvLm9uKCdkaXNjb25uZWN0JyxmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImRpc2Nvbm5lY3RcIik7XG4gICAgICAgICAgICAgICAgc2VsZi5zaW8uY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuc2lvLm9uKCdjb25uZWN0X2ZhaWxlZCcsZnVuY3Rpb24gKCl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2Nvbm5lY3RfZmFpbGVkJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gdGhpcy5oYW5kbGVycyl7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5oYW5kbGVyc1trZXldO1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZih2YWx1ZSkgPT0gXCJmdW5jdGlvblwiKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoa2V5ID09ICdkaXNjb25uZWN0Jyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZuRGlzY29ubmVjdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlZ2lzdGVyOmZ1bmN0aW9uIFwiICsga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2lvLm9uKGtleSx2YWx1ZSk7ICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuc3RhcnRIZWFyYmVhdCgpO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgc3RhcnRIZWFyYmVhdDpmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5zaW8ub24oJ2dhbWVfcG9uZycsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZ2FtZV9wb25nJyk7XG4gICAgICAgICAgICAgICAgc2VsZi5sYXN0UmVjaWV2ZVRpbWUgPSBEYXRlLm5vdygpOyBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVjaWV2ZVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgY29uc29sZS5sb2coMSk7XG4gICAgICAgICAgICBpZighc2VsZi5pc1Bpbmdpbmcpe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKDEpO1xuICAgICAgICAgICAgICAgIHNlbGYuaXNQaW5naW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzZXRJbnRlcnZhbChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoc2VsZi5zaW8pe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihEYXRlLm5vdygpIC0gc2VsZi5sYXN0UmVjaWV2ZVRpbWUgPiAxMDAwMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sNTAwMCk7XG4gICAgICAgICAgICB9ICAgXG4gICAgICAgIH0sXG4gICAgICAgIHNlbmQ6ZnVuY3Rpb24oZXZlbnQsZGF0YSl7XG4gICAgICAgICAgICBpZih0aGlzLnNpby5jb25uZWN0ZWQpe1xuICAgICAgICAgICAgICAgIGlmKGRhdGEgIT0gbnVsbCAmJiAodHlwZW9mKGRhdGEpID09IFwib2JqZWN0XCIpKXtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGRhdGEpOyAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2lvLmVtaXQoZXZlbnQsZGF0YSk7ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgcGluZzpmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5zZW5kKCdnYW1lX3BpbmcnKTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGNsb3NlOmZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnY2xvc2UnKTtcbiAgICAgICAgICAgIGlmKHRoaXMuc2lvICYmIHRoaXMuc2lvLmNvbm5lY3RlZCl7XG4gICAgICAgICAgICAgICAgdGhpcy5zaW8uY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zaW8uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2lvID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMuZm5EaXNjb25uZWN0KXtcbiAgICAgICAgICAgICAgICB0aGlzLmZuRGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm5EaXNjb25uZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHRlc3Q6ZnVuY3Rpb24oZm5SZXN1bHQpe1xuICAgICAgICAgICAgdmFyIHhociA9IG51bGw7XG4gICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbihyZXQpe1xuICAgICAgICAgICAgICAgIGZuUmVzdWx0KHJldC5pc29ubGluZSk7XG4gICAgICAgICAgICAgICAgeGhyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGFyciA9IHRoaXMuaXAuc3BsaXQoJzonKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGFjY291bnQ6Y2MudnYudXNlck1nci5hY2NvdW50LFxuICAgICAgICAgICAgICAgIHNpZ246Y2MudnYudXNlck1nci5zaWduLFxuICAgICAgICAgICAgICAgIGlwOmFyclswXSxcbiAgICAgICAgICAgICAgICBwb3J0OmFyclsxXSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhociA9IGNjLnZ2Lmh0dHAuc2VuZFJlcXVlc3QoXCIvaXNfc2VydmVyX29ubGluZVwiLGRhdGEsZm4pO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGlmKHhocil7XG4gICAgICAgICAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICBmblJlc3VsdChmYWxzZSk7ICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LDE1MDApO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgICAgICAgICdyZWNvbm5lY3Rpb24nOmZhbHNlLFxuICAgICAgICAgICAgICAgICdmb3JjZSBuZXcgY29ubmVjdGlvbic6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3RyYW5zcG9ydHMnOlsnd2Vic29ja2V0JywgJ3BvbGxpbmcnXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy50ZXN0c2lvID0gd2luZG93LmlvLmNvbm5lY3QodGhpcy5pcCxvcHRzKTtcbiAgICAgICAgICAgIHRoaXMudGVzdHNpby5vbignY29ubmVjdCcsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnY29ubmVjdCcpO1xuICAgICAgICAgICAgICAgIHNlbGYudGVzdHNpby5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHNlbGYudGVzdHNpbyA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm5SZXN1bHQodHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudGVzdHNpby5vbignY29ubmVjdF9lcnJvcicsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnY29ubmVjdF9mYWlsZWQnKTtcbiAgICAgICAgICAgICAgICBzZWxmLnRlc3RzaW8gPSBudWxsO1xuICAgICAgICAgICAgICAgIGZuUmVzdWx0KGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKi9cbiAgICAgICAgfVxuICAgIH0sXG59KTsiLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIC8vIGZvbzoge1xyXG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgY29tcG9uZW50IGF0dGFjaGluZ1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYSBub2RlIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcclxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXHJcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxyXG4gICAgICAgIC8vIH0sXHJcbiAgICAgICAgLy8gLi4uXHJcbiAgICAgICAgX2d1b2h1Om51bGwsXHJcbiAgICAgICAgX2luZm86bnVsbCxcclxuICAgICAgICBfZ3VvaHVUaW1lOi0xLFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2d1b2h1ID0gY2MuZmluZChcIkNhbnZhcy90aXBfbm90aWNlXCIpO1xyXG4gICAgICAgIHRoaXMuX2d1b2h1LmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX2luZm8gPSBjYy5maW5kKFwiQ2FudmFzL3RpcF9ub3RpY2UvaW5mb1wiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB0aGlzLm5vZGUub24oJ3B1c2hfbm90aWNlJyxmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhLmRldGFpbDtcclxuICAgICAgICAgICAgc2VsZi5fZ3VvaHUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2VsZi5fZ3VvaHVUaW1lID0gZGF0YS50aW1lO1xyXG4gICAgICAgICAgICBzZWxmLl9pbmZvLnN0cmluZyA9IGRhdGEuaW5mbztcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcbiAgICAgICBpZih0aGlzLl9ndW9odVRpbWUgPiAwKXtcclxuICAgICAgICAgICB0aGlzLl9ndW9odVRpbWUgLT0gZHQ7XHJcbiAgICAgICAgICAgaWYodGhpcy5fZ3VvaHVUaW1lIDwgMCl7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX2d1b2h1LmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH1cclxuICAgIH0sXHJcbn0pO1xyXG4iLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIC8vIGZvbzoge1xyXG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgY29tcG9uZW50IGF0dGFjaGluZ1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYSBub2RlIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcclxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXHJcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxyXG4gICAgICAgIC8vIH0sXHJcbiAgICAgICAgLy8gLi4uXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGJ0biA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImJ0bl9iYWNrXCIpO1xyXG4gICAgICAgIGNjLnZ2LnV0aWxzLmFkZENsaWNrRXZlbnQoYnRuLHRoaXMubm9kZSxcIk9uQmFja1wiLFwib25CdG5DbGlja2VkXCIpOyAgICAgICAgXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbkJ0bkNsaWNrZWQ6ZnVuY3Rpb24oZXZlbnQpe1xyXG4gICAgICAgIGlmKGV2ZW50LnRhcmdldC5uYW1lID09IFwiYnRuX2JhY2tcIil7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCxcclxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XHJcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxyXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcclxuICAgICAgICAvLyB9LFxyXG4gICAgICAgIC8vIC4uLlxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmKCFjYy52dil7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGdhbWVDaGlsZCA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImdhbWVcIik7XHJcbiAgICAgICAgdmFyIG15c2VsZiA9IGdhbWVDaGlsZC5nZXRDaGlsZEJ5TmFtZShcIm15c2VsZlwiKTtcclxuICAgICAgICB2YXIgcGVuZ2FuZ3Jvb3QgPSBteXNlbGYuZ2V0Q2hpbGRCeU5hbWUoXCJwZW5nZ2FuZ3NcIik7XHJcbiAgICAgICAgdmFyIHJlYWx3aWR0aCA9IGNjLmRpcmVjdG9yLmdldFZpc2libGVTaXplKCkud2lkdGg7XHJcbiAgICAgICAgdmFyIHNjYWxlID0gcmVhbHdpZHRoIC8gMTI4MDtcclxuICAgICAgICBwZW5nYW5ncm9vdC5zY2FsZVggKj0gc2NhbGU7XHJcbiAgICAgICAgcGVuZ2FuZ3Jvb3Quc2NhbGVZICo9IHNjYWxlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB0aGlzLm5vZGUub24oJ3Blbmdfbm90aWZ5JyxmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgLy/liLfmlrDmiYDmnInnmoTniYxcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhkYXRhLmRldGFpbCk7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gZGF0YS5kZXRhaWw7XHJcbiAgICAgICAgICAgIHNlbGYub25QZW5nR2FuZ0NoYW5nZWQoZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW5nX25vdGlmeScsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIC8v5Yi35paw5omA5pyJ55qE54mMXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coZGF0YS5kZXRhaWwpO1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGRhdGEuZGV0YWlsO1xyXG4gICAgICAgICAgICBzZWxmLm9uUGVuZ0dhbmdDaGFuZ2VkKGRhdGEuc2VhdERhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubm9kZS5vbignZ2FtZV9iZWdpbicsZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHNlbGYub25HYW1lQmVpbigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBzZWF0cyA9IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdHM7XHJcbiAgICAgICAgZm9yKHZhciBpIGluIHNlYXRzKXtcclxuICAgICAgICAgICAgdGhpcy5vblBlbmdHYW5nQ2hhbmdlZChzZWF0c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25HYW1lQmVpbjpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuaGlkZVNpZGUoXCJteXNlbGZcIik7XHJcbiAgICAgICAgdGhpcy5oaWRlU2lkZShcInJpZ2h0XCIpO1xyXG4gICAgICAgIHRoaXMuaGlkZVNpZGUoXCJ1cFwiKTtcclxuICAgICAgICB0aGlzLmhpZGVTaWRlKFwibGVmdFwiKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGhpZGVTaWRlOmZ1bmN0aW9uKHNpZGUpe1xyXG4gICAgICAgIHZhciBnYW1lQ2hpbGQgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJnYW1lXCIpO1xyXG4gICAgICAgIHZhciBteXNlbGYgPSBnYW1lQ2hpbGQuZ2V0Q2hpbGRCeU5hbWUoc2lkZSk7XHJcbiAgICAgICAgdmFyIHBlbmdhbmdyb290ID0gbXlzZWxmLmdldENoaWxkQnlOYW1lKFwicGVuZ2dhbmdzXCIpO1xyXG4gICAgICAgIGlmKHBlbmdhbmdyb290KXtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBlbmdhbmdyb290LmNoaWxkcmVuQ291bnQ7ICsraSl7XHJcbiAgICAgICAgICAgICAgICBwZW5nYW5ncm9vdC5jaGlsZHJlbltpXS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uUGVuZ0dhbmdDaGFuZ2VkOmZ1bmN0aW9uKHNlYXREYXRhKXtcclxuICAgICAgICBcclxuICAgICAgICBpZihzZWF0RGF0YS5hbmdhbmdzID09IG51bGwgJiYgc2VhdERhdGEuZGlhbmdhbmdzID09IG51bGwgJiYgc2VhdERhdGEud2FuZ2FuZ3MgPT0gbnVsbCAmJiBzZWF0RGF0YS5wZW5ncyA9PSBudWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbG9jYWxJbmRleCA9IGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0TG9jYWxJbmRleChzZWF0RGF0YS5zZWF0aW5kZXgpO1xyXG4gICAgICAgIHZhciBzaWRlID0gY2MudnYubWFoam9uZ21nci5nZXRTaWRlKGxvY2FsSW5kZXgpO1xyXG4gICAgICAgIHZhciBwcmUgPSBjYy52di5tYWhqb25nbWdyLmdldEZvbGRQcmUobG9jYWxJbmRleCk7XHJcbiAgICAgICBcclxuICAgICAgICBjb25zb2xlLmxvZyhcIm9uUGVuZ0dhbmdDaGFuZ2VkXCIgKyBsb2NhbEluZGV4KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgdmFyIGdhbWVDaGlsZCA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImdhbWVcIik7XHJcbiAgICAgICAgdmFyIG15c2VsZiA9IGdhbWVDaGlsZC5nZXRDaGlsZEJ5TmFtZShzaWRlKTtcclxuICAgICAgICB2YXIgcGVuZ2FuZ3Jvb3QgPSBteXNlbGYuZ2V0Q2hpbGRCeU5hbWUoXCJwZW5nZ2FuZ3NcIik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBlbmdhbmdyb290LmNoaWxkcmVuQ291bnQ7ICsraSl7XHJcbiAgICAgICAgICAgIHBlbmdhbmdyb290LmNoaWxkcmVuW2ldLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+WIneWni+WMluadoOeJjFxyXG4gICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGdhbmdzID0gc2VhdERhdGEuYW5nYW5nc1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBnYW5ncy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBtamlkID0gZ2FuZ3NbaV07XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdFBlbmdBbmRHYW5ncyhwZW5nYW5ncm9vdCxzaWRlLHByZSxpbmRleCxtamlkLFwiYW5nYW5nXCIpO1xyXG4gICAgICAgICAgICBpbmRleCsrOyAgICBcclxuICAgICAgICB9IFxyXG4gICAgICAgIHZhciBnYW5ncyA9IHNlYXREYXRhLmRpYW5nYW5nc1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBnYW5ncy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBtamlkID0gZ2FuZ3NbaV07XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdFBlbmdBbmRHYW5ncyhwZW5nYW5ncm9vdCxzaWRlLHByZSxpbmRleCxtamlkLFwiZGlhbmdhbmdcIik7XHJcbiAgICAgICAgICAgIGluZGV4Kys7ICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgZ2FuZ3MgPSBzZWF0RGF0YS53YW5nYW5nc1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBnYW5ncy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBtamlkID0gZ2FuZ3NbaV07XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdFBlbmdBbmRHYW5ncyhwZW5nYW5ncm9vdCxzaWRlLHByZSxpbmRleCxtamlkLFwid2FuZ2FuZ1wiKTtcclxuICAgICAgICAgICAgaW5kZXgrKzsgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8v5Yid5aeL5YyW56Kw54mMXHJcbiAgICAgICAgdmFyIHBlbmdzID0gc2VhdERhdGEucGVuZ3NcclxuICAgICAgICBpZihwZW5ncyl7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwZW5ncy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWppZCA9IHBlbmdzW2ldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0UGVuZ0FuZEdhbmdzKHBlbmdhbmdyb290LHNpZGUscHJlLGluZGV4LG1qaWQsXCJwZW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgaW5kZXgrKzsgICAgXHJcbiAgICAgICAgICAgIH0gICAgXHJcbiAgICAgICAgfSAgICAgICAgXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBpbml0UGVuZ0FuZEdhbmdzOmZ1bmN0aW9uKHBlbmdhbmdyb290LHNpZGUscHJlLGluZGV4LG1qaWQsZmxhZyl7XHJcbiAgICAgICAgdmFyIHBncm9vdCA9IG51bGw7XHJcbiAgICAgICAgaWYocGVuZ2FuZ3Jvb3QuY2hpbGRyZW5Db3VudCA8PSBpbmRleCl7XHJcbiAgICAgICAgICAgIGlmKHNpZGUgPT0gXCJsZWZ0XCIgfHwgc2lkZSA9PSBcInJpZ2h0XCIpe1xyXG4gICAgICAgICAgICAgICAgcGdyb290ID0gY2MuaW5zdGFudGlhdGUoY2MudnYubWFoam9uZ21nci5wZW5nUHJlZmFiTGVmdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHBncm9vdCA9IGNjLmluc3RhbnRpYXRlKGNjLnZ2Lm1haGpvbmdtZ3IucGVuZ1ByZWZhYlNlbGYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBwZW5nYW5ncm9vdC5hZGRDaGlsZChwZ3Jvb3QpOyAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgcGdyb290ID0gcGVuZ2FuZ3Jvb3QuY2hpbGRyZW5baW5kZXhdO1xyXG4gICAgICAgICAgICBwZ3Jvb3QuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoc2lkZSA9PSBcImxlZnRcIil7XHJcbiAgICAgICAgICAgIHBncm9vdC55ID0gLShpbmRleCAqIDI1ICogMyk7ICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihzaWRlID09IFwicmlnaHRcIil7XHJcbiAgICAgICAgICAgIHBncm9vdC55ID0gKGluZGV4ICogMjUgKiAzKTtcclxuICAgICAgICAgICAgcGdyb290LnNldExvY2FsWk9yZGVyKC1pbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoc2lkZSA9PSBcIm15c2VsZlwiKXtcclxuICAgICAgICAgICAgcGdyb290LnggPSBpbmRleCAqIDU1ICogMyArIGluZGV4ICogMTA7ICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgcGdyb290LnggPSAtKGluZGV4ICogNTUqMyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc3ByaXRlcyA9IHBncm9vdC5nZXRDb21wb25lbnRzSW5DaGlsZHJlbihjYy5TcHJpdGUpO1xyXG4gICAgICAgIGZvcih2YXIgcyA9IDA7IHMgPCBzcHJpdGVzLmxlbmd0aDsgKytzKXtcclxuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHNwcml0ZXNbc107XHJcbiAgICAgICAgICAgIGlmKHNwcml0ZS5ub2RlLm5hbWUgPT0gXCJnYW5nXCIpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzR2FuZyA9IGZsYWcgIT0gXCJwZW5nXCI7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGUubm9kZS5hY3RpdmUgPSBpc0dhbmc7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGUubm9kZS5zY2FsZVggPSAxLjA7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGUubm9kZS5zY2FsZVkgPSAxLjA7XHJcbiAgICAgICAgICAgICAgICBpZihmbGFnID09IFwiYW5nYW5nXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0RW1wdHlTcHJpdGVGcmFtZShzaWRlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihzaWRlID09IFwibXlzZWxmXCIgfHwgc2lkZSA9PSBcInVwXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUubm9kZS5zY2FsZVggPSAxLjQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5ub2RlLnNjYWxlWSA9IDEuNDsgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9ICAgXHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0U3ByaXRlRnJhbWVCeU1KSUQocHJlLG1qaWQpOyAgICBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNleyBcclxuICAgICAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0U3ByaXRlRnJhbWVCeU1KSUQocHJlLG1qaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xyXG4gICAgLy8gdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcclxuXHJcbiAgICAvLyB9LFxyXG59KTtcclxuIiwiY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAvLyBmb286IHtcclxuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLFxyXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcclxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXHJcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxyXG4gICAgICAgIC8vIH0sXHJcbiAgICAgICAgLy8gLi4uXHJcbiAgICAgICAgX3BvcHVwcm9vdDpudWxsLFxyXG4gICAgICAgIF9zZXR0aW5nczpudWxsLFxyXG4gICAgICAgIF9kaXNzb2x2ZU5vdGljZTpudWxsLFxyXG4gICAgICAgIFxyXG4gICAgICAgIF9lbmRUaW1lOi0xLFxyXG4gICAgICAgIF9leHRyYUluZm86bnVsbCxcclxuICAgICAgICBfbm90aWNlTGFiZWw6bnVsbCxcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZihjYy52diA9PSBudWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBjYy52di5wb3B1cE1nciA9IHRoaXM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5fcG9wdXByb290ID0gY2MuZmluZChcIkNhbnZhcy9wb3B1cHNcIik7XHJcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSBjYy5maW5kKFwiQ2FudmFzL3BvcHVwcy9zZXR0aW5nc1wiKTtcclxuICAgICAgICB0aGlzLl9kaXNzb2x2ZU5vdGljZSA9IGNjLmZpbmQoXCJDYW52YXMvcG9wdXBzL2Rpc3NvbHZlX25vdGljZVwiKTtcclxuICAgICAgICB0aGlzLl9ub3RpY2VMYWJlbCA9IHRoaXMuX2Rpc3NvbHZlTm90aWNlLmdldENoaWxkQnlOYW1lKFwiaW5mb1wiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuY2xvc2VBbGwoKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmFkZEJ0bkhhbmRsZXIoXCJzZXR0aW5ncy9idG5fY2xvc2VcIik7XHJcbiAgICAgICAgdGhpcy5hZGRCdG5IYW5kbGVyKFwic2V0dGluZ3MvYnRuX3NxanNmalwiKTtcclxuICAgICAgICB0aGlzLmFkZEJ0bkhhbmRsZXIoXCJkaXNzb2x2ZV9ub3RpY2UvYnRuX2FncmVlXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkQnRuSGFuZGxlcihcImRpc3NvbHZlX25vdGljZS9idG5fcmVqZWN0XCIpO1xyXG4gICAgICAgIHRoaXMuYWRkQnRuSGFuZGxlcihcImRpc3NvbHZlX25vdGljZS9idG5fb2tcIik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMubm9kZS5vbihcImRpc3NvbHZlX25vdGljZVwiLGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kZXRhaWw7XHJcbiAgICAgICAgICAgIHNlbGYuc2hvd0Rpc3NvbHZlTm90aWNlKGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubm9kZS5vbihcImRpc3NvbHZlX2NhbmNlbFwiLGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICAgICAgc2VsZi5jbG9zZUFsbCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc3RhcnQ6ZnVuY3Rpb24oKXtcclxuICAgICAgICBpZihjYy52di5nYW1lTmV0TWdyLmRpc3NvdmVEYXRhKXtcclxuICAgICAgICAgICAgdGhpcy5zaG93RGlzc29sdmVOb3RpY2UoY2MudnYuZ2FtZU5ldE1nci5kaXNzb3ZlRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgYWRkQnRuSGFuZGxlcjpmdW5jdGlvbihidG5OYW1lKXtcclxuICAgICAgICB2YXIgYnRuID0gY2MuZmluZChcIkNhbnZhcy9wb3B1cHMvXCIgKyBidG5OYW1lKTtcclxuICAgICAgICB0aGlzLmFkZENsaWNrRXZlbnQoYnRuLHRoaXMubm9kZSxcIlBvcHVwTWdyXCIsXCJvbkJ0bkNsaWNrZWRcIik7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBhZGRDbGlja0V2ZW50OmZ1bmN0aW9uKG5vZGUsdGFyZ2V0LGNvbXBvbmVudCxoYW5kbGVyKXtcclxuICAgICAgICB2YXIgZXZlbnRIYW5kbGVyID0gbmV3IGNjLkNvbXBvbmVudC5FdmVudEhhbmRsZXIoKTtcclxuICAgICAgICBldmVudEhhbmRsZXIudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIGV2ZW50SGFuZGxlci5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgZXZlbnRIYW5kbGVyLmhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cclxuICAgICAgICB2YXIgY2xpY2tFdmVudHMgPSBub2RlLmdldENvbXBvbmVudChjYy5CdXR0b24pLmNsaWNrRXZlbnRzO1xyXG4gICAgICAgIGNsaWNrRXZlbnRzLnB1c2goZXZlbnRIYW5kbGVyKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uQnRuQ2xpY2tlZDpmdW5jdGlvbihldmVudCl7XHJcbiAgICAgICAgdGhpcy5jbG9zZUFsbCgpO1xyXG4gICAgICAgIHZhciBidG5OYW1lID0gZXZlbnQudGFyZ2V0Lm5hbWU7XHJcbiAgICAgICAgaWYoYnRuTmFtZSA9PSBcImJ0bl9hZ3JlZVwiKXtcclxuICAgICAgICAgICAgY2MudnYubmV0LnNlbmQoXCJkaXNzb2x2ZV9hZ3JlZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihidG5OYW1lID09IFwiYnRuX3JlamVjdFwiKXtcclxuICAgICAgICAgICAgY2MudnYubmV0LnNlbmQoXCJkaXNzb2x2ZV9yZWplY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoYnRuTmFtZSA9PSBcImJ0bl9zcWpzZmpcIil7XHJcbiAgICAgICAgICAgIGNjLnZ2Lm5ldC5zZW5kKFwiZGlzc29sdmVfcmVxdWVzdFwiKTsgXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgY2xvc2VBbGw6ZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLl9wb3B1cHJvb3QuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZGlzc29sdmVOb3RpY2UuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzaG93U2V0dGluZ3M6ZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLmNsb3NlQWxsKCk7XHJcbiAgICAgICAgdGhpcy5fcG9wdXByb290LmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MuYWN0aXZlID0gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNob3dEaXNzb2x2ZVJlcXVlc3Q6ZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLmNsb3NlQWxsKCk7XHJcbiAgICAgICAgdGhpcy5fcG9wdXByb290LmFjdGl2ZSA9IHRydWU7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzaG93RGlzc29sdmVOb3RpY2U6ZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgdGhpcy5fZW5kVGltZSA9IERhdGUubm93KCkvMTAwMCArIGRhdGEudGltZTtcclxuICAgICAgICB0aGlzLl9leHRyYUluZm8gPSBcIlwiO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkYXRhLnN0YXRlcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBiID0gZGF0YS5zdGF0ZXNbaV07XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gY2MudnYuZ2FtZU5ldE1nci5zZWF0c1tpXS5uYW1lO1xyXG4gICAgICAgICAgICBpZihiKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2V4dHJhSW5mbyArPSBcIlxcblvlt7LlkIzmhI9dIFwiKyBuYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9leHRyYUluZm8gKz0gXCJcXG5b5b6F56Gu6K6kXSBcIisgbmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNsb3NlQWxsKCk7XHJcbiAgICAgICAgdGhpcy5fcG9wdXByb290LmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fZGlzc29sdmVOb3RpY2UuYWN0aXZlID0gdHJ1ZTs7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcclxuICAgICAgICBpZih0aGlzLl9lbmRUaW1lID4gMCl7XHJcbiAgICAgICAgICAgIHZhciBsYXN0VGltZSA9IHRoaXMuX2VuZFRpbWUgLSBEYXRlLm5vdygpIC8gMTAwMDtcclxuICAgICAgICAgICAgaWYobGFzdFRpbWUgPCAwKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZFRpbWUgPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIG0gPSBNYXRoLmZsb29yKGxhc3RUaW1lIC8gNjApO1xyXG4gICAgICAgICAgICB2YXIgcyA9IE1hdGguY2VpbChsYXN0VGltZSAtIG0qNjApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgICAgIGlmKG0gPiAwKXtcclxuICAgICAgICAgICAgICAgIHN0ciArPSBtICsgXCLliIZcIjsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuX25vdGljZUxhYmVsLnN0cmluZyA9IHN0ciArIHMgKyBcIuenkuWQjuaIv+mXtOWwhuiHquWKqOino+aVo1wiICsgdGhpcy5fZXh0cmFJbmZvO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbn0pO1xyXG4iLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIC8vIGZvbzoge1xyXG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuICAgICAgICB0YXJnZXQ6Y2MuTm9kZSxcclxuICAgICAgICBzcHJpdGU6Y2MuU3ByaXRlRnJhbWUsXHJcbiAgICAgICAgY2hlY2tlZFNwcml0ZTpjYy5TcHJpdGVGcmFtZSxcclxuICAgICAgICBjaGVja2VkOmZhbHNlLFxyXG4gICAgICAgIGdyb3VwSWQ6LTEsXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYoY2MudnYgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoY2MudnYucmFkaW9ncm91cG1nciA9PSBudWxsKXtcclxuICAgICAgICAgICAgdmFyIFJhZGlvR3JvdXBNZ3IgPSByZXF1aXJlKFwiUmFkaW9Hcm91cE1nclwiKTtcclxuICAgICAgICAgICAgY2MudnYucmFkaW9ncm91cG1nciA9IG5ldyBSYWRpb0dyb3VwTWdyKCk7XHJcbiAgICAgICAgICAgIGNjLnZ2LnJhZGlvZ3JvdXBtZ3IuaW5pdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmxvZyh0eXBlb2YoY2MudnYucmFkaW9ncm91cG1nci5hZGQpKTtcclxuICAgICAgICBjYy52di5yYWRpb2dyb3VwbWdyLmFkZCh0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICByZWZyZXNoOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHRhcmdldFNwcml0ZSA9IHRoaXMudGFyZ2V0LmdldENvbXBvbmVudChjYy5TcHJpdGUpO1xyXG4gICAgICAgIGlmKHRoaXMuY2hlY2tlZCl7XHJcbiAgICAgICAgICAgIHRhcmdldFNwcml0ZS5zcHJpdGVGcmFtZSA9IHRoaXMuY2hlY2tlZFNwcml0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgdGFyZ2V0U3ByaXRlLnNwcml0ZUZyYW1lID0gdGhpcy5zcHJpdGU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgY2hlY2s6ZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgICAgIHRoaXMuY2hlY2tlZCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25DbGlja2VkOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgY2MudnYucmFkaW9ncm91cG1nci5jaGVjayh0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxuICAgIFxyXG4gICAgb25EZXN0cm95OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYoY2MudnYgJiYgY2MudnYucmFkaW9ncm91cG1ncil7XHJcbiAgICAgICAgICAgIGNjLnZ2LnJhZGlvZ3JvdXBtZ3IuZGVsKHRoaXMpOyAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCxcclxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XHJcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxyXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcclxuICAgICAgICAvLyB9LFxyXG4gICAgICAgIC8vIC4uLlxyXG4gICAgICAgIF9ncm91cHM6bnVsbFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9ncm91cHMgPSB7fTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGFkZDpmdW5jdGlvbihyYWRpb0J1dHRvbil7XHJcbiAgICAgICAgdmFyIGdyb3VwSWQgPSByYWRpb0J1dHRvbi5ncm91cElkOyBcclxuICAgICAgICB2YXIgYnV0dG9ucyA9IHRoaXMuX2dyb3Vwc1tncm91cElkXTtcclxuICAgICAgICBpZihidXR0b25zID09IG51bGwpe1xyXG4gICAgICAgICAgICBidXR0b25zID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2dyb3Vwc1tncm91cElkXSA9IGJ1dHRvbnM7IFxyXG4gICAgICAgIH1cclxuICAgICAgICBidXR0b25zLnB1c2gocmFkaW9CdXR0b24pO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgZGVsOmZ1bmN0aW9uKHJhZGlvQnV0dG9uKXtcclxuICAgICAgICB2YXIgZ3JvdXBJZCA9IHJhZGlvQnV0dG9uLmdyb3VwSWQ7XHJcbiAgICAgICAgdmFyIGJ1dHRvbnMgPSB0aGlzLl9ncm91cHNbZ3JvdXBJZF07XHJcbiAgICAgICAgaWYoYnV0dG9ucyA9PSBudWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuOyBcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlkeCA9IGJ1dHRvbnMuaW5kZXhPZihyYWRpb0J1dHRvbik7XHJcbiAgICAgICAgaWYoaWR4ICE9IC0xKXtcclxuICAgICAgICAgICAgYnV0dG9ucy5zcGxpY2UoaWR4LDEpOyAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBpZihidXR0b25zLmxlbmd0aCA9PSAwKXtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2dyb3Vwc1tncm91cElkXSAgIFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIGNoZWNrOmZ1bmN0aW9uKHJhZGlvQnV0dG9uKXtcclxuICAgICAgICB2YXIgZ3JvdXBJZCA9IHJhZGlvQnV0dG9uLmdyb3VwSWQ7XHJcbiAgICAgICAgdmFyIGJ1dHRvbnMgPSB0aGlzLl9ncm91cHNbZ3JvdXBJZF07XHJcbiAgICAgICAgaWYoYnV0dG9ucyA9PSBudWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuOyBcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGJ1dHRvbnMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgYnRuID0gYnV0dG9uc1tpXTtcclxuICAgICAgICAgICAgaWYoYnRuID09IHJhZGlvQnV0dG9uKXtcclxuICAgICAgICAgICAgICAgIGJ0bi5jaGVjayh0cnVlKTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBidG4uY2hlY2soZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCwgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQgb25seSB3aGVuIHRoZSBjb21wb25lbnQgYXR0YWNoaW5nXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIG5vZGUgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuICAgICAgICBfcmVjb25uZWN0Om51bGwsXHJcbiAgICAgICAgX2xibFRpcDpudWxsLFxyXG4gICAgICAgIF9sYXN0UGluZzowLFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3JlY29ubmVjdCA9IGNjLmZpbmQoXCJDYW52YXMvcmVjb25uZWN0XCIpO1xyXG4gICAgICAgIHRoaXMuX2xibFRpcCA9IGNjLmZpbmQoXCJDYW52YXMvcmVjb25uZWN0L3RpcFwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpO1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICBcclxuICAgICAgICB2YXIgZm5UZXN0U2VydmVyT24gPSBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBjYy52di5uZXQudGVzdChmdW5jdGlvbihyZXQpe1xyXG4gICAgICAgICAgICAgICBpZihyZXQpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLmRpcmVjdG9yLmxvYWRTY2VuZSgnaGFsbCcpOyAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmblRlc3RTZXJ2ZXJPbiwzMDAwKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24oZGF0YSl7XHJcbiAgICAgICAgICAgIHNlbGYubm9kZS5vZmYoJ2Rpc2Nvbm5lY3QnLGZuKTtcclxuICAgICAgICAgICAgc2VsZi5fcmVjb25uZWN0LmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGZuVGVzdFNlcnZlck9uKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcImFkYXNmZGFzZGZzZGZcIik7XHJcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdkaXNjb25uZWN0Jyxmbik7XHJcbiAgICB9LFxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcbiAgICAgICAgaWYodGhpcy5fcmVjb25uZWN0LmFjdGl2ZSl7XHJcbiAgICAgICAgICAgIHZhciB0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgJSA0O1xyXG4gICAgICAgICAgICB0aGlzLl9sYmxUaXAuc3RyaW5nID0gXCLkuI7mnI3liqHlmajmlq3lvIDov57mjqXvvIzmraPlnKjlsJ3or5Xph43ov55cIjtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHQ7ICsrIGkpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGJsVGlwLnN0cmluZyArPSAnLic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG59KTtcclxuIiwiY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAvLyBmb286IHtcclxuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLFxyXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcclxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXHJcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxyXG4gICAgICAgIC8vIH0sXHJcbiAgICAgICAgLy8gLi4uXHJcbiAgICAgICAgX25leHRQbGF5VGltZToxLFxyXG4gICAgICAgIF9yZXBsYXk6bnVsbCxcclxuICAgICAgICBfaXNQbGF5aW5nOnRydWUsXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYoY2MudnYgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5fcmVwbGF5ID0gY2MuZmluZChcIkNhbnZhcy9yZXBsYXlcIik7XHJcbiAgICAgICAgdGhpcy5fcmVwbGF5LmFjdGl2ZSA9IGNjLnZ2LnJlcGxheU1nci5pc1JlcGxheSgpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25CdG5QYXVzZUNsaWNrZWQ6ZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uQnRuUGxheUNsaWNrZWQ6ZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSB0cnVlO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25CdG5CYWNrQ2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGNjLnZ2LnJlcGxheU1nci5jbGVhcigpO1xyXG4gICAgICAgIGNjLnZ2LmdhbWVOZXRNZ3IucmVzZXQoKTtcclxuICAgICAgICBjYy52di5nYW1lTmV0TWdyLnJvb21JZCA9IG51bGw7XHJcbiAgICAgICAgY2MuZGlyZWN0b3IubG9hZFNjZW5lKFwiaGFsbFwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcbiAgICAgICAgaWYoY2MudnYpe1xyXG4gICAgICAgICAgICBpZih0aGlzLl9pc1BsYXlpbmcgJiYgY2MudnYucmVwbGF5TWdyLmlzUmVwbGF5KCkgPT0gdHJ1ZSAmJiB0aGlzLl9uZXh0UGxheVRpbWUgPiAwKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuX25leHRQbGF5VGltZSAtPSBkdDtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX25leHRQbGF5VGltZSA8IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25leHRQbGF5VGltZSA9IGNjLnZ2LnJlcGxheU1nci50YWtlQWN0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG59KTtcclxuIiwidmFyIEFDVElPTl9DSFVQQUkgPSAxO1xyXG52YXIgQUNUSU9OX01PUEFJID0gMjtcclxudmFyIEFDVElPTl9QRU5HID0gMztcclxudmFyIEFDVElPTl9HQU5HID0gNDtcclxudmFyIEFDVElPTl9IVSA9IDU7XHJcblxyXG5cclxuY2MuQ2xhc3Moe1xyXG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxyXG5cclxuICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAvLyBmb286IHtcclxuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLFxyXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcclxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXHJcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxyXG4gICAgICAgIC8vIH0sXHJcbiAgICAgICAgLy8gLi4uXHJcbiAgICAgICAgX2xhc3RBY3Rpb246bnVsbCxcclxuICAgICAgICBfYWN0aW9uUmVjb3JkczpudWxsLFxyXG4gICAgICAgIF9jdXJyZW50SW5kZXg6MCxcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBjbGVhcjpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuX2xhc3RBY3Rpb24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2FjdGlvblJlY29yZHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCA9IDA7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBpbml0OmZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgIHRoaXMuX2FjdGlvblJlY29yZHMgPSBkYXRhLmFjdGlvbl9yZWNvcmRzO1xyXG4gICAgICAgIGlmKHRoaXMuX2FjdGlvblJlY29yZHMgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvblJlY29yZHMgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLl9sYXN0QWN0aW9uID0gbnVsbDtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGlzUmVwbGF5OmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvblJlY29yZHMgIT0gbnVsbDsgICAgXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBnZXROZXh0QWN0aW9uOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYodGhpcy5fY3VycmVudEluZGV4ID49IHRoaXMuX2FjdGlvblJlY29yZHMubGVuZ3RoKXtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBzaSA9IHRoaXMuX2FjdGlvblJlY29yZHNbdGhpcy5fY3VycmVudEluZGV4KytdO1xyXG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLl9hY3Rpb25SZWNvcmRzW3RoaXMuX2N1cnJlbnRJbmRleCsrXTtcclxuICAgICAgICB2YXIgcGFpID0gdGhpcy5fYWN0aW9uUmVjb3Jkc1t0aGlzLl9jdXJyZW50SW5kZXgrK107XHJcbiAgICAgICAgcmV0dXJuIHtzaTpzaSx0eXBlOmFjdGlvbixwYWk6cGFpfTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHRha2VBY3Rpb246ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgYWN0aW9uID0gdGhpcy5nZXROZXh0QWN0aW9uKCk7XHJcbiAgICAgICAgaWYodGhpcy5fbGFzdEFjdGlvbiAhPSBudWxsICYmIHRoaXMuX2xhc3RBY3Rpb24udHlwZSA9PSBBQ1RJT05fQ0hVUEFJKXtcclxuICAgICAgICAgICAgaWYoYWN0aW9uICE9IG51bGwgJiYgYWN0aW9uLnR5cGUgIT0gQUNUSU9OX1BFTkcgJiYgYWN0aW9uLnR5cGUgIT0gQUNUSU9OX0dBTkcgJiYgYWN0aW9uLnR5cGUgIT0gQUNUSU9OX0hVKXtcclxuICAgICAgICAgICAgICAgIGNjLnZ2LmdhbWVOZXRNZ3IuZG9HdW8odGhpcy5fbGFzdEFjdGlvbi5zaSx0aGlzLl9sYXN0QWN0aW9uLnBhaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbGFzdEFjdGlvbiA9IGFjdGlvbjtcclxuICAgICAgICBpZihhY3Rpb24gPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5leHRBY3Rpb25EZWxheSA9IDEuMDtcclxuICAgICAgICBpZihhY3Rpb24udHlwZSA9PSBBQ1RJT05fQ0hVUEFJKXtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImNodXBhaVwiKTtcclxuICAgICAgICAgICAgY2MudnYuZ2FtZU5ldE1nci5kb0NodXBhaShhY3Rpb24uc2ksYWN0aW9uLnBhaSk7XHJcbiAgICAgICAgICAgIHJldHVybiAxLjA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoYWN0aW9uLnR5cGUgPT0gQUNUSU9OX01PUEFJKXtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIm1vcGFpXCIpO1xyXG4gICAgICAgICAgICBjYy52di5nYW1lTmV0TWdyLmRvTW9wYWkoYWN0aW9uLnNpLGFjdGlvbi5wYWkpO1xyXG4gICAgICAgICAgICBjYy52di5nYW1lTmV0TWdyLmRvVHVybkNoYW5nZShhY3Rpb24uc2kpO1xyXG4gICAgICAgICAgICByZXR1cm4gMC41O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGFjdGlvbi50eXBlID09IEFDVElPTl9QRU5HKXtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInBlbmdcIik7XHJcbiAgICAgICAgICAgIGNjLnZ2LmdhbWVOZXRNZ3IuZG9QZW5nKGFjdGlvbi5zaSxhY3Rpb24ucGFpKTtcclxuICAgICAgICAgICAgY2MudnYuZ2FtZU5ldE1nci5kb1R1cm5DaGFuZ2UoYWN0aW9uLnNpKTtcclxuICAgICAgICAgICAgcmV0dXJuIDEuMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihhY3Rpb24udHlwZSA9PSBBQ1RJT05fR0FORyl7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJnYW5nXCIpO1xyXG4gICAgICAgICAgICBjYy52di5nYW1lTmV0TWdyLmRpc3BhdGNoRXZlbnQoJ2hhbmdhbmdfbm90aWZ5JyxhY3Rpb24uc2kpO1xyXG4gICAgICAgICAgICBjYy52di5nYW1lTmV0TWdyLmRvR2FuZyhhY3Rpb24uc2ksYWN0aW9uLnBhaSk7XHJcbiAgICAgICAgICAgIGNjLnZ2LmdhbWVOZXRNZ3IuZG9UdXJuQ2hhbmdlKGFjdGlvbi5zaSk7XHJcbiAgICAgICAgICAgIHJldHVybiAxLjA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoYWN0aW9uLnR5cGUgPT0gQUNUSU9OX0hVKXtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImh1XCIpO1xyXG4gICAgICAgICAgICBjYy52di5nYW1lTmV0TWdyLmRvSHUoe3NlYXRpbmRleDphY3Rpb24uc2ksaHVwYWk6YWN0aW9uLnBhaSxpc3ppbW86ZmFsc2V9KTtcclxuICAgICAgICAgICAgcmV0dXJuIDEuNTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxufSk7XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgX3Nwckljb246bnVsbCxcclxuICAgICAgICBfemh1YW5nOm51bGwsXHJcbiAgICAgICAgX3JlYWR5Om51bGwsXHJcbiAgICAgICAgX29mZmxpbmU6bnVsbCxcclxuICAgICAgICBfbGJsTmFtZTpudWxsLFxyXG4gICAgICAgIF9sYmxTY29yZTpudWxsLFxyXG4gICAgICAgIF9zY29yZUJnOm51bGwsXHJcbiAgICAgICAgX25kZGF5aW5namlhOm51bGwsXHJcbiAgICAgICAgX3ZvaWNlbXNnOm51bGwsXHJcbiAgICAgICAgXHJcbiAgICAgICAgX2NoYXRCdWJibGU6bnVsbCxcclxuICAgICAgICBfZW1vamk6bnVsbCxcclxuICAgICAgICBfbGFzdENoYXRUaW1lOi0xLFxyXG4gICAgICAgIFxyXG4gICAgICAgIF91c2VyTmFtZTpcIlwiLFxyXG4gICAgICAgIF9zY29yZTowLFxyXG4gICAgICAgIF9kYXlpbmdqaWE6ZmFsc2UsXHJcbiAgICAgICAgX2lzT2ZmbGluZTpmYWxzZSxcclxuICAgICAgICBfaXNSZWFkeTpmYWxzZSxcclxuICAgICAgICBfaXNaaHVhbmc6ZmFsc2UsXHJcbiAgICAgICAgX3VzZXJJZDpudWxsLFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmKGNjLnZ2ID09IG51bGwpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX3Nwckljb24gPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJpY29uXCIpLmdldENvbXBvbmVudChcIkltYWdlTG9hZGVyXCIpO1xyXG4gICAgICAgIHRoaXMuX2xibE5hbWUgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJuYW1lXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCk7XHJcbiAgICAgICAgdGhpcy5fbGJsU2NvcmUgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJzY29yZVwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpO1xyXG4gICAgICAgIHRoaXMuX3ZvaWNlbXNnID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwidm9pY2Vtc2dcIik7XHJcbiAgICAgICAgdGhpcy5feHVhbnBhaSA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcInh1YW5wYWlcIik7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoWHVhblBhaVN0YXRlKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodGhpcy5fdm9pY2Vtc2cpe1xyXG4gICAgICAgICAgICB0aGlzLl92b2ljZW1zZy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodGhpcy5fc3BySWNvbiAmJiB0aGlzLl9zcHJJY29uLmdldENvbXBvbmVudChjYy5CdXR0b24pKXtcclxuICAgICAgICAgICAgY2MudnYudXRpbHMuYWRkQ2xpY2tFdmVudCh0aGlzLl9zcHJJY29uLHRoaXMubm9kZSxcIlNlYXRcIixcIm9uSWNvbkNsaWNrZWRcIik7ICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9vZmZsaW5lID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwib2ZmbGluZVwiKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9yZWFkeSA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcInJlYWR5XCIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX3podWFuZyA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcInpodWFuZ1wiKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9zY29yZUJnID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiWl9tb25leV9mcmFtZVwiKTtcclxuICAgICAgICB0aGlzLl9uZGRheWluZ2ppYSA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImRheWluZ2ppYVwiKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9jaGF0QnViYmxlID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiQ2hhdEJ1YmJsZVwiKTtcclxuICAgICAgICBpZih0aGlzLl9jaGF0QnViYmxlICE9IG51bGwpe1xyXG4gICAgICAgICAgICB0aGlzLl9jaGF0QnViYmxlLmFjdGl2ZSA9IGZhbHNlOyAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9lbW9qaSA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImVtb2ppXCIpO1xyXG4gICAgICAgIGlmKHRoaXMuX2Vtb2ppICE9IG51bGwpe1xyXG4gICAgICAgICAgICB0aGlzLl9lbW9qaS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodGhpcy5fc3BySWNvbiAmJiB0aGlzLl91c2VySWQpe1xyXG4gICAgICAgICAgICB0aGlzLl9zcHJJY29uLnNldFVzZXJJRCh0aGlzLl91c2VySWQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uSWNvbkNsaWNrZWQ6ZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgaWNvblNwcml0ZSA9IHRoaXMuX3Nwckljb24ubm9kZS5nZXRDb21wb25lbnQoY2MuU3ByaXRlKTtcclxuICAgICAgICBpZih0aGlzLl91c2VySWQgIT0gbnVsbCAmJiB0aGlzLl91c2VySWQgPiAwKXtcclxuICAgICAgICAgICB2YXIgc2VhdCA9IGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0U2VhdEJ5SUQodGhpcy5fdXNlcklkKTtcclxuICAgICAgICAgICAgdmFyIHNleCA9IDA7XHJcbiAgICAgICAgICAgIGlmKGNjLnZ2LmJhc2VJbmZvTWFwKXtcclxuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gY2MudnYuYmFzZUluZm9NYXBbdGhpcy5fdXNlcklkXTtcclxuICAgICAgICAgICAgICAgIGlmKGluZm8pe1xyXG4gICAgICAgICAgICAgICAgICAgIHNleCA9IGluZm8uc2V4O1xyXG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYy52di51c2VyaW5mb1Nob3cuc2hvdyhzZWF0Lm5hbWUsc2VhdC51c2VyaWQsaWNvblNwcml0ZSxzZXgsc2VhdC5pcCk7ICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgcmVmcmVzaDpmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmKHRoaXMuX2xibE5hbWUgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHRoaXMuX2xibE5hbWUuc3RyaW5nID0gdGhpcy5fdXNlck5hbWU7ICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZih0aGlzLl9sYmxTY29yZSAhPSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5fbGJsU2NvcmUuc3RyaW5nID0gdGhpcy5fc2NvcmU7ICAgICAgICAgICAgXHJcbiAgICAgICAgfSAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodGhpcy5fbmRkYXlpbmdqaWEgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHRoaXMuX25kZGF5aW5namlhLmFjdGl2ZSA9IHRoaXMuX2RheWluZ2ppYSA9PSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZih0aGlzLl9vZmZsaW5lKXtcclxuICAgICAgICAgICAgdGhpcy5fb2ZmbGluZS5hY3RpdmUgPSB0aGlzLl9pc09mZmxpbmUgJiYgdGhpcy5fdXNlck5hbWUgIT0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodGhpcy5fcmVhZHkpe1xyXG4gICAgICAgICAgICB0aGlzLl9yZWFkeS5hY3RpdmUgPSB0aGlzLl9pc1JlYWR5ICYmIChjYy52di5nYW1lTmV0TWdyLm51bU9mR2FtZXMgPiAwKTsgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHRoaXMuX3podWFuZyl7XHJcbiAgICAgICAgICAgIHRoaXMuX3podWFuZy5hY3RpdmUgPSB0aGlzLl9pc1podWFuZzsgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSB0aGlzLl91c2VyTmFtZSAhPSBudWxsICYmIHRoaXMuX3VzZXJOYW1lICE9IFwiXCI7IFxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc2V0SW5mbyhuYW1lLHNjb3JlLGRheWluZ2ppYSl7XHJcbiAgICAgICAgdGhpcy5fdXNlck5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuX3Njb3JlID0gc2NvcmU7XHJcbiAgICAgICAgaWYodGhpcy5fc2NvcmUgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHRoaXMuX3Njb3JlID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZGF5aW5namlhID0gZGF5aW5namlhO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHRoaXMuX3Njb3JlQmcgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHRoaXMuX3Njb3JlQmcuYWN0aXZlID0gdGhpcy5fc2NvcmUgIT0gbnVsbDsgICAgICAgICAgICBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMuX2xibFNjb3JlICE9IG51bGwpe1xyXG4gICAgICAgICAgICB0aGlzLl9sYmxTY29yZS5ub2RlLmFjdGl2ZSA9IHRoaXMuX3Njb3JlICE9IG51bGw7ICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnJlZnJlc2goKTsgICAgXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzZXRaaHVhbmc6ZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgICAgIGlmKHRoaXMuX3podWFuZyl7XHJcbiAgICAgICAgICAgIHRoaXMuX3podWFuZy5hY3RpdmUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzZXRSZWFkeTpmdW5jdGlvbihpc1JlYWR5KXtcclxuICAgICAgICB0aGlzLl9pc1JlYWR5ID0gaXNSZWFkeTtcclxuICAgICAgICBpZih0aGlzLl9yZWFkeSl7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5LmFjdGl2ZSA9IHRoaXMuX2lzUmVhZHkgJiYgKGNjLnZ2LmdhbWVOZXRNZ3IubnVtT2ZHYW1lcyA+IDApOyBcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzZXRJRDpmdW5jdGlvbihpZCl7XHJcbiAgICAgICAgdmFyIGlkTm9kZSA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImlkXCIpO1xyXG4gICAgICAgIGlmKGlkTm9kZSl7XHJcbiAgICAgICAgICAgIHZhciBsYmwgPSBpZE5vZGUuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKTtcclxuICAgICAgICAgICAgbGJsLnN0cmluZyA9IFwiSUQ6XCIgKyBpZDsgICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5fdXNlcklkID0gaWQ7XHJcbiAgICAgICAgaWYodGhpcy5fc3BySWNvbil7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwckljb24uc2V0VXNlcklEKGlkKTsgXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc2V0T2ZmbGluZTpmdW5jdGlvbihpc09mZmxpbmUpe1xyXG4gICAgICAgIHRoaXMuX2lzT2ZmbGluZSA9IGlzT2ZmbGluZTtcclxuICAgICAgICBpZih0aGlzLl9vZmZsaW5lKXtcclxuICAgICAgICAgICAgdGhpcy5fb2ZmbGluZS5hY3RpdmUgPSB0aGlzLl9pc09mZmxpbmUgJiYgdGhpcy5fdXNlck5hbWUgIT0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBjaGF0OmZ1bmN0aW9uKGNvbnRlbnQpe1xyXG4gICAgICAgIGlmKHRoaXMuX2NoYXRCdWJibGUgPT0gbnVsbCB8fCB0aGlzLl9lbW9qaSA9PSBudWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9lbW9qaS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9jaGF0QnViYmxlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fY2hhdEJ1YmJsZS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IGNvbnRlbnQ7XHJcbiAgICAgICAgdGhpcy5fY2hhdEJ1YmJsZS5nZXRDaGlsZEJ5TmFtZShcIk5ldyBMYWJlbFwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IGNvbnRlbnQ7XHJcbiAgICAgICAgdGhpcy5fbGFzdENoYXRUaW1lID0gMztcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGVtb2ppOmZ1bmN0aW9uKGVtb2ppKXtcclxuICAgICAgICAvL2Vtb2ppID0gSlNPTi5wYXJzZShlbW9qaSk7XHJcbiAgICAgICAgaWYodGhpcy5fZW1vamkgPT0gbnVsbCB8fCB0aGlzLl9lbW9qaSA9PSBudWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmxvZyhlbW9qaSk7XHJcbiAgICAgICAgdGhpcy5fY2hhdEJ1YmJsZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9lbW9qaS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2Vtb2ppLmdldENvbXBvbmVudChjYy5BbmltYXRpb24pLnBsYXkoZW1vamkpO1xyXG4gICAgICAgIHRoaXMuX2xhc3RDaGF0VGltZSA9IDM7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICB2b2ljZU1zZzpmdW5jdGlvbihzaG93KXtcclxuICAgICAgICBpZih0aGlzLl92b2ljZW1zZyl7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZvaWNlbXNnLmFjdGl2ZSA9IHNob3c7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgcmVmcmVzaFh1YW5QYWlTdGF0ZTpmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmKHRoaXMuX3h1YW5wYWkgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5feHVhbnBhaS5hY3RpdmUgPSBjYy52di5nYW1lTmV0TWdyLmlzSHVhblNhblpoYW5nO1xyXG4gICAgICAgIGlmKGNjLnZ2LmdhbWVOZXRNZ3IuaXNIdWFuU2FuWmhhbmcgPT0gZmFsc2UpeyBcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgIFxyXG4gICAgICAgIHRoaXMuX3h1YW5wYWkuZ2V0Q2hpbGRCeU5hbWUoXCJ4elwiKS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl94dWFucGFpLmdldENoaWxkQnlOYW1lKFwieGRcIikuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNlYXQgPSBjYy52di5nYW1lTmV0TWdyLmdldFNlYXRCeUlEKHRoaXMuX3VzZXJJZCk7XHJcbiAgICAgICAgaWYoc2VhdCl7XHJcbiAgICAgICAgICAgIGlmKHNlYXQuaHVhbnBhaXMgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl94dWFucGFpLmdldENoaWxkQnlOYW1lKFwieHpcIikuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgdGhpcy5feHVhbnBhaS5nZXRDaGlsZEJ5TmFtZShcInhkXCIpLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICBcclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG4gICAgICAgIGlmKHRoaXMuX2xhc3RDaGF0VGltZSA+IDApe1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0Q2hhdFRpbWUgLT0gZHQ7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuX2xhc3RDaGF0VGltZSA8IDApe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhdEJ1YmJsZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Vtb2ppLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW1vamkuZ2V0Q29tcG9uZW50KGNjLkFuaW1hdGlvbikuc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxufSk7XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCwgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQgb25seSB3aGVuIHRoZSBjb21wb25lbnQgYXR0YWNoaW5nXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIG5vZGUgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuICAgICAgICBfYnRuWVhPcGVuOm51bGwsXHJcbiAgICAgICAgX2J0bllYQ2xvc2U6bnVsbCxcclxuICAgICAgICBfYnRuWVlPcGVuOm51bGwsXHJcbiAgICAgICAgX2J0bllZQ2xvc2U6bnVsbCxcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZihjYy52diA9PSBudWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgIHRoaXMuX2J0bllYT3BlbiA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcInlpbnhpYW9cIikuZ2V0Q2hpbGRCeU5hbWUoXCJidG5feXhfb3BlblwiKTtcclxuICAgICAgICB0aGlzLl9idG5ZWENsb3NlID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwieWlueGlhb1wiKS5nZXRDaGlsZEJ5TmFtZShcImJ0bl95eF9jbG9zZVwiKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9idG5ZWU9wZW4gPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJ5aW55dWVcIikuZ2V0Q2hpbGRCeU5hbWUoXCJidG5feXlfb3BlblwiKTtcclxuICAgICAgICB0aGlzLl9idG5ZWUNsb3NlID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwieWlueXVlXCIpLmdldENoaWxkQnlOYW1lKFwiYnRuX3l5X2Nsb3NlXCIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuaW5pdEJ1dHRvbkhhbmRsZXIodGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiYnRuX2Nsb3NlXCIpKTtcclxuICAgICAgICB0aGlzLmluaXRCdXR0b25IYW5kbGVyKHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImJ0bl9leGl0XCIpKTtcclxuICAgICAgICBcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmluaXRCdXR0b25IYW5kbGVyKHRoaXMuX2J0bllYT3Blbik7XHJcbiAgICAgICAgdGhpcy5pbml0QnV0dG9uSGFuZGxlcih0aGlzLl9idG5ZWENsb3NlKTtcclxuICAgICAgICB0aGlzLmluaXRCdXR0b25IYW5kbGVyKHRoaXMuX2J0bllZT3Blbik7XHJcbiAgICAgICAgdGhpcy5pbml0QnV0dG9uSGFuZGxlcih0aGlzLl9idG5ZWUNsb3NlKTtcclxuICAgICAgICBcclxuXHJcbiAgICAgICAgdmFyIHNsaWRlciA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcInlpbnhpYW9cIikuZ2V0Q2hpbGRCeU5hbWUoXCJwcm9ncmVzc1wiKTtcclxuICAgICAgICBjYy52di51dGlscy5hZGRTbGlkZUV2ZW50KHNsaWRlcix0aGlzLm5vZGUsXCJTZXR0aW5nc1wiLFwib25TbGlkZWRcIik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNsaWRlciA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcInlpbnl1ZVwiKS5nZXRDaGlsZEJ5TmFtZShcInByb2dyZXNzXCIpO1xyXG4gICAgICAgIGNjLnZ2LnV0aWxzLmFkZFNsaWRlRXZlbnQoc2xpZGVyLHRoaXMubm9kZSxcIlNldHRpbmdzXCIsXCJvblNsaWRlZFwiKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnJlZnJlc2hWb2x1bWUoKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uU2xpZGVkOmZ1bmN0aW9uKHNsaWRlcil7XHJcbiAgICAgICAgaWYoc2xpZGVyLm5vZGUucGFyZW50Lm5hbWUgPT0gXCJ5aW54aWFvXCIpe1xyXG4gICAgICAgICAgICBjYy52di5hdWRpb01nci5zZXRTRlhWb2x1bWUoc2xpZGVyLnByb2dyZXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihzbGlkZXIubm9kZS5wYXJlbnQubmFtZSA9PSBcInlpbnl1ZVwiKXtcclxuICAgICAgICAgICAgY2MudnYuYXVkaW9NZ3Iuc2V0QkdNVm9sdW1lKHNsaWRlci5wcm9ncmVzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVmcmVzaFZvbHVtZSgpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgaW5pdEJ1dHRvbkhhbmRsZXI6ZnVuY3Rpb24oYnRuKXtcclxuICAgICAgICBjYy52di51dGlscy5hZGRDbGlja0V2ZW50KGJ0bix0aGlzLm5vZGUsXCJTZXR0aW5nc1wiLFwib25CdG5DbGlja2VkXCIpOyAgICBcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHJlZnJlc2hWb2x1bWU6ZnVuY3Rpb24oKXtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9idG5ZWENsb3NlLmFjdGl2ZSA9IGNjLnZ2LmF1ZGlvTWdyLnNmeFZvbHVtZSA+IDA7XHJcbiAgICAgICAgdGhpcy5fYnRuWVhPcGVuLmFjdGl2ZSA9ICF0aGlzLl9idG5ZWENsb3NlLmFjdGl2ZTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgeXggPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJ5aW54aWFvXCIpO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IDQzMCAqIGNjLnZ2LmF1ZGlvTWdyLnNmeFZvbHVtZTtcclxuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB5eC5nZXRDaGlsZEJ5TmFtZShcInByb2dyZXNzXCIpXHJcbiAgICAgICAgcHJvZ3Jlc3MuZ2V0Q29tcG9uZW50KGNjLlNsaWRlcikucHJvZ3Jlc3MgPSBjYy52di5hdWRpb01nci5zZnhWb2x1bWU7XHJcbiAgICAgICAgcHJvZ3Jlc3MuZ2V0Q2hpbGRCeU5hbWUoXCJwcm9ncmVzc1wiKS53aWR0aCA9IHdpZHRoOyAgXHJcbiAgICAgICAgLy95eC5nZXRDaGlsZEJ5TmFtZShcImJ0bl9wcm9ncmVzc1wiKS54ID0gcHJvZ3Jlc3MueCArIHdpZHRoO1xyXG4gICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX2J0bllZQ2xvc2UuYWN0aXZlID0gY2MudnYuYXVkaW9NZ3IuYmdtVm9sdW1lID4gMDtcclxuICAgICAgICB0aGlzLl9idG5ZWU9wZW4uYWN0aXZlID0gIXRoaXMuX2J0bllZQ2xvc2UuYWN0aXZlO1xyXG4gICAgICAgIHZhciB5eSA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcInlpbnl1ZVwiKTtcclxuICAgICAgICB2YXIgd2lkdGggPSA0MzAgKiBjYy52di5hdWRpb01nci5iZ21Wb2x1bWU7XHJcbiAgICAgICAgdmFyIHByb2dyZXNzID0geXkuZ2V0Q2hpbGRCeU5hbWUoXCJwcm9ncmVzc1wiKTtcclxuICAgICAgICBwcm9ncmVzcy5nZXRDb21wb25lbnQoY2MuU2xpZGVyKS5wcm9ncmVzcyA9IGNjLnZ2LmF1ZGlvTWdyLmJnbVZvbHVtZTsgXHJcbiAgICAgICAgXHJcbiAgICAgICAgcHJvZ3Jlc3MuZ2V0Q2hpbGRCeU5hbWUoXCJwcm9ncmVzc1wiKS53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIC8veXkuZ2V0Q2hpbGRCeU5hbWUoXCJidG5fcHJvZ3Jlc3NcIikueCA9IHByb2dyZXNzLnggKyB3aWR0aDtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uQnRuQ2xpY2tlZDpmdW5jdGlvbihldmVudCl7XHJcbiAgICAgICAgaWYoZXZlbnQudGFyZ2V0Lm5hbWUgPT0gXCJidG5fY2xvc2VcIil7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihldmVudC50YXJnZXQubmFtZSA9PSBcImJ0bl9leGl0XCIpe1xyXG4gICAgICAgICAgICBjYy5zeXMubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJ3eF9hY2NvdW50XCIpO1xyXG4gICAgICAgICAgICBjYy5zeXMubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJ3eF9zaWduXCIpO1xyXG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5sb2FkU2NlbmUoXCJsb2dpblwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihldmVudC50YXJnZXQubmFtZSA9PSBcImJ0bl95eF9vcGVuXCIpe1xyXG4gICAgICAgICAgICBjYy52di5hdWRpb01nci5zZXRTRlhWb2x1bWUoMS4wKTtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVm9sdW1lKCk7IFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldC5uYW1lID09IFwiYnRuX3l4X2Nsb3NlXCIpe1xyXG4gICAgICAgICAgICBjYy52di5hdWRpb01nci5zZXRTRlhWb2x1bWUoMCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFZvbHVtZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldC5uYW1lID09IFwiYnRuX3l5X29wZW5cIil7XHJcbiAgICAgICAgICAgIGNjLnZ2LmF1ZGlvTWdyLnNldEJHTVZvbHVtZSgxKTtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVm9sdW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZXZlbnQudGFyZ2V0Lm5hbWUgPT0gXCJidG5feXlfY2xvc2VcIil7XHJcbiAgICAgICAgICAgIGNjLnZ2LmF1ZGlvTWdyLnNldEJHTVZvbHVtZSgwKTtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVm9sdW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG5cclxuICAgIC8vIH0sXHJcbn0pO1xyXG4iLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIF9hcnJvdzpudWxsLFxyXG4gICAgICAgIF9wb2ludGVyOm51bGwsXHJcbiAgICAgICAgX3RpbWVMYWJlbDpudWxsLFxyXG4gICAgICAgIF90aW1lOi0xLFxyXG4gICAgICAgIF9hbGVydFRpbWU6LTEsXHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCxcclxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XHJcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxyXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcclxuICAgICAgICAvLyB9LFxyXG4gICAgICAgIC8vIC4uLlxyXG4gICAgfSxcclxuXHJcbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cclxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBnYW1lQ2hpbGQgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJnYW1lXCIpO1xyXG4gICAgICAgIHRoaXMuX2Fycm93ID0gZ2FtZUNoaWxkLmdldENoaWxkQnlOYW1lKFwiYXJyb3dcIik7XHJcbiAgICAgICAgdGhpcy5fcG9pbnRlciA9IHRoaXMuX2Fycm93LmdldENoaWxkQnlOYW1lKFwicG9pbnRlclwiKTtcclxuICAgICAgICB0aGlzLmluaXRQb2ludGVyKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5fdGltZUxhYmVsID0gdGhpcy5fYXJyb3cuZ2V0Q2hpbGRCeU5hbWUoXCJsYmxUaW1lXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCk7XHJcbiAgICAgICAgdGhpcy5fdGltZUxhYmVsLnN0cmluZyA9IFwiMDBcIjtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW1lX2JlZ2luJyxmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgc2VsZi5pbml0UG9pbnRlcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubm9kZS5vbignZ2FtZV9jaHVwYWknLGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgICAgICAgICBzZWxmLmluaXRQb2ludGVyKCk7XHJcbiAgICAgICAgICAgIHNlbGYuX3RpbWUgPSAxMDtcclxuICAgICAgICAgICAgc2VsZi5fYWxlcnRUaW1lID0gMztcclxuICAgICAgICB9KTtcclxuICAgIH0sIFxyXG4gICAgXHJcbiAgICBpbml0UG9pbnRlcjpmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmKGNjLnZ2ID09IG51bGwpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2Fycm93LmFjdGl2ZSA9IGNjLnZ2LmdhbWVOZXRNZ3IuZ2FtZXN0YXRlID09IFwicGxheWluZ1wiO1xyXG4gICAgICAgIGlmKCF0aGlzLl9hcnJvdy5hY3RpdmUpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0dXJuID0gY2MudnYuZ2FtZU5ldE1nci50dXJuO1xyXG4gICAgICAgIHZhciBsb2NhbEluZGV4ID0gY2MudnYuZ2FtZU5ldE1nci5nZXRMb2NhbEluZGV4KHR1cm4pO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9wb2ludGVyLmNoaWxkcmVuLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdGhpcy5fcG9pbnRlci5jaGlsZHJlbltpXS5hY3RpdmUgPSBpID09IGxvY2FsSW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcbiAgICAgICAgaWYodGhpcy5fdGltZSA+IDApe1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lIC09IGR0O1xyXG4gICAgICAgICAgICBpZih0aGlzLl9hbGVydFRpbWUgPiAwICYmIHRoaXMuX3RpbWUgPCB0aGlzLl9hbGVydFRpbWUpe1xyXG4gICAgICAgICAgICAgICAgY2MudnYuYXVkaW9NZ3IucGxheVNGWChcInRpbWV1cF9hbGFybS5tcDNcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGVydFRpbWUgPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcHJlID0gXCJcIjtcclxuICAgICAgICAgICAgaWYodGhpcy5fdGltZSA8IDApe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciB0ID0gTWF0aC5jZWlsKHRoaXMuX3RpbWUpO1xyXG4gICAgICAgICAgICBpZih0IDwgMTApe1xyXG4gICAgICAgICAgICAgICAgcHJlID0gXCIwXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdGltZUxhYmVsLnN0cmluZyA9IHByZSArIHQ7IFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbn0pO1xyXG4iLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIC8vIGZvbzoge1xyXG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgY29tcG9uZW50IGF0dGFjaGluZ1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYSBub2RlIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcclxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXHJcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxyXG4gICAgICAgIC8vIH0sXHJcbiAgICAgICAgLy8gLi4uXHJcbiAgICAgICAgX3VzZXJpbmZvOm51bGwsXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxyXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYoY2MudnYgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5fdXNlcmluZm8gPSBjYy5maW5kKFwiQ2FudmFzL3VzZXJpbmZvXCIpO1xyXG4gICAgICAgIHRoaXMuX3VzZXJpbmZvLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIGNjLnZ2LnV0aWxzLmFkZENsaWNrRXZlbnQodGhpcy5fdXNlcmluZm8sdGhpcy5ub2RlLFwiVXNlckluZm9TaG93XCIsXCJvbkNsaWNrZWRcIik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2MudnYudXNlcmluZm9TaG93ID0gdGhpcztcclxuICAgIH0sXHJcbiAgICBcclxuICAgIHNob3c6ZnVuY3Rpb24obmFtZSx1c2VySWQsaWNvblNwcml0ZSxzZXgsaXApe1xyXG4gICAgICAgIGlmKHVzZXJJZCAhPSBudWxsICYmIHVzZXJJZCA+IDApe1xyXG4gICAgICAgICAgICB0aGlzLl91c2VyaW5mby5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl91c2VyaW5mby5nZXRDaGlsZEJ5TmFtZShcImljb25cIikuZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSkuc3ByaXRlRnJhbWUgPSBpY29uU3ByaXRlLnNwcml0ZUZyYW1lO1xyXG4gICAgICAgICAgICB0aGlzLl91c2VyaW5mby5nZXRDaGlsZEJ5TmFtZShcIm5hbWVcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBuYW1lO1xyXG4gICAgICAgICAgICB0aGlzLl91c2VyaW5mby5nZXRDaGlsZEJ5TmFtZShcImlwXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gXCJJUDogXCIgKyBpcC5yZXBsYWNlKFwiOjpmZmZmOlwiLFwiXCIpO1xyXG4gICAgICAgICAgICB0aGlzLl91c2VyaW5mby5nZXRDaGlsZEJ5TmFtZShcImlkXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gXCJJRDogXCIgKyB1c2VySWQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgc2V4X2ZlbWFsZSA9IHRoaXMuX3VzZXJpbmZvLmdldENoaWxkQnlOYW1lKFwic2V4X2ZlbWFsZVwiKTtcclxuICAgICAgICAgICAgc2V4X2ZlbWFsZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBzZXhfbWFsZSA9IHRoaXMuX3VzZXJpbmZvLmdldENoaWxkQnlOYW1lKFwic2V4X21hbGVcIik7XHJcbiAgICAgICAgICAgIHNleF9tYWxlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYoc2V4ID09IDEpe1xyXG4gICAgICAgICAgICAgICAgc2V4X21hbGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSAgIFxyXG4gICAgICAgICAgICBlbHNlIGlmKHNleCA9PSAyKXtcclxuICAgICAgICAgICAgICAgIHNleF9mZW1hbGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIG9uQ2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuX3VzZXJpbmZvLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xyXG5cclxuICAgIC8vIH0sXHJcbn0pO1xyXG4iLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgYWNjb3VudDpudWxsLFxyXG5cdCAgICB1c2VySWQ6bnVsbCxcclxuXHRcdHVzZXJOYW1lOm51bGwsXHJcblx0XHRsdjowLFxyXG5cdFx0ZXhwOjAsXHJcblx0XHRjb2luczowLFxyXG5cdFx0Z2VtczowLFxyXG5cdFx0c2lnbjowLFxyXG4gICAgICAgIGlwOlwiXCIsXHJcbiAgICAgICAgc2V4OjAsXHJcbiAgICAgICAgcm9vbURhdGE6bnVsbCxcclxuICAgICAgICBcclxuICAgICAgICBvbGRSb29tSWQ6bnVsbCxcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGd1ZXN0QXV0aDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBhY2NvdW50ID0gY2MuYXJnc1tcImFjY291bnRcIl07XHJcbiAgICAgICAgaWYoYWNjb3VudCA9PSBudWxsKXtcclxuICAgICAgICAgICAgYWNjb3VudCA9IGNjLnN5cy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImFjY291bnRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKGFjY291bnQgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIGFjY291bnQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBjYy5zeXMubG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJhY2NvdW50XCIsYWNjb3VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGNjLnZ2Lmh0dHAuc2VuZFJlcXVlc3QoXCIvZ3Vlc3RcIix7YWNjb3VudDphY2NvdW50fSx0aGlzLm9uQXV0aCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbkF1dGg6ZnVuY3Rpb24ocmV0KXtcclxuICAgICAgICB2YXIgc2VsZiA9IGNjLnZ2LnVzZXJNZ3I7XHJcbiAgICAgICAgaWYocmV0LmVycmNvZGUgIT09IDApe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXQuZXJybXNnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgc2VsZi5hY2NvdW50ID0gcmV0LmFjY291bnQ7XHJcbiAgICAgICAgICAgIHNlbGYuc2lnbiA9IHJldC5zaWduO1xyXG4gICAgICAgICAgICBjYy52di5odHRwLnVybCA9IFwiaHR0cDovL1wiICsgY2MudnYuU0kuaGFsbDtcclxuICAgICAgICAgICAgc2VsZi5sb2dpbigpO1xyXG4gICAgICAgIH0gICBcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGxvZ2luOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBvbkxvZ2luID0gZnVuY3Rpb24ocmV0KXtcclxuICAgICAgICAgICAgaWYocmV0LmVycmNvZGUgIT09IDApe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmV0LmVycm1zZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGlmKCFyZXQudXNlcmlkKXtcclxuICAgICAgICAgICAgICAgICAgICAvL2p1bXAgdG8gcmVnaXN0ZXIgdXNlciBpbmZvLlxyXG4gICAgICAgICAgICAgICAgICAgIGNjLmRpcmVjdG9yLmxvYWRTY2VuZShcImNyZWF0ZXJvbGVcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hY2NvdW50ID0gcmV0LmFjY291bnQ7XHJcbiAgICAgICAgXHRcdFx0c2VsZi51c2VySWQgPSByZXQudXNlcmlkO1xyXG4gICAgICAgIFx0XHRcdHNlbGYudXNlck5hbWUgPSByZXQubmFtZTtcclxuICAgICAgICBcdFx0XHRzZWxmLmx2ID0gcmV0Lmx2O1xyXG4gICAgICAgIFx0XHRcdHNlbGYuZXhwID0gcmV0LmV4cDtcclxuICAgICAgICBcdFx0XHRzZWxmLmNvaW5zID0gcmV0LmNvaW5zO1xyXG4gICAgICAgIFx0XHRcdHNlbGYuZ2VtcyA9IHJldC5nZW1zO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucm9vbURhdGEgPSByZXQucm9vbWlkO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V4ID0gcmV0LnNleDtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmlwID0gcmV0LmlwO1xyXG4gICAgICAgIFx0XHRcdGNjLmRpcmVjdG9yLmxvYWRTY2VuZShcImhhbGxcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGNjLnZ2LndjLnNob3coXCLmraPlnKjnmbvlvZXmuLjmiI9cIik7XHJcbiAgICAgICAgY2MudnYuaHR0cC5zZW5kUmVxdWVzdChcIi9sb2dpblwiLHthY2NvdW50OnRoaXMuYWNjb3VudCxzaWduOnRoaXMuc2lnbn0sb25Mb2dpbik7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBjcmVhdGU6ZnVuY3Rpb24obmFtZSl7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBvbkNyZWF0ZSA9IGZ1bmN0aW9uKHJldCl7XHJcbiAgICAgICAgICAgIGlmKHJldC5lcnJjb2RlICE9PSAwKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJldC5lcnJtc2cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmxvZ2luKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBkYXRhID0ge1xyXG4gICAgICAgICAgICBhY2NvdW50OnRoaXMuYWNjb3VudCxcclxuICAgICAgICAgICAgc2lnbjp0aGlzLnNpZ24sXHJcbiAgICAgICAgICAgIG5hbWU6bmFtZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY2MudnYuaHR0cC5zZW5kUmVxdWVzdChcIi9jcmVhdGVfdXNlclwiLGRhdGEsb25DcmVhdGUpOyAgICBcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGVudGVyUm9vbTpmdW5jdGlvbihyb29tSWQsY2FsbGJhY2spe1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgb25FbnRlciA9IGZ1bmN0aW9uKHJldCl7XHJcbiAgICAgICAgICAgIGlmKHJldC5lcnJjb2RlICE9PSAwKXtcclxuICAgICAgICAgICAgICAgIGlmKHJldC5lcnJjb2RlID09IC0xKXtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZW50ZXJSb29tKHJvb21JZCxjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSw1MDAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MudnYud2MuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrICE9IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgaWYoY2FsbGJhY2sgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmV0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNjLnZ2LmdhbWVOZXRNZ3IuY29ubmVjdEdhbWVTZXJ2ZXIocmV0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgICAgICAgIGFjY291bnQ6Y2MudnYudXNlck1nci5hY2NvdW50LFxyXG4gICAgICAgICAgICBzaWduOmNjLnZ2LnVzZXJNZ3Iuc2lnbixcclxuICAgICAgICAgICAgcm9vbWlkOnJvb21JZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY2MudnYud2Muc2hvdyhcIuato+WcqOi/m+WFpeaIv+mXtCBcIiArIHJvb21JZCk7XHJcbiAgICAgICAgY2MudnYuaHR0cC5zZW5kUmVxdWVzdChcIi9lbnRlcl9wcml2YXRlX3Jvb21cIixkYXRhLG9uRW50ZXIpO1xyXG4gICAgfSxcclxuICAgIGdldEhpc3RvcnlMaXN0OmZ1bmN0aW9uKGNhbGxiYWNrKXtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG9uR2V0ID0gZnVuY3Rpb24ocmV0KXtcclxuICAgICAgICAgICAgaWYocmV0LmVycmNvZGUgIT09IDApe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmV0LmVycm1zZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJldC5oaXN0b3J5KTtcclxuICAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrICE9IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJldC5oaXN0b3J5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgICAgICAgIGFjY291bnQ6Y2MudnYudXNlck1nci5hY2NvdW50LFxyXG4gICAgICAgICAgICBzaWduOmNjLnZ2LnVzZXJNZ3Iuc2lnbixcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNjLnZ2Lmh0dHAuc2VuZFJlcXVlc3QoXCIvZ2V0X2hpc3RvcnlfbGlzdFwiLGRhdGEsb25HZXQpO1xyXG4gICAgfSxcclxuICAgIGdldEdhbWVzT2ZSb29tOmZ1bmN0aW9uKHV1aWQsY2FsbGJhY2spe1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgb25HZXQgPSBmdW5jdGlvbihyZXQpe1xyXG4gICAgICAgICAgICBpZihyZXQuZXJyY29kZSAhPT0gMCl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXQuZXJybXNnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmV0LmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmV0LmRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgZGF0YSA9IHtcclxuICAgICAgICAgICAgYWNjb3VudDpjYy52di51c2VyTWdyLmFjY291bnQsXHJcbiAgICAgICAgICAgIHNpZ246Y2MudnYudXNlck1nci5zaWduLFxyXG4gICAgICAgICAgICB1dWlkOnV1aWQsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjYy52di5odHRwLnNlbmRSZXF1ZXN0KFwiL2dldF9nYW1lc19vZl9yb29tXCIsZGF0YSxvbkdldCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBnZXREZXRhaWxPZkdhbWU6ZnVuY3Rpb24odXVpZCxpbmRleCxjYWxsYmFjayl7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBvbkdldCA9IGZ1bmN0aW9uKHJldCl7XHJcbiAgICAgICAgICAgIGlmKHJldC5lcnJjb2RlICE9PSAwKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJldC5lcnJtc2cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXQuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXQuZGF0YSk7XHJcbiAgICAgICAgICAgIH0gICAgICAgXHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgZGF0YSA9IHtcclxuICAgICAgICAgICAgYWNjb3VudDpjYy52di51c2VyTWdyLmFjY291bnQsXHJcbiAgICAgICAgICAgIHNpZ246Y2MudnYudXNlck1nci5zaWduLFxyXG4gICAgICAgICAgICB1dWlkOnV1aWQsXHJcbiAgICAgICAgICAgIGluZGV4OmluZGV4LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY2MudnYuaHR0cC5zZW5kUmVxdWVzdChcIi9nZXRfZGV0YWlsX29mX2dhbWVcIixkYXRhLG9uR2V0KTtcclxuICAgIH1cclxufSk7XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCwgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQgb25seSB3aGVuIHRoZSBjb21wb25lbnQgYXR0YWNoaW5nXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIG5vZGUgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuICAgIH0sXHJcblxyXG4gICAgYWRkQ2xpY2tFdmVudDpmdW5jdGlvbihub2RlLHRhcmdldCxjb21wb25lbnQsaGFuZGxlcil7XHJcbiAgICAgICAgY29uc29sZS5sb2coY29tcG9uZW50ICsgXCI6XCIgKyBoYW5kbGVyKTtcclxuICAgICAgICB2YXIgZXZlbnRIYW5kbGVyID0gbmV3IGNjLkNvbXBvbmVudC5FdmVudEhhbmRsZXIoKTtcclxuICAgICAgICBldmVudEhhbmRsZXIudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIGV2ZW50SGFuZGxlci5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgZXZlbnRIYW5kbGVyLmhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cclxuICAgICAgICB2YXIgY2xpY2tFdmVudHMgPSBub2RlLmdldENvbXBvbmVudChjYy5CdXR0b24pLmNsaWNrRXZlbnRzO1xyXG4gICAgICAgIGNsaWNrRXZlbnRzLnB1c2goZXZlbnRIYW5kbGVyKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGFkZFNsaWRlRXZlbnQ6ZnVuY3Rpb24obm9kZSx0YXJnZXQsY29tcG9uZW50LGhhbmRsZXIpe1xyXG4gICAgICAgIHZhciBldmVudEhhbmRsZXIgPSBuZXcgY2MuQ29tcG9uZW50LkV2ZW50SGFuZGxlcigpO1xyXG4gICAgICAgIGV2ZW50SGFuZGxlci50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgZXZlbnRIYW5kbGVyLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICBldmVudEhhbmRsZXIuaGFuZGxlciA9IGhhbmRsZXI7XHJcblxyXG4gICAgICAgIHZhciBzbGlkZUV2ZW50cyA9IG5vZGUuZ2V0Q29tcG9uZW50KGNjLlNsaWRlcikuc2xpZGVFdmVudHM7XHJcbiAgICAgICAgc2xpZGVFdmVudHMucHVzaChldmVudEhhbmRsZXIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xyXG4gICAgLy8gdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcclxuXHJcbiAgICAvLyB9LFxyXG59KTtcclxuIiwidmFyIHJhZGl4ID0gMTI7XHJcbnZhciBiYXNlID0gMTI4IC0gcmFkaXg7XHJcbmZ1bmN0aW9uIGNyeXB0byh2YWx1ZSl7XHJcbiAgICB2YWx1ZSAtPSBiYXNlO1xyXG4gICAgdmFyIGggPSBNYXRoLmZsb29yKHZhbHVlL3JhZGl4KSArIGJhc2U7XHJcbiAgICB2YXIgbCA9IHZhbHVlJXJhZGl4ICsgYmFzZTtcclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGgpICsgU3RyaW5nLmZyb21DaGFyQ29kZShsKTtcclxufVxyXG5cclxudmFyIGVuY29kZXJtYXAgPSB7fVxyXG52YXIgZGVjb2Rlcm1hcCA9IHt9XHJcbmZvcih2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSl7XHJcbiAgICB2YXIgY29kZSA9IG51bGw7XHJcbiAgICB2YXIgdiA9IGkgKyAxO1xyXG4gICAgaWYodiA+PSBiYXNlKXtcclxuICAgICAgICBjb2RlID0gY3J5cHRvKHYpO1xyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgICBjb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2KTsgICAgXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGVuY29kZXJtYXBbaV0gPSBjb2RlO1xyXG4gICAgZGVjb2Rlcm1hcFtjb2RlXSA9IGk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuY29kZShkYXRhKXtcclxuICAgIHZhciBjb250ZW50ID0gXCJcIjtcclxuICAgIHZhciBsZW4gPSBkYXRhLmxlbmd0aDtcclxuICAgIHZhciBhID0gKGxlbiA+PiAyNCkgJiAweGZmO1xyXG4gICAgdmFyIGIgPSAobGVuID4+IDE2KSAmIDB4ZmY7XHJcbiAgICB2YXIgYyA9IChsZW4gPj4gOCkgJiAweGZmO1xyXG4gICAgdmFyIGQgPSBsZW4gJiAweGZmO1xyXG4gICAgY29udGVudCArPSBlbmNvZGVybWFwW2FdO1xyXG4gICAgY29udGVudCArPSBlbmNvZGVybWFwW2JdO1xyXG4gICAgY29udGVudCArPSBlbmNvZGVybWFwW2NdO1xyXG4gICAgY29udGVudCArPSBlbmNvZGVybWFwW2RdO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgIGNvbnRlbnQgKz0gZW5jb2Rlcm1hcFtkYXRhW2ldXTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb250ZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDb2RlKGNvbnRlbnQsaW5kZXgpe1xyXG4gICAgdmFyIGMgPSBjb250ZW50LmNoYXJDb2RlQXQoaW5kZXgpO1xyXG4gICAgaWYoYyA+PSBiYXNlKXtcclxuICAgICAgICBjID0gY29udGVudC5jaGFyQXQoaW5kZXgpICsgY29udGVudC5jaGFyQXQoaW5kZXggKyAxKTtcclxuICAgIH1cclxuICAgIGVsc2V7XHJcbiAgICAgICAgYyA9IGNvbnRlbnQuY2hhckF0KGluZGV4KTtcclxuICAgIH1cclxuICAgIHJldHVybiBjO1xyXG59XHJcbmZ1bmN0aW9uIGRlY29kZShjb250ZW50KXtcclxuICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICB2YXIgbGVuID0gMDtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCA0OyArK2kpe1xyXG4gICAgICAgIHZhciBjID0gZ2V0Q29kZShjb250ZW50LGluZGV4KTtcclxuICAgICAgICBpbmRleCArPSBjLmxlbmd0aDtcclxuICAgICAgICB2YXIgdiA9IGRlY29kZXJtYXBbY107XHJcbiAgICAgICAgbGVuIHw9IHYgPDwgKDMtaSkqODtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShsZW4pO1xyXG4gICAgdmFyIGNudCA9IDA7XHJcbiAgICB3aGlsZShpbmRleCA8IGNvbnRlbnQubGVuZ3RoKXtcclxuICAgICAgICB2YXIgYyA9IGdldENvZGUoY29udGVudCxpbmRleCk7XHJcbiAgICAgICAgaW5kZXggKz0gYy5sZW5ndGg7XHJcbiAgICAgICAgbmV3RGF0YVtjbnRdID0gZGVjb2Rlcm1hcFtjXTtcclxuICAgICAgICBjbnQrKztcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdEYXRhO1xyXG59XHJcblxyXG5jYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcblxyXG4gICAgcHJvcGVydGllczoge1xyXG4gICAgICAgIC8vIGZvbzoge1xyXG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgY29tcG9uZW50IGF0dGFjaGluZ1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYSBub2RlIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcclxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXHJcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxyXG4gICAgICAgIC8vIH0sXHJcbiAgICAgICAgLy8gLi4uXHJcbiAgICAgICAgb25QbGF5Q2FsbGJhY2s6bnVsbCxcclxuICAgICAgICBfdm9pY2VNZWRpYVBhdGg6bnVsbCxcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLypcclxuICAgICAgICB2YXIgdXJsID0gY2MudXJsLnJhdyhcInJlc291cmNlcy90ZXN0LmFtclwiKTtcclxuICAgICAgICB2YXIgZmlsZURhdGEgPSBqc2IuZmlsZVV0aWxzLmdldERhdGFGcm9tRmlsZSh1cmwpO1xyXG4gICAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcclxuICAgICAgICB2YXIgc2VwID0gXCJcIjtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZmlsZURhdGEubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICBjb250ZW50ICs9IHNlcCArIGZpbGVEYXRhW2ldO1xyXG4gICAgICAgICAgICBzZXAgPSBcIixcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHVybCA9IGNjLnVybC5yYXcoXCJyZXNvdXJjZXMvdGVzdC50eHRcIik7XHJcbiAgICAgICAganNiLmZpbGVVdGlscy53cml0ZVN0cmluZ1RvRmlsZShjb250ZW50LHVybCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHVybCA9IGNjLnVybC5yYXcoXCJyZXNvdXJjZXMvdGVzdDIuYW1yc1wiKTtcclxuICAgICAgICB2YXIgY29udGVudCA9IGVuY29kZShmaWxlRGF0YSk7XHJcbiAgICAgICAganNiLmZpbGVVdGlscy53cml0ZVN0cmluZ1RvRmlsZShjb250ZW50LHVybCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHVybCA9IGNjLnVybC5yYXcoXCJyZXNvdXJjZXMvdGVzdDIuYW1yXCIpO1xyXG4gICAgICAgIGpzYi5maWxlVXRpbHMud3JpdGVEYXRhVG9GaWxlKGRlY29kZShjb250ZW50KSx1cmwpO1xyXG4gICAgICAgICovXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoY2Muc3lzLmlzTmF0aXZlKXtcclxuICAgICAgICAgICAgdGhpcy5fdm9pY2VNZWRpYVBhdGggPSBqc2IuZmlsZVV0aWxzLmdldFdyaXRhYmxlUGF0aCgpICsgXCIvdm9pY2Vtc2dzL1wiO1xyXG4gICAgICAgICAgICB0aGlzLnNldFN0b3JhZ2VEaXIodGhpcy5fdm9pY2VNZWRpYVBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIHByZXBhcmU6ZnVuY3Rpb24oZmlsZW5hbWUpe1xyXG4gICAgICAgIGlmKCFjYy5zeXMuaXNOYXRpdmUpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNjLnZ2LmF1ZGlvTWdyLnBhdXNlQWxsKCk7XHJcbiAgICAgICAgdGhpcy5jbGVhckNhY2hlKGZpbGVuYW1lKTtcclxuICAgICAgICBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0FORFJPSUQpe1xyXG4gICAgICAgICAgICBqc2IucmVmbGVjdGlvbi5jYWxsU3RhdGljTWV0aG9kKFwiY29tL3ZpdmlnYW1lcy92b2ljZXNkay9Wb2ljZVJlY29yZGVyXCIsIFwicHJlcGFyZVwiLCBcIihMamF2YS9sYW5nL1N0cmluZzspVlwiLGZpbGVuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0lPUyl7XHJcbiAgICAgICAgICAgIGpzYi5yZWZsZWN0aW9uLmNhbGxTdGF0aWNNZXRob2QoXCJWb2ljZVNES1wiLCBcInByZXBhcmVSZWNvcmQ6XCIsZmlsZW5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIHJlbGVhc2U6ZnVuY3Rpb24oKXtcclxuICAgICAgICBpZighY2Muc3lzLmlzTmF0aXZlKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYy52di5hdWRpb01nci5yZXN1bWVBbGwoKTtcclxuICAgICAgICBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0FORFJPSUQpe1xyXG4gICAgICAgICAgICBqc2IucmVmbGVjdGlvbi5jYWxsU3RhdGljTWV0aG9kKFwiY29tL3ZpdmlnYW1lcy92b2ljZXNkay9Wb2ljZVJlY29yZGVyXCIsIFwicmVsZWFzZVwiLCBcIigpVlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0lPUyl7XHJcbiAgICAgICAgICAgIGpzYi5yZWZsZWN0aW9uLmNhbGxTdGF0aWNNZXRob2QoXCJWb2ljZVNES1wiLCBcImZpbmlzaFJlY29yZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBjYW5jZWw6ZnVuY3Rpb24oKXtcclxuICAgICAgICBpZighY2Muc3lzLmlzTmF0aXZlKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYy52di5hdWRpb01nci5yZXN1bWVBbGwoKTtcclxuICAgICAgICBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0FORFJPSUQpe1xyXG4gICAgICAgICAgICBqc2IucmVmbGVjdGlvbi5jYWxsU3RhdGljTWV0aG9kKFwiY29tL3ZpdmlnYW1lcy92b2ljZXNkay9Wb2ljZVJlY29yZGVyXCIsIFwiY2FuY2VsXCIsIFwiKClWXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfSU9TKXtcclxuICAgICAgICAgICAganNiLnJlZmxlY3Rpb24uY2FsbFN0YXRpY01ldGhvZChcIlZvaWNlU0RLXCIsIFwiY2FuY2VsUmVjb3JkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgd3JpdGVWb2ljZTpmdW5jdGlvbihmaWxlbmFtZSx2b2ljZURhdGEpe1xyXG4gICAgICAgIGlmKCFjYy5zeXMuaXNOYXRpdmUpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHZvaWNlRGF0YSAmJiB2b2ljZURhdGEubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIHZhciBmaWxlRGF0YSA9IGRlY29kZSh2b2ljZURhdGEpO1xyXG4gICAgICAgICAgICB2YXIgdXJsID0gdGhpcy5fdm9pY2VNZWRpYVBhdGggKyBmaWxlbmFtZTtcclxuICAgICAgICAgICAgdGhpcy5jbGVhckNhY2hlKGZpbGVuYW1lKTtcclxuICAgICAgICAgICAganNiLmZpbGVVdGlscy53cml0ZURhdGFUb0ZpbGUoZmlsZURhdGEsdXJsKTsgXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgY2xlYXJDYWNoZTpmdW5jdGlvbihmaWxlbmFtZSl7XHJcbiAgICAgICAgaWYoY2Muc3lzLmlzTmF0aXZlKXtcclxuICAgICAgICAgICAgdmFyIHVybCA9IHRoaXMuX3ZvaWNlTWVkaWFQYXRoICsgZmlsZW5hbWU7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjaGVjayBmaWxlOlwiICsgdXJsKTtcclxuICAgICAgICAgICAgaWYoanNiLmZpbGVVdGlscy5pc0ZpbGVFeGlzdCh1cmwpKXtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJyZW1vdmU6XCIgKyB1cmwpO1xyXG4gICAgICAgICAgICAgICAganNiLmZpbGVVdGlscy5yZW1vdmVGaWxlKHVybCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoanNiLmZpbGVVdGlscy5pc0ZpbGVFeGlzdCh1cmwgKyBcIi53YXZcIikpe1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInJlbW92ZTpcIiArIHVybCArIFwiLndhdlwiKTtcclxuICAgICAgICAgICAgICAgIGpzYi5maWxlVXRpbHMucmVtb3ZlRmlsZSh1cmwgKyBcIi53YXZcIik7XHJcbiAgICAgICAgICAgIH0gICBcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBwbGF5OmZ1bmN0aW9uKGZpbGVuYW1lKXtcclxuICAgICAgICBpZighY2Muc3lzLmlzTmF0aXZlKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYy52di5hdWRpb01nci5wYXVzZUFsbCgpO1xyXG4gICAgICAgIGlmKGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfQU5EUk9JRCl7XHJcbiAgICAgICAgICAgIGpzYi5yZWZsZWN0aW9uLmNhbGxTdGF0aWNNZXRob2QoXCJjb20vdml2aWdhbWVzL3ZvaWNlc2RrL1ZvaWNlUGxheWVyXCIsIFwicGxheVwiLCBcIihMamF2YS9sYW5nL1N0cmluZzspVlwiLGZpbGVuYW1lKTsgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoY2Muc3lzLm9zID09IGNjLnN5cy5PU19JT1Mpe1xyXG4gICAgICAgICAgICBqc2IucmVmbGVjdGlvbi5jYWxsU3RhdGljTWV0aG9kKFwiVm9pY2VTREtcIiwgXCJwbGF5OlwiLGZpbGVuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzdG9wOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYoIWNjLnN5cy5pc05hdGl2ZSl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2MudnYuYXVkaW9NZ3IucmVzdW1lQWxsKCk7XHJcbiAgICAgICAgaWYoY2Muc3lzLm9zID09IGNjLnN5cy5PU19BTkRST0lEKXtcclxuICAgICAgICAgICAganNiLnJlZmxlY3Rpb24uY2FsbFN0YXRpY01ldGhvZChcImNvbS92aXZpZ2FtZXMvdm9pY2VzZGsvVm9pY2VQbGF5ZXJcIiwgXCJzdG9wXCIsIFwiKClWXCIpOyBcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0lPUyl7XHJcbiAgICAgICAgICAgIGpzYi5yZWZsZWN0aW9uLmNhbGxTdGF0aWNNZXRob2QoXCJWb2ljZVNES1wiLCBcInN0b3BQbGF5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIGdldFZvaWNlTGV2ZWw6ZnVuY3Rpb24obWF4TGV2ZWwpe1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXhMZXZlbCArIDEpO1xyXG4gICAgICAgIGlmKGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfQU5EUk9JRCl7IFxyXG4gICAgICAgICAgICByZXR1cm4ganNiLnJlZmxlY3Rpb24uY2FsbFN0YXRpY01ldGhvZChcImNvbS92aXZpZ2FtZXMvdm9pY2VzZGsvVm9pY2VSZWNvcmRlclwiLCBcImdldFZvaWNlTGV2ZWxcIiwgXCIoSSlJXCIsbWF4TGV2ZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfSU9TKXtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heExldmVsICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgZ2V0Vm9pY2VEYXRhOmZ1bmN0aW9uKGZpbGVuYW1lKXtcclxuICAgICAgICBpZihjYy5zeXMuaXNOYXRpdmUpe1xyXG4gICAgICAgICAgICB2YXIgdXJsID0gdGhpcy5fdm9pY2VNZWRpYVBhdGggKyBmaWxlbmFtZTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJnZXRWb2ljZURhdGE6XCIgKyB1cmwpO1xyXG4gICAgICAgICAgICB2YXIgZmlsZURhdGEgPSBqc2IuZmlsZVV0aWxzLmdldERhdGFGcm9tRmlsZSh1cmwpO1xyXG4gICAgICAgICAgICBpZihmaWxlRGF0YSl7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IGVuY29kZShmaWxlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGRvd25sb2FkOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgXHJcbiAgICB9LFxyXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcclxuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XHJcblxyXG4gICAgLy8gfSxcclxuICAgIFxyXG4gICAgc2V0U3RvcmFnZURpcjpmdW5jdGlvbihkaXIpe1xyXG4gICAgICAgIGlmKCFjYy5zeXMuaXNOYXRpdmUpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfQU5EUk9JRCl7IFxyXG4gICAgICAgICAgICBqc2IucmVmbGVjdGlvbi5jYWxsU3RhdGljTWV0aG9kKFwiY29tL3ZpdmlnYW1lcy92b2ljZXNkay9Wb2ljZVJlY29yZGVyXCIsIFwic2V0U3RvcmFnZURpclwiLCBcIihMamF2YS9sYW5nL1N0cmluZzspVlwiLGRpcik7ICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfSU9TKXtcclxuICAgICAgICAgICAganNiLnJlZmxlY3Rpb24uY2FsbFN0YXRpY01ldGhvZChcIlZvaWNlU0RLXCIsIFwic2V0U3RvcmFnZURpcjpcIixkaXIpO1xyXG4gICAgICAgICAgICBpZighanNiLmZpbGVVdGlscy5pc0RpcmVjdG9yeUV4aXN0KGRpcikpe1xyXG4gICAgICAgICAgICAgICAganNiLmZpbGVVdGlscy5jcmVhdGVEaXJlY3RvcnkoZGlyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbiIsImNjLkNsYXNzKHtcclxuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcclxuXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCwgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQgb25seSB3aGVuIHRoZSBjb21wb25lbnQgYXR0YWNoaW5nXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIG5vZGUgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxyXG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxyXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcclxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAvLyAuLi5cclxuICAgICAgICBfbGFzdFRvdWNoVGltZTpudWxsLFxyXG4gICAgICAgIF92b2ljZTpudWxsLFxyXG4gICAgICAgIF92b2x1bWU6bnVsbCxcclxuICAgICAgICBfdm9pY2VfZmFpbGVkOm51bGwsXHJcbiAgICAgICAgX2xhc3RDaGVja1RpbWU6LTEsXHJcbiAgICAgICAgX3RpbWVCYXI6bnVsbCxcclxuICAgICAgICBNQVhfVElNRToxNTAwMCxcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl92b2ljZSA9IGNjLmZpbmQoXCJDYW52YXMvdm9pY2VcIik7XHJcbiAgICAgICAgdGhpcy5fdm9pY2UuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5fdm9pY2VfZmFpbGVkID0gY2MuZmluZChcIkNhbnZhcy92b2ljZS92b2ljZV9mYWlsZWRcIik7XHJcbiAgICAgICAgdGhpcy5fdm9pY2VfZmFpbGVkLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX3RpbWVCYXIgPSBjYy5maW5kKFwiQ2FudmFzL3ZvaWNlL3RpbWVcIik7XHJcbiAgICAgICAgdGhpcy5fdGltZUJhci5zY2FsZVggPSAwLjA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5fdm9sdW1lID0gY2MuZmluZChcIkNhbnZhcy92b2ljZS92b2x1bWVcIik7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IHRoaXMuX3ZvbHVtZS5jaGlsZHJlbi5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZvbHVtZS5jaGlsZHJlbltpXS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGJ0blZvaWNlID0gY2MuZmluZChcIkNhbnZhcy92b2ljZS92b2ljZV9mYWlsZWQvYnRuX29rXCIpO1xyXG4gICAgICAgIGlmKGJ0blZvaWNlKXtcclxuICAgICAgICAgICAgY2MudnYudXRpbHMuYWRkQ2xpY2tFdmVudChidG5Wb2ljZSx0aGlzLm5vZGUsXCJWb2ljZVwiLFwib25CdG5PS0NsaWNrZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgYnRuVm9pY2UgPSBjYy5maW5kKFwiQ2FudmFzL2J0bl92b2ljZVwiKTtcclxuICAgICAgICBpZihidG5Wb2ljZSl7XHJcbiAgICAgICAgICAgIGJ0blZvaWNlLm9uKGNjLk5vZGUuRXZlbnRUeXBlLlRPVUNIX1NUQVJULGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNjLk5vZGUuRXZlbnRUeXBlLlRPVUNIX1NUQVJUXCIpO1xyXG4gICAgICAgICAgICAgICAgY2MudnYudm9pY2VNZ3IucHJlcGFyZShcInJlY29yZC5hbXJcIik7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9sYXN0VG91Y2hUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3ZvaWNlLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl92b2ljZV9mYWlsZWQuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgYnRuVm9pY2Uub24oY2MuTm9kZS5FdmVudFR5cGUuVE9VQ0hfTU9WRSxmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYy5Ob2RlLkV2ZW50VHlwZS5UT1VDSF9NT1ZFXCIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGJ0blZvaWNlLm9uKGNjLk5vZGUuRXZlbnRUeXBlLlRPVUNIX0VORCxmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYy5Ob2RlLkV2ZW50VHlwZS5UT1VDSF9FTkRcIik7XHJcbiAgICAgICAgICAgICAgICBpZihEYXRlLm5vdygpIC0gc2VsZi5fbGFzdFRvdWNoVGltZSA8IDEwMDApe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3ZvaWNlX2ZhaWxlZC5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLnZ2LnZvaWNlTWdyLmNhbmNlbCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLm9uVm9pY2VPSygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VsZi5fbGFzdFRvdWNoVGltZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYnRuVm9pY2Uub24oY2MuTm9kZS5FdmVudFR5cGUuVE9VQ0hfQ0FOQ0VMLGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNjLk5vZGUuRXZlbnRUeXBlLlRPVUNIX0NBTkNFTFwiKTtcclxuICAgICAgICAgICAgICAgIGNjLnZ2LnZvaWNlTWdyLmNhbmNlbCgpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fbGFzdFRvdWNoVGltZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl92b2ljZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgb25Wb2ljZU9LOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYodGhpcy5fbGFzdFRvdWNoVGltZSAhPSBudWxsKXtcclxuICAgICAgICAgICAgY2MudnYudm9pY2VNZ3IucmVsZWFzZSgpO1xyXG4gICAgICAgICAgICB2YXIgdGltZSA9IERhdGUubm93KCkgLSB0aGlzLl9sYXN0VG91Y2hUaW1lO1xyXG4gICAgICAgICAgICB2YXIgbXNnID0gY2MudnYudm9pY2VNZ3IuZ2V0Vm9pY2VEYXRhKFwicmVjb3JkLmFtclwiKTtcclxuICAgICAgICAgICAgY2MudnYubmV0LnNlbmQoXCJ2b2ljZV9tc2dcIix7bXNnOm1zZyx0aW1lOnRpbWV9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdm9pY2UuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBvbkJ0bk9LQ2xpY2tlZDpmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuX3ZvaWNlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcclxuICAgICAgICBpZih0aGlzLl92b2ljZS5hY3RpdmUgPT0gdHJ1ZSAmJiB0aGlzLl92b2ljZV9mYWlsZWQuYWN0aXZlID09IGZhbHNlKXtcclxuICAgICAgICAgICAgaWYoRGF0ZS5ub3coKSAtIHRoaXMuX2xhc3RDaGVja1RpbWUgPiAzMDApe1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX3ZvbHVtZS5jaGlsZHJlbi5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdm9sdW1lLmNoaWxkcmVuW2ldLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSBjYy52di52b2ljZU1nci5nZXRWb2ljZUxldmVsKDcpO1xyXG4gICAgICAgICAgICAgICAgaWYodiA+PSAxICYmIHYgPD0gNyl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdm9sdW1lLmNoaWxkcmVuW3YtMV0uYWN0aXZlID0gdHJ1ZTsgICBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RDaGVja1RpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHRoaXMuX2xhc3RUb3VjaFRpbWUpe1xyXG4gICAgICAgICAgICB2YXIgdGltZSA9IERhdGUubm93KCkgLSB0aGlzLl9sYXN0VG91Y2hUaW1lO1xyXG4gICAgICAgICAgICBpZih0aW1lID49IHRoaXMuTUFYX1RJTUUpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblZvaWNlT0soKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RUb3VjaFRpbWUgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9IHRpbWUgLyB0aGlzLk1BWF9USU1FO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZUJhci5zY2FsZVggPSAxIC0gcGVyY2VudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbn0pO1xyXG4iLCJjYy5DbGFzcyh7XHJcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXHJcbiAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgdGFyZ2V0OmNjLk5vZGUsXHJcbiAgICAgICAgLy8gZm9vOiB7XHJcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCxcclxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XHJcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxyXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcclxuICAgICAgICAvLyB9LFxyXG4gICAgICAgIC8vIC4uLlxyXG4gICAgICAgIF9pc1Nob3c6ZmFsc2UsXHJcbiAgICAgICAgbGJsQ29udGVudDpjYy5MYWJlbCxcclxuICAgIH0sXHJcblxyXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZihjYy52diA9PSBudWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGNjLnZ2LndjID0gdGhpcztcclxuICAgICAgICB0aGlzLm5vZGUuYWN0aXZlID0gdGhpcy5faXNTaG93O1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xyXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcclxuICAgICAgICB0aGlzLnRhcmdldC5yb3RhdGlvbiA9IHRoaXMudGFyZ2V0LnJvdGF0aW9uIC0gZHQqNDU7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzaG93OmZ1bmN0aW9uKGNvbnRlbnQpe1xyXG4gICAgICAgIHRoaXMuX2lzU2hvdyA9IHRydWU7XHJcbiAgICAgICAgaWYodGhpcy5ub2RlKXtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLmFjdGl2ZSA9IHRoaXMuX2lzU2hvdzsgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5sYmxDb250ZW50KXtcclxuICAgICAgICAgICAgaWYoY29udGVudCA9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubGJsQ29udGVudC5zdHJpbmcgPSBjb250ZW50O1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBoaWRlOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5faXNTaG93ID0gZmFsc2U7XHJcbiAgICAgICAgaWYodGhpcy5ub2RlKXtcclxuICAgICAgICAgICAgdGhpcy5ub2RlLmFjdGl2ZSA9IHRoaXMuX2lzU2hvdzsgICBcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG4iLCJpZiAoIUNDX0pTQiAmJiAhY2Muc3lzLmlzTmF0aXZlKSB7XG5cdChmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLmlvID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5cdG1vZHVsZS5leHBvcnRzID0gIF9kZXJlcV8oJy4vbGliLycpO1xuXG5cdH0se1wiLi9saWIvXCI6Mn1dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi9zb2NrZXQnKTtcblxuXHQvKipcblx0ICogRXhwb3J0cyBwYXJzZXJcblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICpcblx0ICovXG5cdG1vZHVsZS5leHBvcnRzLnBhcnNlciA9IF9kZXJlcV8oJ2VuZ2luZS5pby1wYXJzZXInKTtcblxuXHR9LHtcIi4vc29ja2V0XCI6MyxcImVuZ2luZS5pby1wYXJzZXJcIjoxOX1dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQoZnVuY3Rpb24gKGdsb2JhbCl7XG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblxuXHR2YXIgdHJhbnNwb3J0cyA9IF9kZXJlcV8oJy4vdHJhbnNwb3J0cycpO1xuXHR2YXIgRW1pdHRlciA9IF9kZXJlcV8oJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cdHZhciBkZWJ1ZyA9IF9kZXJlcV8oJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6c29ja2V0Jyk7XG5cdHZhciBpbmRleCA9IF9kZXJlcV8oJ2luZGV4b2YnKTtcblx0dmFyIHBhcnNlciA9IF9kZXJlcV8oJ2VuZ2luZS5pby1wYXJzZXInKTtcblx0dmFyIHBhcnNldXJpID0gX2RlcmVxXygncGFyc2V1cmknKTtcblx0dmFyIHBhcnNlanNvbiA9IF9kZXJlcV8oJ3BhcnNlanNvbicpO1xuXHR2YXIgcGFyc2VxcyA9IF9kZXJlcV8oJ3BhcnNlcXMnKTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gU29ja2V0O1xuXG5cdC8qKlxuXHQgKiBOb29wIGZ1bmN0aW9uLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gbm9vcCgpe31cblxuXHQvKipcblx0ICogU29ja2V0IGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVyaSBvciBvcHRpb25zXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFNvY2tldCh1cmksIG9wdHMpe1xuXHQgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrZXQpKSByZXR1cm4gbmV3IFNvY2tldCh1cmksIG9wdHMpO1xuXG5cdCAgb3B0cyA9IG9wdHMgfHwge307XG5cblx0ICBpZiAodXJpICYmICdvYmplY3QnID09IHR5cGVvZiB1cmkpIHtcblx0XHRvcHRzID0gdXJpO1xuXHRcdHVyaSA9IG51bGw7XG5cdCAgfVxuXG5cdCAgaWYgKHVyaSkge1xuXHRcdHVyaSA9IHBhcnNldXJpKHVyaSk7XG5cdFx0b3B0cy5ob3N0bmFtZSA9IHVyaS5ob3N0O1xuXHRcdG9wdHMuc2VjdXJlID0gdXJpLnByb3RvY29sID09ICdodHRwcycgfHwgdXJpLnByb3RvY29sID09ICd3c3MnO1xuXHRcdG9wdHMucG9ydCA9IHVyaS5wb3J0O1xuXHRcdGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG5cdCAgfSBlbHNlIGlmIChvcHRzLmhvc3QpIHtcblx0XHRvcHRzLmhvc3RuYW1lID0gcGFyc2V1cmkob3B0cy5ob3N0KS5ob3N0O1xuXHQgIH1cblxuXHQgIHRoaXMuc2VjdXJlID0gbnVsbCAhPSBvcHRzLnNlY3VyZSA/IG9wdHMuc2VjdXJlIDpcblx0XHQoZ2xvYmFsLmxvY2F0aW9uICYmICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sKTtcblxuXHQgIGlmIChvcHRzLmhvc3RuYW1lICYmICFvcHRzLnBvcnQpIHtcblx0XHQvLyBpZiBubyBwb3J0IGlzIHNwZWNpZmllZCBtYW51YWxseSwgdXNlIHRoZSBwcm90b2NvbCBkZWZhdWx0XG5cdFx0b3B0cy5wb3J0ID0gdGhpcy5zZWN1cmUgPyAnNDQzJyA6ICc4MCc7XG5cdCAgfVxuXG5cdCAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG5cdCAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHxcblx0XHQoZ2xvYmFsLmxvY2F0aW9uID8gbG9jYXRpb24uaG9zdG5hbWUgOiAnbG9jYWxob3N0Jyk7XG5cdCAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0IHx8IChnbG9iYWwubG9jYXRpb24gJiYgbG9jYXRpb24ucG9ydCA/XG5cdFx0ICAgbG9jYXRpb24ucG9ydCA6XG5cdFx0ICAgKHRoaXMuc2VjdXJlID8gNDQzIDogODApKTtcblx0ICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeSB8fCB7fTtcblx0ICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHRoaXMucXVlcnkpIHRoaXMucXVlcnkgPSBwYXJzZXFzLmRlY29kZSh0aGlzLnF1ZXJ5KTtcblx0ICB0aGlzLnVwZ3JhZGUgPSBmYWxzZSAhPT0gb3B0cy51cGdyYWRlO1xuXHQgIHRoaXMucGF0aCA9IChvcHRzLnBhdGggfHwgJy9lbmdpbmUuaW8nKS5yZXBsYWNlKC9cXC8kLywgJycpICsgJy8nO1xuXHQgIHRoaXMuZm9yY2VKU09OUCA9ICEhb3B0cy5mb3JjZUpTT05QO1xuXHQgIHRoaXMuanNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcblx0ICB0aGlzLmZvcmNlQmFzZTY0ID0gISFvcHRzLmZvcmNlQmFzZTY0O1xuXHQgIHRoaXMuZW5hYmxlc1hEUiA9ICEhb3B0cy5lbmFibGVzWERSO1xuXHQgIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtIHx8ICd0Jztcblx0ICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcblx0ICB0aGlzLnRyYW5zcG9ydHMgPSBvcHRzLnRyYW5zcG9ydHMgfHwgWydwb2xsaW5nJywgJ3dlYnNvY2tldCddO1xuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuXHQgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcblx0ICB0aGlzLnBvbGljeVBvcnQgPSBvcHRzLnBvbGljeVBvcnQgfHwgODQzO1xuXHQgIHRoaXMucmVtZW1iZXJVcGdyYWRlID0gb3B0cy5yZW1lbWJlclVwZ3JhZGUgfHwgZmFsc2U7XG5cdCAgdGhpcy5iaW5hcnlUeXBlID0gbnVsbDtcblx0ICB0aGlzLm9ubHlCaW5hcnlVcGdyYWRlcyA9IG9wdHMub25seUJpbmFyeVVwZ3JhZGVzO1xuXHQgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBmYWxzZSAhPT0gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA/IChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIHx8IHt9KSA6IGZhbHNlO1xuXG5cdCAgaWYgKHRydWUgPT09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUpIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcblx0ICBpZiAodGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSAmJiBudWxsID09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG5cdFx0dGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQgPSAxMDI0O1xuXHQgIH1cblxuXHQgIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIHRoaXMucGZ4ID0gb3B0cy5wZnggfHwgbnVsbDtcblx0ICB0aGlzLmtleSA9IG9wdHMua2V5IHx8IG51bGw7XG5cdCAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlIHx8IG51bGw7XG5cdCAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0IHx8IG51bGw7XG5cdCAgdGhpcy5jYSA9IG9wdHMuY2EgfHwgbnVsbDtcblx0ICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnMgfHwgbnVsbDtcblx0ICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cblx0ICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdCAgaWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0aWYgKG9wdHMuZXh0cmFIZWFkZXJzICYmIE9iamVjdC5rZXlzKG9wdHMuZXh0cmFIZWFkZXJzKS5sZW5ndGggPiAwKSB7XG5cdFx0ICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXHRcdH1cblx0ICB9XG5cblx0ICB0aGlzLm9wZW4oKTtcblx0fVxuXG5cdFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuXHQvKipcblx0ICogTWl4IGluIGBFbWl0dGVyYC5cblx0ICovXG5cblx0RW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuXHQvKipcblx0ICogUHJvdG9jb2wgdmVyc2lvbi5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0U29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG5cdC8qKlxuXHQgKiBFeHBvc2UgZGVwcyBmb3IgbGVnYWN5IGNvbXBhdGliaWxpdHlcblx0ICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG5cdCAqL1xuXG5cdFNvY2tldC5Tb2NrZXQgPSBTb2NrZXQ7XG5cdFNvY2tldC5UcmFuc3BvcnQgPSBfZGVyZXFfKCcuL3RyYW5zcG9ydCcpO1xuXHRTb2NrZXQudHJhbnNwb3J0cyA9IF9kZXJlcV8oJy4vdHJhbnNwb3J0cycpO1xuXHRTb2NrZXQucGFyc2VyID0gX2RlcmVxXygnZW5naW5lLmlvLXBhcnNlcicpO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIHRyYW5zcG9ydCBvZiB0aGUgZ2l2ZW4gdHlwZS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG5cdCAqIEByZXR1cm4ge1RyYW5zcG9ydH1cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICBkZWJ1ZygnY3JlYXRpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuXHQgIHZhciBxdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuXG5cdCAgLy8gYXBwZW5kIGVuZ2luZS5pbyBwcm90b2NvbCBpZGVudGlmaWVyXG5cdCAgcXVlcnkuRUlPID0gcGFyc2VyLnByb3RvY29sO1xuXG5cdCAgLy8gdHJhbnNwb3J0IG5hbWVcblx0ICBxdWVyeS50cmFuc3BvcnQgPSBuYW1lO1xuXG5cdCAgLy8gc2Vzc2lvbiBpZCBpZiB3ZSBhbHJlYWR5IGhhdmUgb25lXG5cdCAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cblx0ICB2YXIgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydHNbbmFtZV0oe1xuXHRcdGFnZW50OiB0aGlzLmFnZW50LFxuXHRcdGhvc3RuYW1lOiB0aGlzLmhvc3RuYW1lLFxuXHRcdHBvcnQ6IHRoaXMucG9ydCxcblx0XHRzZWN1cmU6IHRoaXMuc2VjdXJlLFxuXHRcdHBhdGg6IHRoaXMucGF0aCxcblx0XHRxdWVyeTogcXVlcnksXG5cdFx0Zm9yY2VKU09OUDogdGhpcy5mb3JjZUpTT05QLFxuXHRcdGpzb25wOiB0aGlzLmpzb25wLFxuXHRcdGZvcmNlQmFzZTY0OiB0aGlzLmZvcmNlQmFzZTY0LFxuXHRcdGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUixcblx0XHR0aW1lc3RhbXBSZXF1ZXN0czogdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyxcblx0XHR0aW1lc3RhbXBQYXJhbTogdGhpcy50aW1lc3RhbXBQYXJhbSxcblx0XHRwb2xpY3lQb3J0OiB0aGlzLnBvbGljeVBvcnQsXG5cdFx0c29ja2V0OiB0aGlzLFxuXHRcdHBmeDogdGhpcy5wZngsXG5cdFx0a2V5OiB0aGlzLmtleSxcblx0XHRwYXNzcGhyYXNlOiB0aGlzLnBhc3NwaHJhc2UsXG5cdFx0Y2VydDogdGhpcy5jZXJ0LFxuXHRcdGNhOiB0aGlzLmNhLFxuXHRcdGNpcGhlcnM6IHRoaXMuY2lwaGVycyxcblx0XHRyZWplY3RVbmF1dGhvcml6ZWQ6IHRoaXMucmVqZWN0VW5hdXRob3JpemVkLFxuXHRcdHBlck1lc3NhZ2VEZWZsYXRlOiB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLFxuXHRcdGV4dHJhSGVhZGVyczogdGhpcy5leHRyYUhlYWRlcnNcblx0ICB9KTtcblxuXHQgIHJldHVybiB0cmFuc3BvcnQ7XG5cdH07XG5cblx0ZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuXHQgIHZhciBvID0ge307XG5cdCAgZm9yICh2YXIgaSBpbiBvYmopIHtcblx0XHRpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0ICBvW2ldID0gb2JqW2ldO1xuXHRcdH1cblx0ICB9XG5cdCAgcmV0dXJuIG87XG5cdH1cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFNvY2tldC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgdHJhbnNwb3J0O1xuXHQgIGlmICh0aGlzLnJlbWVtYmVyVXBncmFkZSAmJiBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzICYmIHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKCd3ZWJzb2NrZXQnKSAhPSAtMSkge1xuXHRcdHRyYW5zcG9ydCA9ICd3ZWJzb2NrZXQnO1xuXHQgIH0gZWxzZSBpZiAoMCA9PT0gdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuXHRcdC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdCAgc2VsZi5lbWl0KCdlcnJvcicsICdObyB0cmFuc3BvcnRzIGF2YWlsYWJsZScpO1xuXHRcdH0sIDApO1xuXHRcdHJldHVybjtcblx0ICB9IGVsc2Uge1xuXHRcdHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0c1swXTtcblx0ICB9XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXG5cdCAgLy8gUmV0cnkgd2l0aCB0aGUgbmV4dCB0cmFuc3BvcnQgaWYgdGhlIHRyYW5zcG9ydCBpcyBkaXNhYmxlZCAoanNvbnA6IGZhbHNlKVxuXHQgIHRyeSB7XG5cdFx0dHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcblx0ICB9IGNhdGNoIChlKSB7XG5cdFx0dGhpcy50cmFuc3BvcnRzLnNoaWZ0KCk7XG5cdFx0dGhpcy5vcGVuKCk7XG5cdFx0cmV0dXJuO1xuXHQgIH1cblxuXHQgIHRyYW5zcG9ydC5vcGVuKCk7XG5cdCAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQuIERpc2FibGVzIHRoZSBleGlzdGluZyBvbmUgKGlmIGFueSkuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLnNldFRyYW5zcG9ydCA9IGZ1bmN0aW9uKHRyYW5zcG9ydCl7XG5cdCAgZGVidWcoJ3NldHRpbmcgdHJhbnNwb3J0ICVzJywgdHJhbnNwb3J0Lm5hbWUpO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblxuXHQgIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuXHRcdGRlYnVnKCdjbGVhcmluZyBleGlzdGluZyB0cmFuc3BvcnQgJXMnLCB0aGlzLnRyYW5zcG9ydC5uYW1lKTtcblx0XHR0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblx0ICB9XG5cblx0ICAvLyBzZXQgdXAgdHJhbnNwb3J0XG5cdCAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cblx0ICAvLyBzZXQgdXAgdHJhbnNwb3J0IGxpc3RlbmVyc1xuXHQgIHRyYW5zcG9ydFxuXHQgIC5vbignZHJhaW4nLCBmdW5jdGlvbigpe1xuXHRcdHNlbGYub25EcmFpbigpO1xuXHQgIH0pXG5cdCAgLm9uKCdwYWNrZXQnLCBmdW5jdGlvbihwYWNrZXQpe1xuXHRcdHNlbGYub25QYWNrZXQocGFja2V0KTtcblx0ICB9KVxuXHQgIC5vbignZXJyb3InLCBmdW5jdGlvbihlKXtcblx0XHRzZWxmLm9uRXJyb3IoZSk7XG5cdCAgfSlcblx0ICAub24oJ2Nsb3NlJywgZnVuY3Rpb24oKXtcblx0XHRzZWxmLm9uQ2xvc2UoJ3RyYW5zcG9ydCBjbG9zZScpO1xuXHQgIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcm9iZXMgYSB0cmFuc3BvcnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5wcm9iZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgZGVidWcoJ3Byb2JpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuXHQgIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lLCB7IHByb2JlOiAxIH0pXG5cdFx0LCBmYWlsZWQgPSBmYWxzZVxuXHRcdCwgc2VsZiA9IHRoaXM7XG5cblx0ICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cblx0ICBmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4oKXtcblx0XHRpZiAoc2VsZi5vbmx5QmluYXJ5VXBncmFkZXMpIHtcblx0XHQgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcblx0XHQgIGZhaWxlZCA9IGZhaWxlZCB8fCB1cGdyYWRlTG9zZXNCaW5hcnk7XG5cdFx0fVxuXHRcdGlmIChmYWlsZWQpIHJldHVybjtcblxuXHRcdGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIG9wZW5lZCcsIG5hbWUpO1xuXHRcdHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICdwaW5nJywgZGF0YTogJ3Byb2JlJyB9XSk7XG5cdFx0dHJhbnNwb3J0Lm9uY2UoJ3BhY2tldCcsIGZ1bmN0aW9uIChtc2cpIHtcblx0XHQgIGlmIChmYWlsZWQpIHJldHVybjtcblx0XHQgIGlmICgncG9uZycgPT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PSBtc2cuZGF0YSkge1xuXHRcdFx0ZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgcG9uZycsIG5hbWUpO1xuXHRcdFx0c2VsZi51cGdyYWRpbmcgPSB0cnVlO1xuXHRcdFx0c2VsZi5lbWl0KCd1cGdyYWRpbmcnLCB0cmFuc3BvcnQpO1xuXHRcdFx0aWYgKCF0cmFuc3BvcnQpIHJldHVybjtcblx0XHRcdFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PSB0cmFuc3BvcnQubmFtZTtcblxuXHRcdFx0ZGVidWcoJ3BhdXNpbmcgY3VycmVudCB0cmFuc3BvcnQgXCIlc1wiJywgc2VsZi50cmFuc3BvcnQubmFtZSk7XG5cdFx0XHRzZWxmLnRyYW5zcG9ydC5wYXVzZShmdW5jdGlvbiAoKSB7XG5cdFx0XHQgIGlmIChmYWlsZWQpIHJldHVybjtcblx0XHRcdCAgaWYgKCdjbG9zZWQnID09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuXHRcdFx0ICBkZWJ1ZygnY2hhbmdpbmcgdHJhbnNwb3J0IGFuZCBzZW5kaW5nIHVwZ3JhZGUgcGFja2V0Jyk7XG5cblx0XHRcdCAgY2xlYW51cCgpO1xuXG5cdFx0XHQgIHNlbGYuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG5cdFx0XHQgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICd1cGdyYWRlJyB9XSk7XG5cdFx0XHQgIHNlbGYuZW1pdCgndXBncmFkZScsIHRyYW5zcG9ydCk7XG5cdFx0XHQgIHRyYW5zcG9ydCA9IG51bGw7XG5cdFx0XHQgIHNlbGYudXBncmFkaW5nID0gZmFsc2U7XG5cdFx0XHQgIHNlbGYuZmx1c2goKTtcblx0XHRcdH0pO1xuXHRcdCAgfSBlbHNlIHtcblx0XHRcdGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCcsIG5hbWUpO1xuXHRcdFx0dmFyIGVyciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3InKTtcblx0XHRcdGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblx0XHRcdHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyKTtcblx0XHQgIH1cblx0XHR9KTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQoKSB7XG5cdFx0aWYgKGZhaWxlZCkgcmV0dXJuO1xuXG5cdFx0Ly8gQW55IGNhbGxiYWNrIGNhbGxlZCBieSB0cmFuc3BvcnQgc2hvdWxkIGJlIGlnbm9yZWQgc2luY2Ugbm93XG5cdFx0ZmFpbGVkID0gdHJ1ZTtcblxuXHRcdGNsZWFudXAoKTtcblxuXHRcdHRyYW5zcG9ydC5jbG9zZSgpO1xuXHRcdHRyYW5zcG9ydCA9IG51bGw7XG5cdCAgfVxuXG5cdCAgLy9IYW5kbGUgYW55IGVycm9yIHRoYXQgaGFwcGVucyB3aGlsZSBwcm9iaW5nXG5cdCAgZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcblx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yOiAnICsgZXJyKTtcblx0XHRlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblxuXHRcdGZyZWV6ZVRyYW5zcG9ydCgpO1xuXG5cdFx0ZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkIGJlY2F1c2Ugb2YgZXJyb3I6ICVzJywgbmFtZSwgZXJyKTtcblxuXHRcdHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyb3IpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UoKXtcblx0XHRvbmVycm9yKFwidHJhbnNwb3J0IGNsb3NlZFwiKTtcblx0ICB9XG5cblx0ICAvL1doZW4gdGhlIHNvY2tldCBpcyBjbG9zZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuXHQgIGZ1bmN0aW9uIG9uY2xvc2UoKXtcblx0XHRvbmVycm9yKFwic29ja2V0IGNsb3NlZFwiKTtcblx0ICB9XG5cblx0ICAvL1doZW4gdGhlIHNvY2tldCBpcyB1cGdyYWRlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG5cdCAgZnVuY3Rpb24gb251cGdyYWRlKHRvKXtcblx0XHRpZiAodHJhbnNwb3J0ICYmIHRvLm5hbWUgIT0gdHJhbnNwb3J0Lm5hbWUpIHtcblx0XHQgIGRlYnVnKCdcIiVzXCIgd29ya3MgLSBhYm9ydGluZyBcIiVzXCInLCB0by5uYW1lLCB0cmFuc3BvcnQubmFtZSk7XG5cdFx0ICBmcmVlemVUcmFuc3BvcnQoKTtcblx0XHR9XG5cdCAgfVxuXG5cdCAgLy9SZW1vdmUgYWxsIGxpc3RlbmVycyBvbiB0aGUgdHJhbnNwb3J0IGFuZCBvbiBzZWxmXG5cdCAgZnVuY3Rpb24gY2xlYW51cCgpe1xuXHRcdHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG5cdFx0dHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXHRcdHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcblx0XHRzZWxmLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXHRcdHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG5cdCAgfVxuXG5cdCAgdHJhbnNwb3J0Lm9uY2UoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuXHQgIHRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uZXJyb3IpO1xuXHQgIHRyYW5zcG9ydC5vbmNlKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXG5cdCAgdGhpcy5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuXHQgIHRoaXMub25jZSgndXBncmFkaW5nJywgb251cGdyYWRlKTtcblxuXHQgIHRyYW5zcG9ydC5vcGVuKCk7XG5cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBkZWVtZWQgb3Blbi5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgZGVidWcoJ3NvY2tldCBvcGVuJyk7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuXHQgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PSB0aGlzLnRyYW5zcG9ydC5uYW1lO1xuXHQgIHRoaXMuZW1pdCgnb3BlbicpO1xuXHQgIHRoaXMuZmx1c2goKTtcblxuXHQgIC8vIHdlIGNoZWNrIGZvciBgcmVhZHlTdGF0ZWAgaW4gY2FzZSBhbiBgb3BlbmBcblx0ICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG5cdCAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy51cGdyYWRlICYmIHRoaXMudHJhbnNwb3J0LnBhdXNlKSB7XG5cdFx0ZGVidWcoJ3N0YXJ0aW5nIHVwZ3JhZGUgcHJvYmVzJyk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnVwZ3JhZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdCAgdGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKTtcblx0XHR9XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGEgcGFja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcblx0ICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdFx0ZGVidWcoJ3NvY2tldCByZWNlaXZlOiB0eXBlIFwiJXNcIiwgZGF0YSBcIiVzXCInLCBwYWNrZXQudHlwZSwgcGFja2V0LmRhdGEpO1xuXG5cdFx0dGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXG5cdFx0Ly8gU29ja2V0IGlzIGxpdmUgLSBhbnkgcGFja2V0IGNvdW50c1xuXHRcdHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG5cblx0XHRzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG5cdFx0ICBjYXNlICdvcGVuJzpcblx0XHRcdHRoaXMub25IYW5kc2hha2UocGFyc2Vqc29uKHBhY2tldC5kYXRhKSk7XG5cdFx0XHRicmVhaztcblxuXHRcdCAgY2FzZSAncG9uZyc6XG5cdFx0XHR0aGlzLnNldFBpbmcoKTtcblx0XHRcdHRoaXMuZW1pdCgncG9uZycpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHQgIGNhc2UgJ2Vycm9yJzpcblx0XHRcdHZhciBlcnIgPSBuZXcgRXJyb3IoJ3NlcnZlciBlcnJvcicpO1xuXHRcdFx0ZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcblx0XHRcdHRoaXMub25FcnJvcihlcnIpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHQgIGNhc2UgJ21lc3NhZ2UnOlxuXHRcdFx0dGhpcy5lbWl0KCdkYXRhJywgcGFja2V0LmRhdGEpO1xuXHRcdFx0dGhpcy5lbWl0KCdtZXNzYWdlJywgcGFja2V0LmRhdGEpO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHQgIH0gZWxzZSB7XG5cdFx0ZGVidWcoJ3BhY2tldCByZWNlaXZlZCB3aXRoIHNvY2tldCByZWFkeVN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBoYW5kc2hha2UgY29tcGxldGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGhhbmRzaGFrZSBvYmpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUub25IYW5kc2hha2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHQgIHRoaXMuZW1pdCgnaGFuZHNoYWtlJywgZGF0YSk7XG5cdCAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuXHQgIHRoaXMudHJhbnNwb3J0LnF1ZXJ5LnNpZCA9IGRhdGEuc2lkO1xuXHQgIHRoaXMudXBncmFkZXMgPSB0aGlzLmZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO1xuXHQgIHRoaXMucGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG5cdCAgdGhpcy5waW5nVGltZW91dCA9IGRhdGEucGluZ1RpbWVvdXQ7XG5cdCAgdGhpcy5vbk9wZW4oKTtcblx0ICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG5cdCAgaWYgICgnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHJldHVybjtcblx0ICB0aGlzLnNldFBpbmcoKTtcblxuXHQgIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuXHQgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xuXHQgIHRoaXMub24oJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXNldHMgcGluZyB0aW1lb3V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbkhlYXJ0YmVhdCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG5cdCAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHNlbGYucGluZ1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdGlmICgnY2xvc2VkJyA9PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcblx0XHRzZWxmLm9uQ2xvc2UoJ3BpbmcgdGltZW91dCcpO1xuXHQgIH0sIHRpbWVvdXQgfHwgKHNlbGYucGluZ0ludGVydmFsICsgc2VsZi5waW5nVGltZW91dCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQaW5ncyBzZXJ2ZXIgZXZlcnkgYHRoaXMucGluZ0ludGVydmFsYCBhbmQgZXhwZWN0cyByZXNwb25zZVxuXHQgKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5zZXRQaW5nID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICBjbGVhclRpbWVvdXQoc2VsZi5waW5nSW50ZXJ2YWxUaW1lcik7XG5cdCAgc2VsZi5waW5nSW50ZXJ2YWxUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdGRlYnVnKCd3cml0aW5nIHBpbmcgcGFja2V0IC0gZXhwZWN0aW5nIHBvbmcgd2l0aGluICVzbXMnLCBzZWxmLnBpbmdUaW1lb3V0KTtcblx0XHRzZWxmLnBpbmcoKTtcblx0XHRzZWxmLm9uSGVhcnRiZWF0KHNlbGYucGluZ1RpbWVvdXQpO1xuXHQgIH0sIHNlbGYucGluZ0ludGVydmFsKTtcblx0fTtcblxuXHQvKipcblx0KiBTZW5kcyBhIHBpbmcgcGFja2V0LlxuXHQqXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cblx0U29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB0aGlzLnNlbmRQYWNrZXQoJ3BpbmcnLCBmdW5jdGlvbigpe1xuXHRcdHNlbGYuZW1pdCgncGluZycpO1xuXHQgIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgb24gYGRyYWluYCBldmVudFxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbkRyYWluID0gZnVuY3Rpb24oKSB7XG5cdCAgdGhpcy53cml0ZUJ1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcblxuXHQgIC8vIHNldHRpbmcgcHJldkJ1ZmZlckxlbiA9IDAgaXMgdmVyeSBpbXBvcnRhbnRcblx0ICAvLyBmb3IgZXhhbXBsZSwgd2hlbiB1cGdyYWRpbmcsIHVwZ3JhZGUgcGFja2V0IGlzIHNlbnQgb3Zlcixcblx0ICAvLyBhbmQgYSBub256ZXJvIHByZXZCdWZmZXJMZW4gY291bGQgY2F1c2UgcHJvYmxlbXMgb24gYGRyYWluYFxuXHQgIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG5cblx0ICBpZiAoMCA9PT0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcblx0XHR0aGlzLmVtaXQoJ2RyYWluJyk7XG5cdCAgfSBlbHNlIHtcblx0XHR0aGlzLmZsdXNoKCk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBGbHVzaCB3cml0ZSBidWZmZXJzLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAoJ2Nsb3NlZCcgIT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmXG5cdFx0IXRoaXMudXBncmFkaW5nICYmIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG5cdFx0ZGVidWcoJ2ZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0JywgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO1xuXHRcdHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy53cml0ZUJ1ZmZlcik7XG5cdFx0Ly8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuXHRcdC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuXHRcdHRoaXMucHJldkJ1ZmZlckxlbiA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuXHRcdHRoaXMuZW1pdCgnZmx1c2gnKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFNlbmRzIGEgbWVzc2FnZS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cblx0ICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUud3JpdGUgPVxuXHRTb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobXNnLCBvcHRpb25zLCBmbikge1xuXHQgIHRoaXMuc2VuZFBhY2tldCgnbWVzc2FnZScsIG1zZywgb3B0aW9ucywgZm4pO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZW5kcyBhIHBhY2tldC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHBhY2tldCB0eXBlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEsIG9wdGlvbnMsIGZuKSB7XG5cdCAgaWYoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkge1xuXHRcdGZuID0gZGF0YTtcblx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHQgIH1cblxuXHQgIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBvcHRpb25zKSB7XG5cdFx0Zm4gPSBvcHRpb25zO1xuXHRcdG9wdGlvbnMgPSBudWxsO1xuXHQgIH1cblxuXHQgIGlmICgnY2xvc2luZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHRcdHJldHVybjtcblx0ICB9XG5cblx0ICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0ICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cblx0ICB2YXIgcGFja2V0ID0ge1xuXHRcdHR5cGU6IHR5cGUsXG5cdFx0ZGF0YTogZGF0YSxcblx0XHRvcHRpb25zOiBvcHRpb25zXG5cdCAgfTtcblx0ICB0aGlzLmVtaXQoJ3BhY2tldENyZWF0ZScsIHBhY2tldCk7XG5cdCAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7XG5cdCAgaWYgKGZuKSB0aGlzLm9uY2UoJ2ZsdXNoJywgZm4pO1xuXHQgIHRoaXMuZmx1c2goKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdFx0dGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NpbmcnO1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG5cdFx0ICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy51cGdyYWRpbmcpIHtcblx0XHRcdCAgd2FpdEZvclVwZ3JhZGUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHQgIGNsb3NlKCk7XG5cdFx0XHR9XG5cdFx0ICB9KTtcblx0XHR9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG5cdFx0ICB3YWl0Rm9yVXBncmFkZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0ICBjbG9zZSgpO1xuXHRcdH1cblx0ICB9XG5cblx0ICBmdW5jdGlvbiBjbG9zZSgpIHtcblx0XHRzZWxmLm9uQ2xvc2UoJ2ZvcmNlZCBjbG9zZScpO1xuXHRcdGRlYnVnKCdzb2NrZXQgY2xvc2luZyAtIHRlbGxpbmcgdHJhbnNwb3J0IHRvIGNsb3NlJyk7XG5cdFx0c2VsZi50cmFuc3BvcnQuY2xvc2UoKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBjbGVhbnVwQW5kQ2xvc2UoKSB7XG5cdFx0c2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG5cdFx0c2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcblx0XHRjbG9zZSgpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHdhaXRGb3JVcGdyYWRlKCkge1xuXHRcdC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG5cdFx0c2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcblx0XHRzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBlcnJvclxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuXHQgIGRlYnVnKCdzb2NrZXQgZXJyb3IgJWonLCBlcnIpO1xuXHQgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblx0ICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0ICB0aGlzLm9uQ2xvc2UoJ3RyYW5zcG9ydCBlcnJvcicsIGVycik7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjbG9zZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24sIGRlc2MpIHtcblx0ICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0XHRkZWJ1Zygnc29ja2V0IGNsb3NlIHdpdGggcmVhc29uOiBcIiVzXCInLCByZWFzb24pO1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdC8vIGNsZWFyIHRpbWVyc1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblxuXHRcdC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuXHRcdHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcblxuXHRcdC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG5cdFx0dGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcblxuXHRcdC8vIGlnbm9yZSBmdXJ0aGVyIHRyYW5zcG9ydCBjb21tdW5pY2F0aW9uXG5cdFx0dGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cblx0XHQvLyBzZXQgcmVhZHkgc3RhdGVcblx0XHR0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblxuXHRcdC8vIGNsZWFyIHNlc3Npb24gaWRcblx0XHR0aGlzLmlkID0gbnVsbDtcblxuXHRcdC8vIGVtaXQgY2xvc2UgZXZlbnRcblx0XHR0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uLCBkZXNjKTtcblxuXHRcdC8vIGNsZWFuIGJ1ZmZlcnMgYWZ0ZXIsIHNvIHVzZXJzIGNhbiBzdGlsbFxuXHRcdC8vIGdyYWIgdGhlIGJ1ZmZlcnMgb24gYGNsb3NlYCBldmVudFxuXHRcdHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcblx0XHRzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogRmlsdGVycyB1cGdyYWRlcywgcmV0dXJuaW5nIG9ubHkgdGhvc2UgbWF0Y2hpbmcgY2xpZW50IHRyYW5zcG9ydHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICpcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5maWx0ZXJVcGdyYWRlcyA9IGZ1bmN0aW9uICh1cGdyYWRlcykge1xuXHQgIHZhciBmaWx0ZXJlZFVwZ3JhZGVzID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGk8ajsgaSsrKSB7XG5cdFx0aWYgKH5pbmRleCh0aGlzLnRyYW5zcG9ydHMsIHVwZ3JhZGVzW2ldKSkgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcblx0ICB9XG5cdCAgcmV0dXJuIGZpbHRlcmVkVXBncmFkZXM7XG5cdH07XG5cblx0fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG5cdH0se1wiLi90cmFuc3BvcnRcIjo0LFwiLi90cmFuc3BvcnRzXCI6NSxcImNvbXBvbmVudC1lbWl0dGVyXCI6MTUsXCJkZWJ1Z1wiOjE3LFwiZW5naW5lLmlvLXBhcnNlclwiOjE5LFwiaW5kZXhvZlwiOjIzLFwicGFyc2Vqc29uXCI6MjYsXCJwYXJzZXFzXCI6MjcsXCJwYXJzZXVyaVwiOjI4fV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblxuXHR2YXIgcGFyc2VyID0gX2RlcmVxXygnZW5naW5lLmlvLXBhcnNlcicpO1xuXHR2YXIgRW1pdHRlciA9IF9kZXJlcV8oJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydDtcblxuXHQvKipcblx0ICogVHJhbnNwb3J0IGFic3RyYWN0IGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFRyYW5zcG9ydCAob3B0cykge1xuXHQgIHRoaXMucGF0aCA9IG9wdHMucGF0aDtcblx0ICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZTtcblx0ICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQ7XG5cdCAgdGhpcy5zZWN1cmUgPSBvcHRzLnNlY3VyZTtcblx0ICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcblx0ICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbTtcblx0ICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcblx0ICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcblx0ICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuXHQgIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuXHQgIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIHRoaXMucGZ4ID0gb3B0cy5wZng7XG5cdCAgdGhpcy5rZXkgPSBvcHRzLmtleTtcblx0ICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG5cdCAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuXHQgIHRoaXMuY2EgPSBvcHRzLmNhO1xuXHQgIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcblx0ICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG5cdCAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1peCBpbiBgRW1pdHRlcmAuXG5cdCAqL1xuXG5cdEVtaXR0ZXIoVHJhbnNwb3J0LnByb3RvdHlwZSk7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGFuIGVycm9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdCAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChtc2csIGRlc2MpIHtcblx0ICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG5cdCAgZXJyLnR5cGUgPSAnVHJhbnNwb3J0RXJyb3InO1xuXHQgIGVyci5kZXNjcmlwdGlvbiA9IGRlc2M7XG5cdCAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIE9wZW5zIHRoZSB0cmFuc3BvcnQuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAoJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICcnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHRcdHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblx0XHR0aGlzLmRvT3BlbigpO1xuXHQgIH1cblxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHRcdHRoaXMuZG9DbG9zZSgpO1xuXHRcdHRoaXMub25DbG9zZSgpO1xuXHQgIH1cblxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZW5kcyBtdWx0aXBsZSBwYWNrZXRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihwYWNrZXRzKXtcblx0ICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHRcdHRoaXMud3JpdGUocGFja2V0cyk7XG5cdCAgfSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBub3Qgb3BlbicpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gb3BlblxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuXHQgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXHQgIHRoaXMuZW1pdCgnb3BlbicpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2l0aCBkYXRhLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcblx0ICB2YXIgcGFja2V0ID0gcGFyc2VyLmRlY29kZVBhY2tldChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKTtcblx0ICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aXRoIGEgZGVjb2RlZCBwYWNrZXQuXG5cdCAqL1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG5cdCAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBjbG9zZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblx0ICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG5cdH07XG5cblx0fSx7XCJjb21wb25lbnQtZW1pdHRlclwiOjE1LFwiZW5naW5lLmlvLXBhcnNlclwiOjE5fV0sNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdChmdW5jdGlvbiAoZ2xvYmFsKXtcblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcblx0ICovXG5cblx0dmFyIFhNTEh0dHBSZXF1ZXN0ID0gX2RlcmVxXygneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG5cdHZhciBYSFIgPSBfZGVyZXFfKCcuL3BvbGxpbmcteGhyJyk7XG5cdHZhciBKU09OUCA9IF9kZXJlcV8oJy4vcG9sbGluZy1qc29ucCcpO1xuXHR2YXIgd2Vic29ja2V0ID0gX2RlcmVxXygnLi93ZWJzb2NrZXQnKTtcblxuXHQvKipcblx0ICogRXhwb3J0IHRyYW5zcG9ydHMuXG5cdCAqL1xuXG5cdGV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5cdGV4cG9ydHMud2Vic29ja2V0ID0gd2Vic29ja2V0O1xuXG5cdC8qKlxuXHQgKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cblx0ICogRGVjaWRlcyBvbiB4aHIgdnMganNvbnAgYmFzZWQgb24gZmVhdHVyZSBkZXRlY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBwb2xsaW5nKG9wdHMpe1xuXHQgIHZhciB4aHI7XG5cdCAgdmFyIHhkID0gZmFsc2U7XG5cdCAgdmFyIHhzID0gZmFsc2U7XG5cdCAgdmFyIGpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG5cblx0ICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG5cdFx0dmFyIGlzU1NMID0gJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2w7XG5cdFx0dmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG5cdFx0Ly8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuXHRcdGlmICghcG9ydCkge1xuXHRcdCAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG5cdFx0fVxuXG5cdFx0eGQgPSBvcHRzLmhvc3RuYW1lICE9IGxvY2F0aW9uLmhvc3RuYW1lIHx8IHBvcnQgIT0gb3B0cy5wb3J0O1xuXHRcdHhzID0gb3B0cy5zZWN1cmUgIT0gaXNTU0w7XG5cdCAgfVxuXG5cdCAgb3B0cy54ZG9tYWluID0geGQ7XG5cdCAgb3B0cy54c2NoZW1lID0geHM7XG5cdCAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXG5cdCAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuXHRcdHJldHVybiBuZXcgWEhSKG9wdHMpO1xuXHQgIH0gZWxzZSB7XG5cdFx0aWYgKCFqc29ucCkgdGhyb3cgbmV3IEVycm9yKCdKU09OUCBkaXNhYmxlZCcpO1xuXHRcdHJldHVybiBuZXcgSlNPTlAob3B0cyk7XG5cdCAgfVxuXHR9XG5cblx0fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG5cdH0se1wiLi9wb2xsaW5nLWpzb25wXCI6NixcIi4vcG9sbGluZy14aHJcIjo3LFwiLi93ZWJzb2NrZXRcIjo5LFwieG1saHR0cHJlcXVlc3Qtc3NsXCI6MTB9XSw2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblx0KGZ1bmN0aW9uIChnbG9iYWwpe1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuXHQgKi9cblxuXHR2YXIgUG9sbGluZyA9IF9kZXJlcV8oJy4vcG9sbGluZycpO1xuXHR2YXIgaW5oZXJpdCA9IF9kZXJlcV8oJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblxuXHQvKipcblx0ICogQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG5cdCAqL1xuXG5cdHZhciByTmV3bGluZSA9IC9cXG4vZztcblx0dmFyIHJFc2NhcGVkTmV3bGluZSA9IC9cXFxcbi9nO1xuXG5cdC8qKlxuXHQgKiBHbG9iYWwgSlNPTlAgY2FsbGJhY2tzLlxuXHQgKi9cblxuXHR2YXIgY2FsbGJhY2tzO1xuXG5cdC8qKlxuXHQgKiBDYWxsYmFja3MgY291bnQuXG5cdCAqL1xuXG5cdHZhciBpbmRleCA9IDA7XG5cblx0LyoqXG5cdCAqIE5vb3AuXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGVtcHR5ICgpIHsgfVxuXG5cdC8qKlxuXHQgKiBKU09OUCBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gSlNPTlBQb2xsaW5nIChvcHRzKSB7XG5cdCAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuXG5cdCAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cblx0ICAvLyBkZWZpbmUgZ2xvYmFsIGNhbGxiYWNrcyBhcnJheSBpZiBub3QgcHJlc2VudFxuXHQgIC8vIHdlIGRvIHRoaXMgaGVyZSAobGF6aWx5KSB0byBhdm9pZCB1bm5lZWRlZCBnbG9iYWwgcG9sbHV0aW9uXG5cdCAgaWYgKCFjYWxsYmFja3MpIHtcblx0XHQvLyB3ZSBuZWVkIHRvIGNvbnNpZGVyIG11bHRpcGxlIGVuZ2luZXMgaW4gdGhlIHNhbWUgcGFnZVxuXHRcdGlmICghZ2xvYmFsLl9fX2VpbykgZ2xvYmFsLl9fX2VpbyA9IFtdO1xuXHRcdGNhbGxiYWNrcyA9IGdsb2JhbC5fX19laW87XG5cdCAgfVxuXG5cdCAgLy8gY2FsbGJhY2sgaWRlbnRpZmllclxuXHQgIHRoaXMuaW5kZXggPSBjYWxsYmFja3MubGVuZ3RoO1xuXG5cdCAgLy8gYWRkIGNhbGxiYWNrIHRvIGpzb25wIGdsb2JhbFxuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAobXNnKSB7XG5cdFx0c2VsZi5vbkRhdGEobXNnKTtcblx0ICB9KTtcblxuXHQgIC8vIGFwcGVuZCB0byBxdWVyeSBzdHJpbmdcblx0ICB0aGlzLnF1ZXJ5LmogPSB0aGlzLmluZGV4O1xuXG5cdCAgLy8gcHJldmVudCBzcHVyaW91cyBlcnJvcnMgZnJvbSBiZWluZyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBpcyB1bmxvYWRlZFxuXHQgIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHRnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuXHRcdCAgaWYgKHNlbGYuc2NyaXB0KSBzZWxmLnNjcmlwdC5vbmVycm9yID0gZW1wdHk7XG5cdFx0fSwgZmFsc2UpO1xuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG5cdCAqL1xuXG5cdGluaGVyaXQoSlNPTlBQb2xsaW5nLCBQb2xsaW5nKTtcblxuXHQvKlxuXHQgKiBKU09OUCBvbmx5IHN1cHBvcnRzIGJpbmFyeSBhcyBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG5cdCAqL1xuXG5cdEpTT05QUG9sbGluZy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblxuXHQvKipcblx0ICogQ2xvc2VzIHRoZSBzb2NrZXQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRKU09OUFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKHRoaXMuc2NyaXB0KSB7XG5cdFx0dGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG5cdFx0dGhpcy5zY3JpcHQgPSBudWxsO1xuXHQgIH1cblxuXHQgIGlmICh0aGlzLmZvcm0pIHtcblx0XHR0aGlzLmZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvcm0pO1xuXHRcdHRoaXMuZm9ybSA9IG51bGw7XG5cdFx0dGhpcy5pZnJhbWUgPSBudWxsO1xuXHQgIH1cblxuXHQgIFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UuY2FsbCh0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdEpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cblx0ICBpZiAodGhpcy5zY3JpcHQpIHtcblx0XHR0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcblx0XHR0aGlzLnNjcmlwdCA9IG51bGw7XG5cdCAgfVxuXG5cdCAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcblx0ICBzY3JpcHQuc3JjID0gdGhpcy51cmkoKTtcblx0ICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKGUpe1xuXHRcdHNlbGYub25FcnJvcignanNvbnAgcG9sbCBlcnJvcicsZSk7XG5cdCAgfTtcblxuXHQgIHZhciBpbnNlcnRBdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcblx0ICBpZiAoaW5zZXJ0QXQpIHtcblx0XHRpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIGluc2VydEF0KTtcblx0ICB9XG5cdCAgZWxzZSB7XG5cdFx0KGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0ICB9XG5cdCAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG5cblx0ICB2YXIgaXNVQWdlY2tvID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG5hdmlnYXRvciAmJiAvZ2Vja28vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXHQgIFxuXHQgIGlmIChpc1VBZ2Vja28pIHtcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHQgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcblx0XHQgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblx0XHQgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcblx0XHR9LCAxMDApO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogV3JpdGVzIHdpdGggYSBoaWRkZW4gaWZyYW1lLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0SlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgaWYgKCF0aGlzLmZvcm0pIHtcblx0XHR2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcblx0XHR2YXIgYXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG5cdFx0dmFyIGlkID0gdGhpcy5pZnJhbWVJZCA9ICdlaW9faWZyYW1lXycgKyB0aGlzLmluZGV4O1xuXHRcdHZhciBpZnJhbWU7XG5cblx0XHRmb3JtLmNsYXNzTmFtZSA9ICdzb2NrZXRpbyc7XG5cdFx0Zm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdFx0Zm9ybS5zdHlsZS50b3AgPSAnLTEwMDBweCc7XG5cdFx0Zm9ybS5zdHlsZS5sZWZ0ID0gJy0xMDAwcHgnO1xuXHRcdGZvcm0udGFyZ2V0ID0gaWQ7XG5cdFx0Zm9ybS5tZXRob2QgPSAnUE9TVCc7XG5cdFx0Zm9ybS5zZXRBdHRyaWJ1dGUoJ2FjY2VwdC1jaGFyc2V0JywgJ3V0Zi04Jyk7XG5cdFx0YXJlYS5uYW1lID0gJ2QnO1xuXHRcdGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG5cdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuXHRcdHRoaXMuZm9ybSA9IGZvcm07XG5cdFx0dGhpcy5hcmVhID0gYXJlYTtcblx0ICB9XG5cblx0ICB0aGlzLmZvcm0uYWN0aW9uID0gdGhpcy51cmkoKTtcblxuXHQgIGZ1bmN0aW9uIGNvbXBsZXRlICgpIHtcblx0XHRpbml0SWZyYW1lKCk7XG5cdFx0Zm4oKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBpbml0SWZyYW1lICgpIHtcblx0XHRpZiAoc2VsZi5pZnJhbWUpIHtcblx0XHQgIHRyeSB7XG5cdFx0XHRzZWxmLmZvcm0ucmVtb3ZlQ2hpbGQoc2VsZi5pZnJhbWUpO1xuXHRcdCAgfSBjYXRjaCAoZSkge1xuXHRcdFx0c2VsZi5vbkVycm9yKCdqc29ucCBwb2xsaW5nIGlmcmFtZSByZW1vdmFsIGVycm9yJywgZSk7XG5cdFx0ICB9XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHQgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuXHRcdCAgdmFyIGh0bWwgPSAnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiBuYW1lPVwiJysgc2VsZi5pZnJhbWVJZCArJ1wiPic7XG5cdFx0ICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHQgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXHRcdCAgaWZyYW1lLm5hbWUgPSBzZWxmLmlmcmFtZUlkO1xuXHRcdCAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0OjAnO1xuXHRcdH1cblxuXHRcdGlmcmFtZS5pZCA9IHNlbGYuaWZyYW1lSWQ7XG5cblx0XHRzZWxmLmZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblx0XHRzZWxmLmlmcmFtZSA9IGlmcmFtZTtcblx0ICB9XG5cblx0ICBpbml0SWZyYW1lKCk7XG5cblx0ICAvLyBlc2NhcGUgXFxuIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjb252ZXJ0ZWQgaW50byBcXHJcXG4gYnkgc29tZSBVQXNcblx0ICAvLyBkb3VibGUgZXNjYXBpbmcgaXMgcmVxdWlyZWQgZm9yIGVzY2FwZWQgbmV3IGxpbmVzIGJlY2F1c2UgdW5lc2NhcGluZyBvZiBuZXcgbGluZXMgY2FuIGJlIGRvbmUgc2FmZWx5IG9uIHNlcnZlci1zaWRlXG5cdCAgZGF0YSA9IGRhdGEucmVwbGFjZShyRXNjYXBlZE5ld2xpbmUsICdcXFxcXFxuJyk7XG5cdCAgdGhpcy5hcmVhLnZhbHVlID0gZGF0YS5yZXBsYWNlKHJOZXdsaW5lLCAnXFxcXG4nKTtcblxuXHQgIHRyeSB7XG5cdFx0dGhpcy5mb3JtLnN1Ym1pdCgpO1xuXHQgIH0gY2F0Y2goZSkge31cblxuXHQgIGlmICh0aGlzLmlmcmFtZS5hdHRhY2hFdmVudCkge1xuXHRcdHRoaXMuaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG5cdFx0ICBpZiAoc2VsZi5pZnJhbWUucmVhZHlTdGF0ZSA9PSAnY29tcGxldGUnKSB7XG5cdFx0XHRjb21wbGV0ZSgpO1xuXHRcdCAgfVxuXHRcdH07XG5cdCAgfSBlbHNlIHtcblx0XHR0aGlzLmlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZTtcblx0ICB9XG5cdH07XG5cblx0fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG5cdH0se1wiLi9wb2xsaW5nXCI6OCxcImNvbXBvbmVudC1pbmhlcml0XCI6MTZ9XSw3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblx0KGZ1bmN0aW9uIChnbG9iYWwpe1xuXHQvKipcblx0ICogTW9kdWxlIHJlcXVpcmVtZW50cy5cblx0ICovXG5cblx0dmFyIFhNTEh0dHBSZXF1ZXN0ID0gX2RlcmVxXygneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG5cdHZhciBQb2xsaW5nID0gX2RlcmVxXygnLi9wb2xsaW5nJyk7XG5cdHZhciBFbWl0dGVyID0gX2RlcmVxXygnY29tcG9uZW50LWVtaXR0ZXInKTtcblx0dmFyIGluaGVyaXQgPSBfZGVyZXFfKCdjb21wb25lbnQtaW5oZXJpdCcpO1xuXHR2YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcteGhyJyk7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IFhIUjtcblx0bW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cblx0LyoqXG5cdCAqIEVtcHR5IGZ1bmN0aW9uXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGVtcHR5KCl7fVxuXG5cdC8qKlxuXHQgKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdHNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gWEhSKG9wdHMpe1xuXHQgIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuXHQgIGlmIChnbG9iYWwubG9jYXRpb24pIHtcblx0XHR2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbDtcblx0XHR2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cblx0XHQvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG5cdFx0aWYgKCFwb3J0KSB7XG5cdFx0ICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcblx0XHR9XG5cblx0XHR0aGlzLnhkID0gb3B0cy5ob3N0bmFtZSAhPSBnbG9iYWwubG9jYXRpb24uaG9zdG5hbWUgfHxcblx0XHQgIHBvcnQgIT0gb3B0cy5wb3J0O1xuXHRcdHRoaXMueHMgPSBvcHRzLnNlY3VyZSAhPSBpc1NTTDtcblx0ICB9IGVsc2Uge1xuXHRcdHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cblx0ICovXG5cblx0aW5oZXJpdChYSFIsIFBvbGxpbmcpO1xuXG5cdC8qKlxuXHQgKiBYSFIgc3VwcG9ydHMgYmluYXJ5XG5cdCAqL1xuXG5cdFhIUi5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgcmVxdWVzdC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0WEhSLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24ob3B0cyl7XG5cdCAgb3B0cyA9IG9wdHMgfHwge307XG5cdCAgb3B0cy51cmkgPSB0aGlzLnVyaSgpO1xuXHQgIG9wdHMueGQgPSB0aGlzLnhkO1xuXHQgIG9wdHMueHMgPSB0aGlzLnhzO1xuXHQgIG9wdHMuYWdlbnQgPSB0aGlzLmFnZW50IHx8IGZhbHNlO1xuXHQgIG9wdHMuc3VwcG9ydHNCaW5hcnkgPSB0aGlzLnN1cHBvcnRzQmluYXJ5O1xuXHQgIG9wdHMuZW5hYmxlc1hEUiA9IHRoaXMuZW5hYmxlc1hEUjtcblxuXHQgIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIG9wdHMucGZ4ID0gdGhpcy5wZng7XG5cdCAgb3B0cy5rZXkgPSB0aGlzLmtleTtcblx0ICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG5cdCAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuXHQgIG9wdHMuY2EgPSB0aGlzLmNhO1xuXHQgIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcblx0ICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG5cdCAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICBvcHRzLmV4dHJhSGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuXG5cdCAgcmV0dXJuIG5ldyBSZXF1ZXN0KG9wdHMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZW5kcyBkYXRhLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFhIUi5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uKGRhdGEsIGZuKXtcblx0ICB2YXIgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgZGF0YSAhPT0gdW5kZWZpbmVkO1xuXHQgIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdQT1NUJywgZGF0YTogZGF0YSwgaXNCaW5hcnk6IGlzQmluYXJ5IH0pO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICByZXEub24oJ3N1Y2Nlc3MnLCBmbik7XG5cdCAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycil7XG5cdFx0c2VsZi5vbkVycm9yKCd4aHIgcG9zdCBlcnJvcicsIGVycik7XG5cdCAgfSk7XG5cdCAgdGhpcy5zZW5kWGhyID0gcmVxO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0WEhSLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbigpe1xuXHQgIGRlYnVnKCd4aHIgcG9sbCcpO1xuXHQgIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoKTtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgcmVxLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSl7XG5cdFx0c2VsZi5vbkRhdGEoZGF0YSk7XG5cdCAgfSk7XG5cdCAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycil7XG5cdFx0c2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG5cdCAgfSk7XG5cdCAgdGhpcy5wb2xsWGhyID0gcmVxO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFJlcXVlc3Qob3B0cyl7XG5cdCAgdGhpcy5tZXRob2QgPSBvcHRzLm1ldGhvZCB8fCAnR0VUJztcblx0ICB0aGlzLnVyaSA9IG9wdHMudXJpO1xuXHQgIHRoaXMueGQgPSAhIW9wdHMueGQ7XG5cdCAgdGhpcy54cyA9ICEhb3B0cy54cztcblx0ICB0aGlzLmFzeW5jID0gZmFsc2UgIT09IG9wdHMuYXN5bmM7XG5cdCAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9IG9wdHMuZGF0YSA/IG9wdHMuZGF0YSA6IG51bGw7XG5cdCAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQ7XG5cdCAgdGhpcy5pc0JpbmFyeSA9IG9wdHMuaXNCaW5hcnk7XG5cdCAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IG9wdHMuc3VwcG9ydHNCaW5hcnk7XG5cdCAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG5cdCAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdGhpcy5wZnggPSBvcHRzLnBmeDtcblx0ICB0aGlzLmtleSA9IG9wdHMua2V5O1xuXHQgIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcblx0ICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG5cdCAgdGhpcy5jYSA9IG9wdHMuY2E7XG5cdCAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuXHQgIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cblx0ICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cblx0ICB0aGlzLmNyZWF0ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1peCBpbiBgRW1pdHRlcmAuXG5cdCAqL1xuXG5cdEVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKCl7XG5cdCAgdmFyIG9wdHMgPSB7IGFnZW50OiB0aGlzLmFnZW50LCB4ZG9tYWluOiB0aGlzLnhkLCB4c2NoZW1lOiB0aGlzLnhzLCBlbmFibGVzWERSOiB0aGlzLmVuYWJsZXNYRFIgfTtcblxuXHQgIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIG9wdHMucGZ4ID0gdGhpcy5wZng7XG5cdCAgb3B0cy5rZXkgPSB0aGlzLmtleTtcblx0ICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG5cdCAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuXHQgIG9wdHMuY2EgPSB0aGlzLmNhO1xuXHQgIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcblx0ICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG5cdCAgdmFyIHhociA9IHRoaXMueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblxuXHQgIHRyeSB7XG5cdFx0ZGVidWcoJ3hociBvcGVuICVzOiAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVyaSk7XG5cdFx0eGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcblx0XHR0cnkge1xuXHRcdCAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG5cdFx0XHR4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrKHRydWUpO1xuXHRcdFx0Zm9yICh2YXIgaSBpbiB0aGlzLmV4dHJhSGVhZGVycykge1xuXHRcdFx0ICBpZiAodGhpcy5leHRyYUhlYWRlcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoaSwgdGhpcy5leHRyYUhlYWRlcnNbaV0pO1xuXHRcdFx0ICB9XG5cdFx0XHR9XG5cdFx0ICB9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0XHRpZiAodGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuXHRcdCAgLy8gVGhpcyBoYXMgdG8gYmUgZG9uZSBhZnRlciBvcGVuIGJlY2F1c2UgRmlyZWZveCBpcyBzdHVwaWRcblx0XHQgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMyMTY5MDMvZ2V0LWJpbmFyeS1kYXRhLXdpdGgteG1saHR0cHJlcXVlc3QtaW4tYS1maXJlZm94LWV4dGVuc2lvblxuXHRcdCAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdFx0fVxuXG5cdFx0aWYgKCdQT1NUJyA9PSB0aGlzLm1ldGhvZCkge1xuXHRcdCAgdHJ5IHtcblx0XHRcdGlmICh0aGlzLmlzQmluYXJ5KSB7XG5cdFx0XHQgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0ICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuXHRcdFx0fVxuXHRcdCAgfSBjYXRjaCAoZSkge31cblx0XHR9XG5cblx0XHQvLyBpZTYgY2hlY2tcblx0XHRpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG5cdFx0ICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5oYXNYRFIoKSkge1xuXHRcdCAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRzZWxmLm9uTG9hZCgpO1xuXHRcdCAgfTtcblx0XHQgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKXtcblx0XHRcdHNlbGYub25FcnJvcih4aHIucmVzcG9uc2VUZXh0KTtcblx0XHQgIH07XG5cdFx0fSBlbHNlIHtcblx0XHQgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xuXHRcdFx0aWYgKDQgIT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcblx0XHRcdGlmICgyMDAgPT0geGhyLnN0YXR1cyB8fCAxMjIzID09IHhoci5zdGF0dXMpIHtcblx0XHRcdCAgc2VsZi5vbkxvYWQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHQgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuXHRcdFx0ICAvLyBkb2VzIG5vdCB0aHJvdyBpbiB0aGUgc2FtZSB0aWNrIGFuZCBnZXRzIGNhdWdodCBoZXJlXG5cdFx0XHQgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0XHRcdFx0c2VsZi5vbkVycm9yKHhoci5zdGF0dXMpO1xuXHRcdFx0ICB9LCAwKTtcblx0XHRcdH1cblx0XHQgIH07XG5cdFx0fVxuXG5cdFx0ZGVidWcoJ3hociBkYXRhICVzJywgdGhpcy5kYXRhKTtcblx0XHR4aHIuc2VuZCh0aGlzLmRhdGEpO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBOZWVkIHRvIGRlZmVyIHNpbmNlIC5jcmVhdGUoKSBpcyBjYWxsZWQgZGlyZWN0bHkgZmhyb20gdGhlIGNvbnN0cnVjdG9yXG5cdFx0Ly8gYW5kIHRodXMgdGhlICdlcnJvcicgZXZlbnQgY2FuIG9ubHkgYmUgb25seSBib3VuZCAqYWZ0ZXIqIHRoaXMgZXhjZXB0aW9uXG5cdFx0Ly8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG5cdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHQgIHNlbGYub25FcnJvcihlKTtcblx0XHR9LCAwKTtcblx0XHRyZXR1cm47XG5cdCAgfVxuXG5cdCAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuXHRcdHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcblx0XHRSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRSZXF1ZXN0LnByb3RvdHlwZS5vblN1Y2Nlc3MgPSBmdW5jdGlvbigpe1xuXHQgIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuXHQgIHRoaXMuY2xlYW51cCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgaWYgd2UgaGF2ZSBkYXRhLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UmVxdWVzdC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG5cdCAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG5cdCAgdGhpcy5vblN1Y2Nlc3MoKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gZXJyb3IuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRSZXF1ZXN0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24oZXJyKXtcblx0ICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0ICB0aGlzLmNsZWFudXAodHJ1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsZWFucyB1cCBob3VzZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbihmcm9tRXJyb3Ipe1xuXHQgIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YgdGhpcy54aHIgfHwgbnVsbCA9PT0gdGhpcy54aHIpIHtcblx0XHRyZXR1cm47XG5cdCAgfVxuXHQgIC8vIHhtbGh0dHByZXF1ZXN0XG5cdCAgaWYgKHRoaXMuaGFzWERSKCkpIHtcblx0XHR0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG5cdCAgfSBlbHNlIHtcblx0XHR0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eTtcblx0ICB9XG5cblx0ICBpZiAoZnJvbUVycm9yKSB7XG5cdFx0dHJ5IHtcblx0XHQgIHRoaXMueGhyLmFib3J0KCk7XG5cdFx0fSBjYXRjaChlKSB7fVxuXHQgIH1cblxuXHQgIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcblx0XHRkZWxldGUgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XTtcblx0ICB9XG5cblx0ICB0aGlzLnhociA9IG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGxvYWQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRSZXF1ZXN0LnByb3RvdHlwZS5vbkxvYWQgPSBmdW5jdGlvbigpe1xuXHQgIHZhciBkYXRhO1xuXHQgIHRyeSB7XG5cdFx0dmFyIGNvbnRlbnRUeXBlO1xuXHRcdHRyeSB7XG5cdFx0ICBjb250ZW50VHlwZSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKS5zcGxpdCgnOycpWzBdO1xuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0aWYgKGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuXHRcdCAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0ICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcblx0XHRcdGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG5cdFx0ICB9IGVsc2Uge1xuXHRcdFx0dHJ5IHtcblx0XHRcdCAgZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkodGhpcy54aHIucmVzcG9uc2UpKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdCAgdmFyIHVpOEFyciA9IG5ldyBVaW50OEFycmF5KHRoaXMueGhyLnJlc3BvbnNlKTtcblx0XHRcdCAgdmFyIGRhdGFBcnJheSA9IFtdO1xuXHRcdFx0ICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSB1aThBcnIubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdFx0XHRcdGRhdGFBcnJheS5wdXNoKHVpOEFycltpZHhdKTtcblx0XHRcdCAgfVxuXG5cdFx0XHQgIGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGRhdGFBcnJheSk7XG5cdFx0XHR9XG5cdFx0ICB9XG5cdFx0fVxuXHQgIH0gY2F0Y2ggKGUpIHtcblx0XHR0aGlzLm9uRXJyb3IoZSk7XG5cdCAgfVxuXHQgIGlmIChudWxsICE9IGRhdGEpIHtcblx0XHR0aGlzLm9uRGF0YShkYXRhKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIGl0IGhhcyBYRG9tYWluUmVxdWVzdC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLmhhc1hEUiA9IGZ1bmN0aW9uKCl7XG5cdCAgcmV0dXJuICd1bmRlZmluZWQnICE9PSB0eXBlb2YgZ2xvYmFsLlhEb21haW5SZXF1ZXN0ICYmICF0aGlzLnhzICYmIHRoaXMuZW5hYmxlc1hEUjtcblx0fTtcblxuXHQvKipcblx0ICogQWJvcnRzIHRoZSByZXF1ZXN0LlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRSZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCl7XG5cdCAgdGhpcy5jbGVhbnVwKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFib3J0cyBwZW5kaW5nIHJlcXVlc3RzIHdoZW4gdW5sb2FkaW5nIHRoZSB3aW5kb3cuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnRcblx0ICogbWVtb3J5IGxlYWtzIChlLmcuIHdoZW4gdXNpbmcgSUUpIGFuZCB0byBlbnN1cmUgdGhhdCBubyBzcHVyaW91cyBlcnJvciBpc1xuXHQgKiBlbWl0dGVkLlxuXHQgKi9cblxuXHRpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG5cdCAgUmVxdWVzdC5yZXF1ZXN0c0NvdW50ID0gMDtcblx0ICBSZXF1ZXN0LnJlcXVlc3RzID0ge307XG5cdCAgaWYgKGdsb2JhbC5hdHRhY2hFdmVudCkge1xuXHRcdGdsb2JhbC5hdHRhY2hFdmVudCgnb251bmxvYWQnLCB1bmxvYWRIYW5kbGVyKTtcblx0ICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0Z2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiB1bmxvYWRIYW5kbGVyKCkge1xuXHQgIGZvciAodmFyIGkgaW4gUmVxdWVzdC5yZXF1ZXN0cykge1xuXHRcdGlmIChSZXF1ZXN0LnJlcXVlc3RzLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0ICBSZXF1ZXN0LnJlcXVlc3RzW2ldLmFib3J0KCk7XG5cdFx0fVxuXHQgIH1cblx0fVxuXG5cdH0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxuXHR9LHtcIi4vcG9sbGluZ1wiOjgsXCJjb21wb25lbnQtZW1pdHRlclwiOjE1LFwiY29tcG9uZW50LWluaGVyaXRcIjoxNixcImRlYnVnXCI6MTcsXCJ4bWxodHRwcmVxdWVzdC1zc2xcIjoxMH1dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cblx0dmFyIFRyYW5zcG9ydCA9IF9kZXJlcV8oJy4uL3RyYW5zcG9ydCcpO1xuXHR2YXIgcGFyc2VxcyA9IF9kZXJlcV8oJ3BhcnNlcXMnKTtcblx0dmFyIHBhcnNlciA9IF9kZXJlcV8oJ2VuZ2luZS5pby1wYXJzZXInKTtcblx0dmFyIGluaGVyaXQgPSBfZGVyZXFfKCdjb21wb25lbnQtaW5oZXJpdCcpO1xuXHR2YXIgeWVhc3QgPSBfZGVyZXFfKCd5ZWFzdCcpO1xuXHR2YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcnKTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxuXHQvKipcblx0ICogSXMgWEhSMiBzdXBwb3J0ZWQ/XG5cdCAqL1xuXG5cdHZhciBoYXNYSFIyID0gKGZ1bmN0aW9uKCkge1xuXHQgIHZhciBYTUxIdHRwUmVxdWVzdCA9IF9kZXJlcV8oJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xuXHQgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoeyB4ZG9tYWluOiBmYWxzZSB9KTtcblx0ICByZXR1cm4gbnVsbCAhPSB4aHIucmVzcG9uc2VUeXBlO1xuXHR9KSgpO1xuXG5cdC8qKlxuXHQgKiBQb2xsaW5nIGludGVyZmFjZS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdHNcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFBvbGxpbmcob3B0cyl7XG5cdCAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG5cdCAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG5cdFx0dGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXHQgIH1cblx0ICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cblx0ICovXG5cblx0aW5oZXJpdChQb2xsaW5nLCBUcmFuc3BvcnQpO1xuXG5cdC8qKlxuXHQgKiBUcmFuc3BvcnQgbmFtZS5cblx0ICovXG5cblx0UG9sbGluZy5wcm90b3R5cGUubmFtZSA9ICdwb2xsaW5nJztcblxuXHQvKipcblx0ICogT3BlbnMgdGhlIHNvY2tldCAodHJpZ2dlcnMgcG9sbGluZykuIFdlIHdyaXRlIGEgUElORyBtZXNzYWdlIHRvIGRldGVybWluZVxuXHQgKiB3aGVuIHRoZSB0cmFuc3BvcnQgaXMgb3Blbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uKCl7XG5cdCAgdGhpcy5wb2xsKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhdXNlcyBwb2xsaW5nLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB1cG9uIGJ1ZmZlcnMgYXJlIGZsdXNoZWQgYW5kIHRyYW5zcG9ydCBpcyBwYXVzZWRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFBvbGxpbmcucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24ob25QYXVzZSl7XG5cdCAgdmFyIHBlbmRpbmcgPSAwO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblxuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdwYXVzaW5nJztcblxuXHQgIGZ1bmN0aW9uIHBhdXNlKCl7XG5cdFx0ZGVidWcoJ3BhdXNlZCcpO1xuXHRcdHNlbGYucmVhZHlTdGF0ZSA9ICdwYXVzZWQnO1xuXHRcdG9uUGF1c2UoKTtcblx0ICB9XG5cblx0ICBpZiAodGhpcy5wb2xsaW5nIHx8ICF0aGlzLndyaXRhYmxlKSB7XG5cdFx0dmFyIHRvdGFsID0gMDtcblxuXHRcdGlmICh0aGlzLnBvbGxpbmcpIHtcblx0XHQgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHBvbGxpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG5cdFx0ICB0b3RhbCsrO1xuXHRcdCAgdGhpcy5vbmNlKCdwb2xsQ29tcGxldGUnLCBmdW5jdGlvbigpe1xuXHRcdFx0ZGVidWcoJ3ByZS1wYXVzZSBwb2xsaW5nIGNvbXBsZXRlJyk7XG5cdFx0XHQtLXRvdGFsIHx8IHBhdXNlKCk7XG5cdFx0ICB9KTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMud3JpdGFibGUpIHtcblx0XHQgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHdyaXRpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG5cdFx0ICB0b3RhbCsrO1xuXHRcdCAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uKCl7XG5cdFx0XHRkZWJ1ZygncHJlLXBhdXNlIHdyaXRpbmcgY29tcGxldGUnKTtcblx0XHRcdC0tdG90YWwgfHwgcGF1c2UoKTtcblx0XHQgIH0pO1xuXHRcdH1cblx0ICB9IGVsc2Uge1xuXHRcdHBhdXNlKCk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdGFydHMgcG9sbGluZyBjeWNsZS5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0UG9sbGluZy5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uKCl7XG5cdCAgZGVidWcoJ3BvbGxpbmcnKTtcblx0ICB0aGlzLnBvbGxpbmcgPSB0cnVlO1xuXHQgIHRoaXMuZG9Qb2xsKCk7XG5cdCAgdGhpcy5lbWl0KCdwb2xsJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIE92ZXJsb2FkcyBvbkRhdGEgdG8gZGV0ZWN0IHBheWxvYWRzLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UG9sbGluZy5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIGRlYnVnKCdwb2xsaW5nIGdvdCBkYXRhICVzJywgZGF0YSk7XG5cdCAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24ocGFja2V0LCBpbmRleCwgdG90YWwpIHtcblx0XHQvLyBpZiBpdHMgdGhlIGZpcnN0IG1lc3NhZ2Ugd2UgY29uc2lkZXIgdGhlIHRyYW5zcG9ydCBvcGVuXG5cdFx0aWYgKCdvcGVuaW5nJyA9PSBzZWxmLnJlYWR5U3RhdGUpIHtcblx0XHQgIHNlbGYub25PcGVuKCk7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgaXRzIGEgY2xvc2UgcGFja2V0LCB3ZSBjbG9zZSB0aGUgb25nb2luZyByZXF1ZXN0c1xuXHRcdGlmICgnY2xvc2UnID09IHBhY2tldC50eXBlKSB7XG5cdFx0ICBzZWxmLm9uQ2xvc2UoKTtcblx0XHQgIHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBvdGhlcndpc2UgYnlwYXNzIG9uRGF0YSBhbmQgaGFuZGxlIHRoZSBtZXNzYWdlXG5cdFx0c2VsZi5vblBhY2tldChwYWNrZXQpO1xuXHQgIH07XG5cblx0ICAvLyBkZWNvZGUgcGF5bG9hZFxuXHQgIHBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcblxuXHQgIC8vIGlmIGFuIGV2ZW50IGRpZCBub3QgdHJpZ2dlciBjbG9zaW5nXG5cdCAgaWYgKCdjbG9zZWQnICE9IHRoaXMucmVhZHlTdGF0ZSkge1xuXHRcdC8vIGlmIHdlIGdvdCBkYXRhIHdlJ3JlIG5vdCBwb2xsaW5nXG5cdFx0dGhpcy5wb2xsaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5lbWl0KCdwb2xsQ29tcGxldGUnKTtcblxuXHRcdGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdFx0ICB0aGlzLnBvbGwoKTtcblx0XHR9IGVsc2Uge1xuXHRcdCAgZGVidWcoJ2lnbm9yaW5nIHBvbGwgLSB0cmFuc3BvcnQgc3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcblx0XHR9XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbigpe1xuXHQgIHZhciBzZWxmID0gdGhpcztcblxuXHQgIGZ1bmN0aW9uIGNsb3NlKCl7XG5cdFx0ZGVidWcoJ3dyaXRpbmcgY2xvc2UgcGFja2V0Jyk7XG5cdFx0c2VsZi53cml0ZShbeyB0eXBlOiAnY2xvc2UnIH1dKTtcblx0ICB9XG5cblx0ICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHRcdGRlYnVnKCd0cmFuc3BvcnQgb3BlbiAtIGNsb3NpbmcnKTtcblx0XHRjbG9zZSgpO1xuXHQgIH0gZWxzZSB7XG5cdFx0Ly8gaW4gY2FzZSB3ZSdyZSB0cnlpbmcgdG8gY2xvc2Ugd2hpbGVcblx0XHQvLyBoYW5kc2hha2luZyBpcyBpbiBwcm9ncmVzcyAoR0gtMTY0KVxuXHRcdGRlYnVnKCd0cmFuc3BvcnQgbm90IG9wZW4gLSBkZWZlcnJpbmcgY2xvc2UnKTtcblx0XHR0aGlzLm9uY2UoJ29wZW4nLCBjbG9zZSk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgcGFja2V0c1xuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UG9sbGluZy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihwYWNrZXRzKXtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXHQgIHZhciBjYWxsYmFja2ZuID0gZnVuY3Rpb24oKSB7XG5cdFx0c2VsZi53cml0YWJsZSA9IHRydWU7XG5cdFx0c2VsZi5lbWl0KCdkcmFpbicpO1xuXHQgIH07XG5cblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgcGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgdGhpcy5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24oZGF0YSkge1xuXHRcdHNlbGYuZG9Xcml0ZShkYXRhLCBjYWxsYmFja2ZuKTtcblx0ICB9KTtcblx0fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFBvbGxpbmcucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uKCl7XG5cdCAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblx0ICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnaHR0cHMnIDogJ2h0dHAnO1xuXHQgIHZhciBwb3J0ID0gJyc7XG5cblx0ICAvLyBjYWNoZSBidXN0aW5nIGlzIGZvcmNlZFxuXHQgIGlmIChmYWxzZSAhPT0gdGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuXHRcdHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcblx0ICB9XG5cblx0ICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgIXF1ZXJ5LnNpZCkge1xuXHRcdHF1ZXJ5LmI2NCA9IDE7XG5cdCAgfVxuXG5cdCAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cblx0ICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuXHQgIGlmICh0aGlzLnBvcnQgJiYgKCgnaHR0cHMnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gNDQzKSB8fFxuXHRcdCAoJ2h0dHAnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gODApKSkge1xuXHRcdHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG5cdCAgfVxuXG5cdCAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG5cdCAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuXHRcdHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG5cdCAgfVxuXG5cdCAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG5cdCAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG5cdH07XG5cblx0fSx7XCIuLi90cmFuc3BvcnRcIjo0LFwiY29tcG9uZW50LWluaGVyaXRcIjoxNixcImRlYnVnXCI6MTcsXCJlbmdpbmUuaW8tcGFyc2VyXCI6MTksXCJwYXJzZXFzXCI6MjcsXCJ4bWxodHRwcmVxdWVzdC1zc2xcIjoxMCxcInllYXN0XCI6MzB9XSw5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblx0KGZ1bmN0aW9uIChnbG9iYWwpe1xuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cblx0dmFyIFRyYW5zcG9ydCA9IF9kZXJlcV8oJy4uL3RyYW5zcG9ydCcpO1xuXHR2YXIgcGFyc2VyID0gX2RlcmVxXygnZW5naW5lLmlvLXBhcnNlcicpO1xuXHR2YXIgcGFyc2VxcyA9IF9kZXJlcV8oJ3BhcnNlcXMnKTtcblx0dmFyIGluaGVyaXQgPSBfZGVyZXFfKCdjb21wb25lbnQtaW5oZXJpdCcpO1xuXHR2YXIgeWVhc3QgPSBfZGVyZXFfKCd5ZWFzdCcpO1xuXHR2YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OndlYnNvY2tldCcpO1xuXHR2YXIgQnJvd3NlcldlYlNvY2tldCA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcblxuXHQvKipcblx0ICogR2V0IGVpdGhlciB0aGUgYFdlYlNvY2tldGAgb3IgYE1veldlYlNvY2tldGAgZ2xvYmFsc1xuXHQgKiBpbiB0aGUgYnJvd3NlciBvciB0cnkgdG8gcmVzb2x2ZSBXZWJTb2NrZXQtY29tcGF0aWJsZVxuXHQgKiBpbnRlcmZhY2UgZXhwb3NlZCBieSBgd3NgIGZvciBOb2RlLWxpa2UgZW52aXJvbm1lbnQuXG5cdCAqL1xuXG5cdHZhciBXZWJTb2NrZXQgPSBCcm93c2VyV2ViU29ja2V0O1xuXHRpZiAoIVdlYlNvY2tldCAmJiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuXHQgIHRyeSB7XG5cdFx0V2ViU29ja2V0ID0gX2RlcmVxXygnd3MnKTtcblx0ICB9IGNhdGNoIChlKSB7IH1cblx0fVxuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBXUztcblxuXHQvKipcblx0ICogV2ViU29ja2V0IHRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cblx0ICpcblx0ICogQGFwaSB7T2JqZWN0fSBjb25uZWN0aW9uIG9wdGlvbnNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gV1Mob3B0cyl7XG5cdCAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG5cdCAgaWYgKGZvcmNlQmFzZTY0KSB7XG5cdFx0dGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXHQgIH1cblx0ICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZTtcblx0ICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cblx0ICovXG5cblx0aW5oZXJpdChXUywgVHJhbnNwb3J0KTtcblxuXHQvKipcblx0ICogVHJhbnNwb3J0IG5hbWUuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFdTLnByb3RvdHlwZS5uYW1lID0gJ3dlYnNvY2tldCc7XG5cblx0Lypcblx0ICogV2ViU29ja2V0cyBzdXBwb3J0IGJpbmFyeVxuXHQgKi9cblxuXHRXUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBPcGVucyBzb2NrZXQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRXUy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24oKXtcblx0ICBpZiAoIXRoaXMuY2hlY2soKSkge1xuXHRcdC8vIGxldCBwcm9iZSB0aW1lb3V0XG5cdFx0cmV0dXJuO1xuXHQgIH1cblxuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB2YXIgdXJpID0gdGhpcy51cmkoKTtcblx0ICB2YXIgcHJvdG9jb2xzID0gdm9pZCgwKTtcblx0ICB2YXIgb3B0cyA9IHtcblx0XHRhZ2VudDogdGhpcy5hZ2VudCxcblx0XHRwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZVxuXHQgIH07XG5cblx0ICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuXHQgIG9wdHMua2V5ID0gdGhpcy5rZXk7XG5cdCAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuXHQgIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcblx0ICBvcHRzLmNhID0gdGhpcy5jYTtcblx0ICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG5cdCAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblx0ICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcblx0XHRvcHRzLmhlYWRlcnMgPSB0aGlzLmV4dHJhSGVhZGVycztcblx0ICB9XG5cblx0ICB0aGlzLndzID0gQnJvd3NlcldlYlNvY2tldCA/IG5ldyBXZWJTb2NrZXQodXJpKSA6IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuXG5cdCAgaWYgKHRoaXMud3MuYmluYXJ5VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXHQgIH1cblxuXHQgIGlmICh0aGlzLndzLnN1cHBvcnRzICYmIHRoaXMud3Muc3VwcG9ydHMuYmluYXJ5KSB7XG5cdFx0dGhpcy5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cdFx0dGhpcy53cy5iaW5hcnlUeXBlID0gJ2J1ZmZlcic7XG5cdCAgfSBlbHNlIHtcblx0XHR0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXHQgIH1cblxuXHQgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcblx0fTtcblxuXHQvKipcblx0ICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNvY2tldFxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0V1MucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24oKXtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cblx0ICB0aGlzLndzLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG5cdFx0c2VsZi5vbk9wZW4oKTtcblx0ICB9O1xuXHQgIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uKCl7XG5cdFx0c2VsZi5vbkNsb3NlKCk7XG5cdCAgfTtcblx0ICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2KXtcblx0XHRzZWxmLm9uRGF0YShldi5kYXRhKTtcblx0ICB9O1xuXHQgIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uKGUpe1xuXHRcdHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG5cdCAgfTtcblx0fTtcblxuXHQvKipcblx0ICogT3ZlcnJpZGUgYG9uRGF0YWAgdG8gdXNlIGEgdGltZXIgb24gaU9TLlxuXHQgKiBTZWU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21sb3VnaHJhbi8yMDUyMDA2XG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG5hdmlnYXRvclxuXHQgICYmIC9pUGFkfGlQaG9uZXxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuXHQgIFdTLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdCAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEuY2FsbChzZWxmLCBkYXRhKTtcblx0XHR9LCAwKTtcblx0ICB9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgcGFja2V0cy5cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFdTLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cblx0ICAvLyBlbmNvZGVQYWNrZXQgZWZmaWNpZW50IGFzIGl0IHVzZXMgV1MgZnJhbWluZ1xuXHQgIC8vIG5vIG5lZWQgZm9yIGVuY29kZVBheWxvYWRcblx0ICB2YXIgdG90YWwgPSBwYWNrZXRzLmxlbmd0aDtcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IHRvdGFsOyBpIDwgbDsgaSsrKSB7XG5cdFx0KGZ1bmN0aW9uKHBhY2tldCkge1xuXHRcdCAgcGFyc2VyLmVuY29kZVBhY2tldChwYWNrZXQsIHNlbGYuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdGlmICghQnJvd3NlcldlYlNvY2tldCkge1xuXHRcdFx0ICAvLyBhbHdheXMgY3JlYXRlIGEgbmV3IG9iamVjdCAoR0gtNDM3KVxuXHRcdFx0ICB2YXIgb3B0cyA9IHt9O1xuXHRcdFx0ICBpZiAocGFja2V0Lm9wdGlvbnMpIHtcblx0XHRcdFx0b3B0cy5jb21wcmVzcyA9IHBhY2tldC5vcHRpb25zLmNvbXByZXNzO1xuXHRcdFx0ICB9XG5cblx0XHRcdCAgaWYgKHNlbGYucGVyTWVzc2FnZURlZmxhdGUpIHtcblx0XHRcdFx0dmFyIGxlbiA9ICdzdHJpbmcnID09IHR5cGVvZiBkYXRhID8gZ2xvYmFsLkJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG5cdFx0XHRcdGlmIChsZW4gPCBzZWxmLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuXHRcdFx0XHQgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0ICB9XG5cdFx0XHR9XG5cblx0XHRcdC8vU29tZXRpbWVzIHRoZSB3ZWJzb2NrZXQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgYnV0IHRoZSBicm93c2VyIGRpZG4ndFxuXHRcdFx0Ly9oYXZlIGEgY2hhbmNlIG9mIGluZm9ybWluZyB1cyBhYm91dCBpdCB5ZXQsIGluIHRoYXQgY2FzZSBzZW5kIHdpbGxcblx0XHRcdC8vdGhyb3cgYW4gZXJyb3Jcblx0XHRcdHRyeSB7XG5cdFx0XHQgIGlmIChCcm93c2VyV2ViU29ja2V0KSB7XG5cdFx0XHRcdC8vIFR5cGVFcnJvciBpcyB0aHJvd24gd2hlbiBwYXNzaW5nIHRoZSBzZWNvbmQgYXJndW1lbnQgb24gU2FmYXJpXG5cdFx0XHRcdHNlbGYud3Muc2VuZChkYXRhKTtcblx0XHRcdCAgfSBlbHNlIHtcblx0XHRcdFx0c2VsZi53cy5zZW5kKGRhdGEsIG9wdHMpO1xuXHRcdFx0ICB9XG5cdFx0XHR9IGNhdGNoIChlKXtcblx0XHRcdCAgZGVidWcoJ3dlYnNvY2tldCBjbG9zZWQgYmVmb3JlIG9uY2xvc2UgZXZlbnQnKTtcblx0XHRcdH1cblxuXHRcdFx0LS10b3RhbCB8fCBkb25lKCk7XG5cdFx0ICB9KTtcblx0XHR9KShwYWNrZXRzW2ldKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBkb25lKCl7XG5cdFx0c2VsZi5lbWl0KCdmbHVzaCcpO1xuXG5cdFx0Ly8gZmFrZSBkcmFpblxuXHRcdC8vIGRlZmVyIHRvIG5leHQgdGljayB0byBhbGxvdyBTb2NrZXQgdG8gY2xlYXIgd3JpdGVCdWZmZXJcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0ICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcblx0XHQgIHNlbGYuZW1pdCgnZHJhaW4nKTtcblx0XHR9LCAwKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGNsb3NlXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRXUy5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uKCl7XG5cdCAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsb3NlcyBzb2NrZXQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRXUy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCl7XG5cdCAgaWYgKHR5cGVvZiB0aGlzLndzICE9PSAndW5kZWZpbmVkJykge1xuXHRcdHRoaXMud3MuY2xvc2UoKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRXUy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24oKXtcblx0ICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuXHQgIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJztcblx0ICB2YXIgcG9ydCA9ICcnO1xuXG5cdCAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcblx0ICBpZiAodGhpcy5wb3J0ICYmICgoJ3dzcycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA0NDMpXG5cdFx0fHwgKCd3cycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA4MCkpKSB7XG5cdFx0cG9ydCA9ICc6JyArIHRoaXMucG9ydDtcblx0ICB9XG5cblx0ICAvLyBhcHBlbmQgdGltZXN0YW1wIHRvIFVSSVxuXHQgIGlmICh0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG5cdFx0cXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuXHQgIH1cblxuXHQgIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuXHQgIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuXHRcdHF1ZXJ5LmI2NCA9IDE7XG5cdCAgfVxuXG5cdCAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cblx0ICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcblx0ICBpZiAocXVlcnkubGVuZ3RoKSB7XG5cdFx0cXVlcnkgPSAnPycgKyBxdWVyeTtcblx0ICB9XG5cblx0ICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcblx0ICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcblx0fTtcblxuXHQvKipcblx0ICogRmVhdHVyZSBkZXRlY3Rpb24gZm9yIFdlYlNvY2tldC5cblx0ICpcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciB0aGlzIHRyYW5zcG9ydCBpcyBhdmFpbGFibGUuXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFdTLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKCl7XG5cdCAgcmV0dXJuICEhV2ViU29ja2V0ICYmICEoJ19faW5pdGlhbGl6ZScgaW4gV2ViU29ja2V0ICYmIHRoaXMubmFtZSA9PT0gV1MucHJvdG90eXBlLm5hbWUpO1xuXHR9O1xuXG5cdH0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxuXHR9LHtcIi4uL3RyYW5zcG9ydFwiOjQsXCJjb21wb25lbnQtaW5oZXJpdFwiOjE2LFwiZGVidWdcIjoxNyxcImVuZ2luZS5pby1wYXJzZXJcIjoxOSxcInBhcnNlcXNcIjoyNyxcIndzXCI6dW5kZWZpbmVkLFwieWVhc3RcIjozMH1dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblx0Ly8gYnJvd3NlciBzaGltIGZvciB4bWxodHRwcmVxdWVzdCBtb2R1bGVcblx0dmFyIGhhc0NPUlMgPSBfZGVyZXFfKCdoYXMtY29ycycpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0cykge1xuXHQgIHZhciB4ZG9tYWluID0gb3B0cy54ZG9tYWluO1xuXG5cdCAgLy8gc2NoZW1lIG11c3QgYmUgc2FtZSB3aGVuIHVzaWduIFhEb21haW5SZXF1ZXN0XG5cdCAgLy8gaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDEwLzA1LzEzL3hkb21haW5yZXF1ZXN0LXJlc3RyaWN0aW9ucy1saW1pdGF0aW9ucy1hbmQtd29ya2Fyb3VuZHMuYXNweFxuXHQgIHZhciB4c2NoZW1lID0gb3B0cy54c2NoZW1lO1xuXG5cdCAgLy8gWERvbWFpblJlcXVlc3QgaGFzIGEgZmxvdyBvZiBub3Qgc2VuZGluZyBjb29raWUsIHRoZXJlZm9yZSBpdCBzaG91bGQgYmUgZGlzYWJsZWQgYXMgYSBkZWZhdWx0LlxuXHQgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2VuZ2luZS5pby1jbGllbnQvcHVsbC8yMTdcblx0ICB2YXIgZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuXHQgIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuXHQgIHRyeSB7XG5cdFx0aWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJiAoIXhkb21haW4gfHwgaGFzQ09SUykpIHtcblx0XHQgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHR9XG5cdCAgfSBjYXRjaCAoZSkgeyB9XG5cblx0ICAvLyBVc2UgWERvbWFpblJlcXVlc3QgZm9yIElFOCBpZiBlbmFibGVzWERSIGlzIHRydWVcblx0ICAvLyBiZWNhdXNlIGxvYWRpbmcgYmFyIGtlZXBzIGZsYXNoaW5nIHdoZW4gdXNpbmcganNvbnAtcG9sbGluZ1xuXHQgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95dWppb3Nha2Evc29ja2UuaW8taWU4LWxvYWRpbmctZXhhbXBsZVxuXHQgIHRyeSB7XG5cdFx0aWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBYRG9tYWluUmVxdWVzdCAmJiAheHNjaGVtZSAmJiBlbmFibGVzWERSKSB7XG5cdFx0ICByZXR1cm4gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG5cdFx0fVxuXHQgIH0gY2F0Y2ggKGUpIHsgfVxuXG5cdCAgaWYgKCF4ZG9tYWluKSB7XG5cdFx0dHJ5IHtcblx0XHQgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcblx0XHR9IGNhdGNoKGUpIHsgfVxuXHQgIH1cblx0fVxuXG5cdH0se1wiaGFzLWNvcnNcIjoyMn1dLDExOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblx0bW9kdWxlLmV4cG9ydHMgPSBhZnRlclxuXG5cdGZ1bmN0aW9uIGFmdGVyKGNvdW50LCBjYWxsYmFjaywgZXJyX2NiKSB7XG5cdFx0dmFyIGJhaWwgPSBmYWxzZVxuXHRcdGVycl9jYiA9IGVycl9jYiB8fCBub29wXG5cdFx0cHJveHkuY291bnQgPSBjb3VudFxuXG5cdFx0cmV0dXJuIChjb3VudCA9PT0gMCkgPyBjYWxsYmFjaygpIDogcHJveHlcblxuXHRcdGZ1bmN0aW9uIHByb3h5KGVyciwgcmVzdWx0KSB7XG5cdFx0XHRpZiAocHJveHkuY291bnQgPD0gMCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2FmdGVyIGNhbGxlZCB0b28gbWFueSB0aW1lcycpXG5cdFx0XHR9XG5cdFx0XHQtLXByb3h5LmNvdW50XG5cblx0XHRcdC8vIGFmdGVyIGZpcnN0IGVycm9yLCByZXN0IGFyZSBwYXNzZWQgdG8gZXJyX2NiXG5cdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdGJhaWwgPSB0cnVlXG5cdFx0XHRcdGNhbGxiYWNrKGVycilcblx0XHRcdFx0Ly8gZnV0dXJlIGVycm9yIGNhbGxiYWNrcyB3aWxsIGdvIHRvIGVycm9yIGhhbmRsZXJcblx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJfY2Jcblx0XHRcdH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5cdH0se31dLDEyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblx0LyoqXG5cdCAqIEFuIGFic3RyYWN0aW9uIGZvciBzbGljaW5nIGFuIGFycmF5YnVmZmVyIGV2ZW4gd2hlblxuXHQgKiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgaXMgbm90IHN1cHBvcnRlZFxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyLCBzdGFydCwgZW5kKSB7XG5cdCAgdmFyIGJ5dGVzID0gYXJyYXlidWZmZXIuYnl0ZUxlbmd0aDtcblx0ICBzdGFydCA9IHN0YXJ0IHx8IDA7XG5cdCAgZW5kID0gZW5kIHx8IGJ5dGVzO1xuXG5cdCAgaWYgKGFycmF5YnVmZmVyLnNsaWNlKSB7IHJldHVybiBhcnJheWJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTsgfVxuXG5cdCAgaWYgKHN0YXJ0IDwgMCkgeyBzdGFydCArPSBieXRlczsgfVxuXHQgIGlmIChlbmQgPCAwKSB7IGVuZCArPSBieXRlczsgfVxuXHQgIGlmIChlbmQgPiBieXRlcykgeyBlbmQgPSBieXRlczsgfVxuXG5cdCAgaWYgKHN0YXJ0ID49IGJ5dGVzIHx8IHN0YXJ0ID49IGVuZCB8fCBieXRlcyA9PT0gMCkge1xuXHRcdHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG5cdCAgfVxuXG5cdCAgdmFyIGFidiA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcblx0ICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kIC0gc3RhcnQpO1xuXHQgIGZvciAodmFyIGkgPSBzdGFydCwgaWkgPSAwOyBpIDwgZW5kOyBpKyssIGlpKyspIHtcblx0XHRyZXN1bHRbaWldID0gYWJ2W2ldO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcblx0fTtcblxuXHR9LHt9XSwxMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdC8qXG5cdCAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vbmlrbGFzdmgvYmFzZTY0LWFycmF5YnVmZmVyXG5cdCAqXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cblx0ICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXHQgKi9cblx0KGZ1bmN0aW9uKGNoYXJzKXtcblx0ICBcInVzZSBzdHJpY3RcIjtcblxuXHQgIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcblx0XHR2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksXG5cdFx0aSwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSs9Mykge1xuXHRcdCAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2ldID4+IDJdO1xuXHRcdCAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuXHRcdCAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG5cdFx0ICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaSArIDJdICYgNjNdO1xuXHRcdH1cblxuXHRcdGlmICgobGVuICUgMykgPT09IDIpIHtcblx0XHQgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgXCI9XCI7XG5cdFx0fSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG5cdFx0ICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gYmFzZTY0O1xuXHQgIH07XG5cblx0ICBleHBvcnRzLmRlY29kZSA9ICBmdW5jdGlvbihiYXNlNjQpIHtcblx0XHR2YXIgYnVmZmVyTGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCAqIDAuNzUsXG5cdFx0bGVuID0gYmFzZTY0Lmxlbmd0aCwgaSwgcCA9IDAsXG5cdFx0ZW5jb2RlZDEsIGVuY29kZWQyLCBlbmNvZGVkMywgZW5jb2RlZDQ7XG5cblx0XHRpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAxXSA9PT0gXCI9XCIpIHtcblx0XHQgIGJ1ZmZlckxlbmd0aC0tO1xuXHRcdCAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09IFwiPVwiKSB7XG5cdFx0XHRidWZmZXJMZW5ndGgtLTtcblx0XHQgIH1cblx0XHR9XG5cblx0XHR2YXIgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxcblx0XHRieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcblx0XHQgIGVuY29kZWQxID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaV0pO1xuXHRcdCAgZW5jb2RlZDIgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzFdKTtcblx0XHQgIGVuY29kZWQzID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSsyXSk7XG5cdFx0ICBlbmNvZGVkNCA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krM10pO1xuXG5cdFx0ICBieXRlc1twKytdID0gKGVuY29kZWQxIDw8IDIpIHwgKGVuY29kZWQyID4+IDQpO1xuXHRcdCAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG5cdFx0ICBieXRlc1twKytdID0gKChlbmNvZGVkMyAmIDMpIDw8IDYpIHwgKGVuY29kZWQ0ICYgNjMpO1xuXHRcdH1cblxuXHRcdHJldHVybiBhcnJheWJ1ZmZlcjtcblx0ICB9O1xuXHR9KShcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIik7XG5cblx0fSx7fV0sMTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQoZnVuY3Rpb24gKGdsb2JhbCl7XG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBibG9iIGJ1aWxkZXIgZXZlbiB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuXHQgKi9cblxuXHR2YXIgQmxvYkJ1aWxkZXIgPSBnbG9iYWwuQmxvYkJ1aWxkZXJcblx0ICB8fCBnbG9iYWwuV2ViS2l0QmxvYkJ1aWxkZXJcblx0ICB8fCBnbG9iYWwuTVNCbG9iQnVpbGRlclxuXHQgIHx8IGdsb2JhbC5Nb3pCbG9iQnVpbGRlcjtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcblx0ICovXG5cblx0dmFyIGJsb2JTdXBwb3J0ZWQgPSAoZnVuY3Rpb24oKSB7XG5cdCAgdHJ5IHtcblx0XHR2YXIgYSA9IG5ldyBCbG9iKFsnaGknXSk7XG5cdFx0cmV0dXJuIGEuc2l6ZSA9PT0gMjtcblx0ICB9IGNhdGNoKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHR9KSgpO1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIHN1cHBvcnRzIEFycmF5QnVmZmVyVmlld3Ncblx0ICogRmFpbHMgaW4gU2FmYXJpIDYsIHNvIHdlIG5lZWQgdG8gbWFwIHRvIEFycmF5QnVmZmVycyB0aGVyZS5cblx0ICovXG5cblx0dmFyIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA9IGJsb2JTdXBwb3J0ZWQgJiYgKGZ1bmN0aW9uKCkge1xuXHQgIHRyeSB7XG5cdFx0dmFyIGIgPSBuZXcgQmxvYihbbmV3IFVpbnQ4QXJyYXkoWzEsMl0pXSk7XG5cdFx0cmV0dXJuIGIuc2l6ZSA9PT0gMjtcblx0ICB9IGNhdGNoKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHR9KSgpO1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBCbG9iQnVpbGRlciBpcyBzdXBwb3J0ZWRcblx0ICovXG5cblx0dmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcblx0ICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kXG5cdCAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7XG5cblx0LyoqXG5cdCAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IG1hcHMgQXJyYXlCdWZmZXJWaWV3cyB0byBBcnJheUJ1ZmZlcnNcblx0ICogVXNlZCBieSBCbG9iQnVpbGRlciBjb25zdHJ1Y3RvciBhbmQgb2xkIGJyb3dzZXJzIHRoYXQgZGlkbid0XG5cdCAqIHN1cHBvcnQgaXQgaW4gdGhlIEJsb2IgY29uc3RydWN0b3IuXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KSB7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgY2h1bmsgPSBhcnlbaV07XG5cdFx0aWYgKGNodW5rLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdFx0ICB2YXIgYnVmID0gY2h1bmsuYnVmZmVyO1xuXG5cdFx0ICAvLyBpZiB0aGlzIGlzIGEgc3ViYXJyYXksIG1ha2UgYSBjb3B5IHNvIHdlIG9ubHlcblx0XHQgIC8vIGluY2x1ZGUgdGhlIHN1YmFycmF5IHJlZ2lvbiBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlclxuXHRcdCAgaWYgKGNodW5rLmJ5dGVMZW5ndGggIT09IGJ1Zi5ieXRlTGVuZ3RoKSB7XG5cdFx0XHR2YXIgY29weSA9IG5ldyBVaW50OEFycmF5KGNodW5rLmJ5dGVMZW5ndGgpO1xuXHRcdFx0Y29weS5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKSk7XG5cdFx0XHRidWYgPSBjb3B5LmJ1ZmZlcjtcblx0XHQgIH1cblxuXHRcdCAgYXJ5W2ldID0gYnVmO1xuXHRcdH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuXHQgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdCAgdmFyIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG5cdCAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcblx0XHRiYi5hcHBlbmQoYXJ5W2ldKTtcblx0ICB9XG5cblx0ICByZXR1cm4gKG9wdGlvbnMudHlwZSkgPyBiYi5nZXRCbG9iKG9wdGlvbnMudHlwZSkgOiBiYi5nZXRCbG9iKCk7XG5cdH07XG5cblx0ZnVuY3Rpb24gQmxvYkNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuXHQgIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcblx0ICByZXR1cm4gbmV3IEJsb2IoYXJ5LCBvcHRpb25zIHx8IHt9KTtcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcblx0ICBpZiAoYmxvYlN1cHBvcnRlZCkge1xuXHRcdHJldHVybiBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPyBnbG9iYWwuQmxvYiA6IEJsb2JDb25zdHJ1Y3Rvcjtcblx0ICB9IGVsc2UgaWYgKGJsb2JCdWlsZGVyU3VwcG9ydGVkKSB7XG5cdFx0cmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XG5cdCAgfSBlbHNlIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHQgIH1cblx0fSkoKTtcblxuXHR9KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcblx0fSx7fV0sMTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5cdC8qKlxuXHQgKiBFeHBvc2UgYEVtaXR0ZXJgLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuXHQgIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqXG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIG1peGluKG9iaikge1xuXHQgIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuXHRcdG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcblx0ICB9XG5cdCAgcmV0dXJuIG9iajtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0ICogQHJldHVybiB7RW1pdHRlcn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUub24gPVxuXHRFbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcblx0ICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cdCAgKHRoaXMuX2NhbGxiYWNrc1tldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdKVxuXHRcdC5wdXNoKGZuKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG5cdCAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG5cdCAgZnVuY3Rpb24gb24oKSB7XG5cdFx0c2VsZi5vZmYoZXZlbnQsIG9uKTtcblx0XHRmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIH1cblxuXHQgIG9uLmZuID0gZm47XG5cdCAgdGhpcy5vbihldmVudCwgb24pO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuXHQgKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG5cdCAqIEByZXR1cm4ge0VtaXR0ZXJ9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5cdEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cblx0RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cblx0RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG5cdCAgLy8gYWxsXG5cdCAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuXHRcdHJldHVybiB0aGlzO1xuXHQgIH1cblxuXHQgIC8vIHNwZWNpZmljIGV2ZW50XG5cdCAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cdCAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG5cdCAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuXHQgIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblx0XHRyZXR1cm4gdGhpcztcblx0ICB9XG5cblx0ICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuXHQgIHZhciBjYjtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuXHRcdGNiID0gY2FsbGJhY2tzW2ldO1xuXHRcdGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG5cdFx0ICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuXHRcdCAgYnJlYWs7XG5cdFx0fVxuXHQgIH1cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcGFyYW0ge01peGVkfSAuLi5cblx0ICogQHJldHVybiB7RW1pdHRlcn1cblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcblx0ICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cdCAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcblx0XHQsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cblx0ICBpZiAoY2FsbGJhY2tzKSB7XG5cdFx0Y2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblx0XHQgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHR9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblx0ICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXTtcblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuXHQgIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xuXHR9O1xuXG5cdH0se31dLDE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGEsIGIpe1xuXHQgIHZhciBmbiA9IGZ1bmN0aW9uKCl7fTtcblx0ICBmbi5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcblx0ICBhLnByb3RvdHlwZSA9IG5ldyBmbjtcblx0ICBhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGE7XG5cdH07XG5cdH0se31dLDE3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuXHQvKipcblx0ICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuXHQgKlxuXHQgKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG5cdCAqL1xuXG5cdGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4vZGVidWcnKTtcblx0ZXhwb3J0cy5sb2cgPSBsb2c7XG5cdGV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5cdGV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5cdGV4cG9ydHMubG9hZCA9IGxvYWQ7XG5cdGV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuXHRleHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG5cdFx0XHRcdCAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuXHRcdFx0XHRcdCAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuXHRcdFx0XHRcdCAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuXHQvKipcblx0ICogQ29sb3JzLlxuXHQgKi9cblxuXHRleHBvcnRzLmNvbG9ycyA9IFtcblx0ICAnbGlnaHRzZWFncmVlbicsXG5cdCAgJ2ZvcmVzdGdyZWVuJyxcblx0ICAnZ29sZGVucm9kJyxcblx0ICAnZG9kZ2VyYmx1ZScsXG5cdCAgJ2RhcmtvcmNoaWQnLFxuXHQgICdjcmltc29uJ1xuXHRdO1xuXG5cdC8qKlxuXHQgKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuXHQgKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cblx0ICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuXHQgKlxuXHQgKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuXHQgKi9cblxuXHRmdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdCAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0ICByZXR1cm4gKCdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHx8XG5cdFx0Ly8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh3aW5kb3cuY29uc29sZSAmJiAoY29uc29sZS5maXJlYnVnIHx8IChjb25zb2xlLmV4Y2VwdGlvbiAmJiBjb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gaXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG5cdCAqL1xuXG5cdGV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuXHQgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGZvcm1hdEFyZ3MoKSB7XG5cdCAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cdCAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG5cdCAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG5cdFx0KyB0aGlzLm5hbWVzcGFjZVxuXHRcdCsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuXHRcdCsgYXJnc1swXVxuXHRcdCsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuXHRcdCsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdCAgaWYgKCF1c2VDb2xvcnMpIHJldHVybiBhcmdzO1xuXG5cdCAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHQgIGFyZ3MgPSBbYXJnc1swXSwgYywgJ2NvbG9yOiBpbmhlcml0J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcblxuXHQgIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdCAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQgIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHQgIHZhciBpbmRleCA9IDA7XG5cdCAgdmFyIGxhc3RDID0gMDtcblx0ICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16JV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcblx0XHRpbmRleCsrO1xuXHRcdGlmICgnJWMnID09PSBtYXRjaCkge1xuXHRcdCAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0ICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdCAgbGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdCAgfSk7XG5cblx0ICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG5cdCAgcmV0dXJuIGFyZ3M7XG5cdH1cblxuXHQvKipcblx0ICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG5cdCAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGxvZygpIHtcblx0ICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuXHQgIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG5cdCAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuXHRcdCYmIGNvbnNvbGUubG9nXG5cdFx0JiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG5cdH1cblxuXHQvKipcblx0ICogU2F2ZSBgbmFtZXNwYWNlc2AuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0ICB0cnkge1xuXHRcdGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcblx0XHQgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH0gZWxzZSB7XG5cdFx0ICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuXHRcdH1cblx0ICB9IGNhdGNoKGUpIHt9XG5cdH1cblxuXHQvKipcblx0ICogTG9hZCBgbmFtZXNwYWNlc2AuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGxvYWQoKSB7XG5cdCAgdmFyIHI7XG5cdCAgdHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuXHQgIH0gY2F0Y2goZSkge31cblx0ICByZXR1cm4gcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuXHQgKi9cblxuXHRleHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG5cdC8qKlxuXHQgKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG5cdCAqXG5cdCAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuXHQgKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuXHQgKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKXtcblx0ICB0cnkge1xuXHRcdHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuXHQgIH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHR9LHtcIi4vZGVidWdcIjoxOH1dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuXHQvKipcblx0ICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuXHQgKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuXHQgKlxuXHQgKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG5cdCAqL1xuXG5cdGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRlYnVnO1xuXHRleHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcblx0ZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcblx0ZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5cdGV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGV4cG9ydHMuaHVtYW5pemUgPSBfZGVyZXFfKCdtcycpO1xuXG5cdC8qKlxuXHQgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0ICovXG5cblx0ZXhwb3J0cy5uYW1lcyA9IFtdO1xuXHRleHBvcnRzLnNraXBzID0gW107XG5cblx0LyoqXG5cdCAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0ICpcblx0ICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXJjYXNlZCBsZXR0ZXIsIGkuZS4gXCJuXCIuXG5cdCAqL1xuXG5cdGV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQgKiBQcmV2aW91c2x5IGFzc2lnbmVkIGNvbG9yLlxuXHQgKi9cblxuXHR2YXIgcHJldkNvbG9yID0gMDtcblxuXHQvKipcblx0ICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cblx0ICovXG5cblx0dmFyIHByZXZUaW1lO1xuXG5cdC8qKlxuXHQgKiBTZWxlY3QgYSBjb2xvci5cblx0ICpcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IoKSB7XG5cdCAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW3ByZXZDb2xvcisrICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gZGVidWcobmFtZXNwYWNlKSB7XG5cblx0ICAvLyBkZWZpbmUgdGhlIGBkaXNhYmxlZGAgdmVyc2lvblxuXHQgIGZ1bmN0aW9uIGRpc2FibGVkKCkge1xuXHQgIH1cblx0ICBkaXNhYmxlZC5lbmFibGVkID0gZmFsc2U7XG5cblx0ICAvLyBkZWZpbmUgdGhlIGBlbmFibGVkYCB2ZXJzaW9uXG5cdCAgZnVuY3Rpb24gZW5hYmxlZCgpIHtcblxuXHRcdHZhciBzZWxmID0gZW5hYmxlZDtcblxuXHRcdC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0dmFyIGN1cnIgPSArbmV3IERhdGUoKTtcblx0XHR2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0Ly8gYWRkIHRoZSBgY29sb3JgIGlmIG5vdCBzZXRcblx0XHRpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuXHRcdGlmIChudWxsID09IHNlbGYuY29sb3IgJiYgc2VsZi51c2VDb2xvcnMpIHNlbGYuY29sb3IgPSBzZWxlY3RDb2xvcigpO1xuXG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG5cdFx0YXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0aWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuXHRcdCAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJW9cblx0XHQgIGFyZ3MgPSBbJyVvJ10uY29uY2F0KGFyZ3MpO1xuXHRcdH1cblxuXHRcdC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0dmFyIGluZGV4ID0gMDtcblx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuXHRcdCAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdCAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG5cdFx0ICBpbmRleCsrO1xuXHRcdCAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdCAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcblx0XHRcdHZhciB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0Ly8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0aW5kZXgtLTtcblx0XHQgIH1cblx0XHQgIHJldHVybiBtYXRjaDtcblx0XHR9KTtcblxuXHRcdGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5mb3JtYXRBcmdzKSB7XG5cdFx0ICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblx0XHR2YXIgbG9nRm4gPSBlbmFibGVkLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuXHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHQgIH1cblx0ICBlbmFibGVkLmVuYWJsZWQgPSB0cnVlO1xuXG5cdCAgdmFyIGZuID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSkgPyBlbmFibGVkIDogZGlzYWJsZWQ7XG5cblx0ICBmbi5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cblx0ICByZXR1cm4gZm47XG5cdH1cblxuXHQvKipcblx0ICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQgKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHQgIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuXHQgIHZhciBzcGxpdCA9IChuYW1lc3BhY2VzIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHQgIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0aWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdCAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcblx0XHR9IGVsc2Uge1xuXHRcdCAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdH1cblx0ICB9XG5cdH1cblxuXHQvKipcblx0ICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdCAgZXhwb3J0cy5lbmFibGUoJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdCAgdmFyIGksIGxlbjtcblx0ICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0aWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdCAgcmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0ICB9XG5cdCAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHQgIHJldHVybiB0cnVlO1xuXHRcdH1cblx0ICB9XG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvZXJjZSBgdmFsYC5cblx0ICpcblx0ICogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCAqIEByZXR1cm4ge01peGVkfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHQgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0ICByZXR1cm4gdmFsO1xuXHR9XG5cblx0fSx7XCJtc1wiOjI1fV0sMTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQoZnVuY3Rpb24gKGdsb2JhbCl7XG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblxuXHR2YXIga2V5cyA9IF9kZXJlcV8oJy4va2V5cycpO1xuXHR2YXIgaGFzQmluYXJ5ID0gX2RlcmVxXygnaGFzLWJpbmFyeScpO1xuXHR2YXIgc2xpY2VCdWZmZXIgPSBfZGVyZXFfKCdhcnJheWJ1ZmZlci5zbGljZScpO1xuXHR2YXIgYmFzZTY0ZW5jb2RlciA9IF9kZXJlcV8oJ2Jhc2U2NC1hcnJheWJ1ZmZlcicpO1xuXHR2YXIgYWZ0ZXIgPSBfZGVyZXFfKCdhZnRlcicpO1xuXHR2YXIgdXRmOCA9IF9kZXJlcV8oJ3V0ZjgnKTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgYW4gYW5kcm9pZCBicm93c2VyLiBUaGF0IHJlcXVpcmVzIHVzIHRvIHVzZVxuXHQgKiBBcnJheUJ1ZmZlciB3aXRoIHBvbGxpbmcgdHJhbnNwb3J0cy4uLlxuXHQgKlxuXHQgKiBodHRwOi8vZ2hpbmRhLm5ldC9qcGVnLWJsb2ItYWpheC1hbmRyb2lkL1xuXHQgKi9cblxuXHR2YXIgaXNBbmRyb2lkID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQW5kcm9pZC9pKTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gUGhhbnRvbUpTLlxuXHQgKiBVcGxvYWRpbmcgYSBCbG9iIHdpdGggUGhhbnRvbUpTIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5LCBhcyByZXBvcnRlZCBoZXJlOlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTM5NVxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgaXNQaGFudG9tSlMgPSAvUGhhbnRvbUpTL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuXHQvKipcblx0ICogV2hlbiB0cnVlLCBhdm9pZHMgdXNpbmcgQmxvYnMgdG8gZW5jb2RlIHBheWxvYWRzLlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZG9udFNlbmRCbG9icyA9IGlzQW5kcm9pZCB8fCBpc1BoYW50b21KUztcblxuXHQvKipcblx0ICogQ3VycmVudCBwcm90b2NvbCB2ZXJzaW9uLlxuXHQgKi9cblxuXHRleHBvcnRzLnByb3RvY29sID0gMztcblxuXHQvKipcblx0ICogUGFja2V0IHR5cGVzLlxuXHQgKi9cblxuXHR2YXIgcGFja2V0cyA9IGV4cG9ydHMucGFja2V0cyA9IHtcblx0XHRvcGVuOiAgICAgMCAgICAvLyBub24td3Ncblx0ICAsIGNsb3NlOiAgICAxICAgIC8vIG5vbi13c1xuXHQgICwgcGluZzogICAgIDJcblx0ICAsIHBvbmc6ICAgICAzXG5cdCAgLCBtZXNzYWdlOiAgNFxuXHQgICwgdXBncmFkZTogIDVcblx0ICAsIG5vb3A6ICAgICA2XG5cdH07XG5cblx0dmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblxuXHQvKipcblx0ICogUHJlbWFkZSBlcnJvciBwYWNrZXQuXG5cdCAqL1xuXG5cdHZhciBlcnIgPSB7IHR5cGU6ICdlcnJvcicsIGRhdGE6ICdwYXJzZXIgZXJyb3InIH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuXHQgKi9cblxuXHR2YXIgQmxvYiA9IF9kZXJlcV8oJ2Jsb2InKTtcblxuXHQvKipcblx0ICogRW5jb2RlcyBhIHBhY2tldC5cblx0ICpcblx0ICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKlxuXHQgKiAgICAgNWhlbGxvIHdvcmxkXG5cdCAqICAgICAzXG5cdCAqICAgICA0XG5cdCAqXG5cdCAqIEJpbmFyeSBpcyBlbmNvZGVkIGluIGFuIGlkZW50aWNhbCBwcmluY2lwbGVcblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG5cdCAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHN1cHBvcnRzQmluYXJ5KSB7XG5cdFx0Y2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcblx0XHRzdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXHQgIH1cblxuXHQgIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB1dGY4ZW5jb2RlKSB7XG5cdFx0Y2FsbGJhY2sgPSB1dGY4ZW5jb2RlO1xuXHRcdHV0ZjhlbmNvZGUgPSBudWxsO1xuXHQgIH1cblxuXHQgIHZhciBkYXRhID0gKHBhY2tldC5kYXRhID09PSB1bmRlZmluZWQpXG5cdFx0PyB1bmRlZmluZWRcblx0XHQ6IHBhY2tldC5kYXRhLmJ1ZmZlciB8fCBwYWNrZXQuZGF0YTtcblxuXHQgIGlmIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdFx0cmV0dXJuIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcblx0ICB9IGVsc2UgaWYgKEJsb2IgJiYgZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG5cdFx0cmV0dXJuIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuXHQgIH1cblxuXHQgIC8vIG1pZ2h0IGJlIGFuIG9iamVjdCB3aXRoIHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuXHQgIGlmIChkYXRhICYmIGRhdGEuYmFzZTY0KSB7XG5cdFx0cmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcblx0ICB9XG5cblx0ICAvLyBTZW5kaW5nIGRhdGEgYXMgYSB1dGYtOCBzdHJpbmdcblx0ICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG5cdCAgLy8gZGF0YSBmcmFnbWVudCBpcyBvcHRpb25hbFxuXHQgIGlmICh1bmRlZmluZWQgIT09IHBhY2tldC5kYXRhKSB7XG5cdFx0ZW5jb2RlZCArPSB1dGY4ZW5jb2RlID8gdXRmOC5lbmNvZGUoU3RyaW5nKHBhY2tldC5kYXRhKSkgOiBTdHJpbmcocGFja2V0LmRhdGEpO1xuXHQgIH1cblxuXHQgIHJldHVybiBjYWxsYmFjaygnJyArIGVuY29kZWQpO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spIHtcblx0ICAvLyBwYWNrZXQgZGF0YSBpcyBhbiBvYmplY3QgeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG5cdCAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdICsgcGFja2V0LmRhdGEuZGF0YTtcblx0ICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG5cdH1cblxuXHQvKipcblx0ICogRW5jb2RlIHBhY2tldCBoZWxwZXJzIGZvciBiaW5hcnkgdHlwZXNcblx0ICovXG5cblx0ZnVuY3Rpb24gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcblx0ICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG5cdFx0cmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuXHQgIH1cblxuXHQgIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG5cdCAgdmFyIGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuXHQgIHZhciByZXN1bHRCdWZmZXIgPSBuZXcgVWludDhBcnJheSgxICsgZGF0YS5ieXRlTGVuZ3RoKTtcblxuXHQgIHJlc3VsdEJ1ZmZlclswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0cmVzdWx0QnVmZmVyW2krMV0gPSBjb250ZW50QXJyYXlbaV07XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcblx0ICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG5cdFx0cmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuXHQgIH1cblxuXHQgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdCAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0cGFja2V0LmRhdGEgPSBmci5yZXN1bHQ7XG5cdFx0ZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgY2FsbGJhY2spO1xuXHQgIH07XG5cdCAgcmV0dXJuIGZyLnJlYWRBc0FycmF5QnVmZmVyKHBhY2tldC5kYXRhKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcblx0ICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG5cdFx0cmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuXHQgIH1cblxuXHQgIGlmIChkb250U2VuZEJsb2JzKSB7XG5cdFx0cmV0dXJuIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcblx0ICB9XG5cblx0ICB2YXIgbGVuZ3RoID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG5cdCAgbGVuZ3RoWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cdCAgdmFyIGJsb2IgPSBuZXcgQmxvYihbbGVuZ3RoLmJ1ZmZlciwgcGFja2V0LmRhdGFdKTtcblxuXHQgIHJldHVybiBjYWxsYmFjayhibG9iKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2Vcblx0ICovXG5cblx0ZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGNhbGxiYWNrKSB7XG5cdCAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuXHQgIGlmIChCbG9iICYmIHBhY2tldC5kYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcblx0XHR2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdCAgdmFyIGI2NCA9IGZyLnJlc3VsdC5zcGxpdCgnLCcpWzFdO1xuXHRcdCAgY2FsbGJhY2sobWVzc2FnZSArIGI2NCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gZnIucmVhZEFzRGF0YVVSTChwYWNrZXQuZGF0YSk7XG5cdCAgfVxuXG5cdCAgdmFyIGI2NGRhdGE7XG5cdCAgdHJ5IHtcblx0XHRiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSkpO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB3aXRoIHR5cGVkIGFycmF5c1xuXHRcdHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKTtcblx0XHR2YXIgYmFzaWMgPSBuZXcgQXJyYXkodHlwZWQubGVuZ3RoKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG5cdFx0ICBiYXNpY1tpXSA9IHR5cGVkW2ldO1xuXHRcdH1cblx0XHRiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBiYXNpYyk7XG5cdCAgfVxuXHQgIG1lc3NhZ2UgKz0gZ2xvYmFsLmJ0b2EoYjY0ZGF0YSk7XG5cdCAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZWNvZGVzIGEgcGFja2V0LiBDaGFuZ2VzIGZvcm1hdCB0byBCbG9iIGlmIHJlcXVlc3RlZC5cblx0ICpcblx0ICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRleHBvcnRzLmRlY29kZVBhY2tldCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCB1dGY4ZGVjb2RlKSB7XG5cdCAgLy8gU3RyaW5nIGRhdGFcblx0ICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycgfHwgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGRhdGEuY2hhckF0KDApID09ICdiJykge1xuXHRcdCAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0KGRhdGEuc3Vic3RyKDEpLCBiaW5hcnlUeXBlKTtcblx0XHR9XG5cblx0XHRpZiAodXRmOGRlY29kZSkge1xuXHRcdCAgdHJ5IHtcblx0XHRcdGRhdGEgPSB1dGY4LmRlY29kZShkYXRhKTtcblx0XHQgIH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBlcnI7XG5cdFx0ICB9XG5cdFx0fVxuXHRcdHZhciB0eXBlID0gZGF0YS5jaGFyQXQoMCk7XG5cblx0XHRpZiAoTnVtYmVyKHR5cGUpICE9IHR5cGUgfHwgIXBhY2tldHNsaXN0W3R5cGVdKSB7XG5cdFx0ICByZXR1cm4gZXJyO1xuXHRcdH1cblxuXHRcdGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcblx0XHQgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiBkYXRhLnN1YnN0cmluZygxKSB9O1xuXHRcdH0gZWxzZSB7XG5cdFx0ICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSB9O1xuXHRcdH1cblx0ICB9XG5cblx0ICB2YXIgYXNBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuXHQgIHZhciB0eXBlID0gYXNBcnJheVswXTtcblx0ICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuXHQgIGlmIChCbG9iICYmIGJpbmFyeVR5cGUgPT09ICdibG9iJykge1xuXHRcdHJlc3QgPSBuZXcgQmxvYihbcmVzdF0pO1xuXHQgIH1cblx0ICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZWNvZGVzIGEgcGFja2V0IGVuY29kZWQgaW4gYSBiYXNlNjQgc3RyaW5nXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG5cdCAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuXHQgKi9cblxuXHRleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKG1zZywgYmluYXJ5VHlwZSkge1xuXHQgIHZhciB0eXBlID0gcGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07XG5cdCAgaWYgKCFnbG9iYWwuQXJyYXlCdWZmZXIpIHtcblx0XHRyZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogbXNnLnN1YnN0cigxKSB9IH07XG5cdCAgfVxuXG5cdCAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuXHQgIGlmIChiaW5hcnlUeXBlID09PSAnYmxvYicgJiYgQmxvYikge1xuXHRcdGRhdGEgPSBuZXcgQmxvYihbZGF0YV0pO1xuXHQgIH1cblxuXHQgIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcblx0fTtcblxuXHQvKipcblx0ICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG5cdCAqXG5cdCAqICAgICA8bGVuZ3RoPjpkYXRhXG5cdCAqXG5cdCAqIEV4YW1wbGU6XG5cdCAqXG5cdCAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcblx0ICpcblx0ICogSWYgYW55IGNvbnRlbnRzIGFyZSBiaW5hcnksIHRoZXkgd2lsbCBiZSBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmdzLiBCYXNlNjRcblx0ICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGV4cG9ydHMuZW5jb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChwYWNrZXRzLCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcblx0ICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09ICdmdW5jdGlvbicpIHtcblx0XHRjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuXHRcdHN1cHBvcnRzQmluYXJ5ID0gbnVsbDtcblx0ICB9XG5cblx0ICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cblx0ICBpZiAoc3VwcG9ydHNCaW5hcnkgJiYgaXNCaW5hcnkpIHtcblx0XHRpZiAoQmxvYiAmJiAhZG9udFNlbmRCbG9icykge1xuXHRcdCAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYihwYWNrZXRzLCBjYWxsYmFjayk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIocGFja2V0cywgY2FsbGJhY2spO1xuXHQgIH1cblxuXHQgIGlmICghcGFja2V0cy5sZW5ndGgpIHtcblx0XHRyZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpIHtcblx0XHRyZXR1cm4gbWVzc2FnZS5sZW5ndGggKyAnOicgKyBtZXNzYWdlO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuXHRcdGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgIWlzQmluYXJ5ID8gZmFsc2UgOiBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdCAgZG9uZUNhbGxiYWNrKG51bGwsIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSk7XG5cdFx0fSk7XG5cdCAgfVxuXG5cdCAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG5cdFx0cmV0dXJuIGNhbGxiYWNrKHJlc3VsdHMuam9pbignJykpO1xuXHQgIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBc3luYyBhcnJheSBtYXAgdXNpbmcgYWZ0ZXJcblx0ICovXG5cblx0ZnVuY3Rpb24gbWFwKGFyeSwgZWFjaCwgZG9uZSkge1xuXHQgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYXJ5Lmxlbmd0aCk7XG5cdCAgdmFyIG5leHQgPSBhZnRlcihhcnkubGVuZ3RoLCBkb25lKTtcblxuXHQgIHZhciBlYWNoV2l0aEluZGV4ID0gZnVuY3Rpb24oaSwgZWwsIGNiKSB7XG5cdFx0ZWFjaChlbCwgZnVuY3Rpb24oZXJyb3IsIG1zZykge1xuXHRcdCAgcmVzdWx0W2ldID0gbXNnO1xuXHRcdCAgY2IoZXJyb3IsIHJlc3VsdCk7XG5cdFx0fSk7XG5cdCAgfTtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0ZWFjaFdpdGhJbmRleChpLCBhcnlbaV0sIG5leHQpO1xuXHQgIH1cblx0fVxuXG5cdC8qXG5cdCAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gUG9zc2libGUgYmluYXJ5IGNvbnRlbnRzIGFyZVxuXHQgKiBkZWNvZGVkIGZyb20gdGhlaXIgYmFzZTY0IHJlcHJlc2VudGF0aW9uXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLCBjYWxsYmFjayBtZXRob2Rcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG5cdCAgaWYgKHR5cGVvZiBkYXRhICE9ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcblx0ICB9XG5cblx0ICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG5cdFx0YmluYXJ5VHlwZSA9IG51bGw7XG5cdCAgfVxuXG5cdCAgdmFyIHBhY2tldDtcblx0ICBpZiAoZGF0YSA9PSAnJykge1xuXHRcdC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcblx0XHRyZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblx0ICB9XG5cblx0ICB2YXIgbGVuZ3RoID0gJydcblx0XHQsIG4sIG1zZztcblxuXHQgIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHR2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cblx0XHRpZiAoJzonICE9IGNocikge1xuXHRcdCAgbGVuZ3RoICs9IGNocjtcblx0XHR9IGVsc2Uge1xuXHRcdCAgaWYgKCcnID09IGxlbmd0aCB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuXHRcdFx0Ly8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cdFx0ICB9XG5cblx0XHQgIG1zZyA9IGRhdGEuc3Vic3RyKGkgKyAxLCBuKTtcblxuXHRcdCAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG5cdFx0XHQvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblx0XHQgIH1cblxuXHRcdCAgaWYgKG1zZy5sZW5ndGgpIHtcblx0XHRcdHBhY2tldCA9IGV4cG9ydHMuZGVjb2RlUGFja2V0KG1zZywgYmluYXJ5VHlwZSwgdHJ1ZSk7XG5cblx0XHRcdGlmIChlcnIudHlwZSA9PSBwYWNrZXQudHlwZSAmJiBlcnIuZGF0YSA9PSBwYWNrZXQuZGF0YSkge1xuXHRcdFx0ICAvLyBwYXJzZXIgZXJyb3IgaW4gaW5kaXZpZHVhbCBwYWNrZXQgLSBpZ25vcmluZyBwYXlsb2FkXG5cdFx0XHQgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcmV0ID0gY2FsbGJhY2socGFja2V0LCBpICsgbiwgbCk7XG5cdFx0XHRpZiAoZmFsc2UgPT09IHJldCkgcmV0dXJuO1xuXHRcdCAgfVxuXG5cdFx0ICAvLyBhZHZhbmNlIGN1cnNvclxuXHRcdCAgaSArPSBuO1xuXHRcdCAgbGVuZ3RoID0gJyc7XG5cdFx0fVxuXHQgIH1cblxuXHQgIGlmIChsZW5ndGggIT0gJycpIHtcblx0XHQvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG5cdFx0cmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cdCAgfVxuXG5cdH07XG5cblx0LyoqXG5cdCAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cblx0ICpcblx0ICogPDEgPSBiaW5hcnksIDAgPSBzdHJpbmc+PG51bWJlciBmcm9tIDAtOT48bnVtYmVyIGZyb20gMC05PlsuLi5dPG51bWJlclxuXHQgKiAyNTU+PGRhdGE+XG5cdCAqXG5cdCAqIEV4YW1wbGU6XG5cdCAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcblx0ICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG5cdCAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuXHRcdHJldHVybiBjYWxsYmFjayhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuXHRcdGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuXHRcdCAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBkYXRhKTtcblx0XHR9KTtcblx0ICB9XG5cblx0ICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIGVuY29kZWRQYWNrZXRzKSB7XG5cdFx0dmFyIHRvdGFsTGVuZ3RoID0gZW5jb2RlZFBhY2tldHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgcCkge1xuXHRcdCAgdmFyIGxlbjtcblx0XHQgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpe1xuXHRcdFx0bGVuID0gcC5sZW5ndGg7XG5cdFx0ICB9IGVsc2Uge1xuXHRcdFx0bGVuID0gcC5ieXRlTGVuZ3RoO1xuXHRcdCAgfVxuXHRcdCAgcmV0dXJuIGFjYyArIGxlbi50b1N0cmluZygpLmxlbmd0aCArIGxlbiArIDI7IC8vIHN0cmluZy9iaW5hcnkgaWRlbnRpZmllciArIHNlcGFyYXRvciA9IDJcblx0XHR9LCAwKTtcblxuXHRcdHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuXHRcdHZhciBidWZmZXJJbmRleCA9IDA7XG5cdFx0ZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG5cdFx0ICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgcCA9PT0gJ3N0cmluZyc7XG5cdFx0ICB2YXIgYWIgPSBwO1xuXHRcdCAgaWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHAubGVuZ3RoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuXHRcdFx0ICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0fVxuXHRcdFx0YWIgPSB2aWV3LmJ1ZmZlcjtcblx0XHQgIH1cblxuXHRcdCAgaWYgKGlzU3RyaW5nKSB7IC8vIG5vdCB0cnVlIGJpbmFyeVxuXHRcdFx0cmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuXHRcdCAgfSBlbHNlIHsgLy8gdHJ1ZSBiaW5hcnlcblx0XHRcdHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMTtcblx0XHQgIH1cblxuXHRcdCAgdmFyIGxlblN0ciA9IGFiLmJ5dGVMZW5ndGgudG9TdHJpbmcoKTtcblx0XHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRyZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG5cdFx0ICB9XG5cdFx0ICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDI1NTtcblxuXHRcdCAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhYik7XG5cdFx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcblx0XHRcdHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gdmlld1tpXTtcblx0XHQgIH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuXHQgIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbmNvZGUgYXMgQmxvYlxuXHQgKi9cblxuXHRleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuXHQgIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuXHRcdGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZW5jb2RlZCkge1xuXHRcdCAgdmFyIGJpbmFyeUlkZW50aWZpZXIgPSBuZXcgVWludDhBcnJheSgxKTtcblx0XHQgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAxO1xuXHRcdCAgaWYgKHR5cGVvZiBlbmNvZGVkID09PSAnc3RyaW5nJykge1xuXHRcdFx0dmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkLmxlbmd0aCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcblx0XHRcdCAgdmlld1tpXSA9IGVuY29kZWQuY2hhckNvZGVBdChpKTtcblx0XHRcdH1cblx0XHRcdGVuY29kZWQgPSB2aWV3LmJ1ZmZlcjtcblx0XHRcdGJpbmFyeUlkZW50aWZpZXJbMF0gPSAwO1xuXHRcdCAgfVxuXG5cdFx0ICB2YXIgbGVuID0gKGVuY29kZWQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcblx0XHRcdD8gZW5jb2RlZC5ieXRlTGVuZ3RoXG5cdFx0XHQ6IGVuY29kZWQuc2l6ZTtcblxuXHRcdCAgdmFyIGxlblN0ciA9IGxlbi50b1N0cmluZygpO1xuXHRcdCAgdmFyIGxlbmd0aEFyeSA9IG5ldyBVaW50OEFycmF5KGxlblN0ci5sZW5ndGggKyAxKTtcblx0XHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZW5ndGhBcnlbaV0gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuXHRcdCAgfVxuXHRcdCAgbGVuZ3RoQXJ5W2xlblN0ci5sZW5ndGhdID0gMjU1O1xuXG5cdFx0ICBpZiAoQmxvYikge1xuXHRcdFx0dmFyIGJsb2IgPSBuZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsIGxlbmd0aEFyeS5idWZmZXIsIGVuY29kZWRdKTtcblx0XHRcdGRvbmVDYWxsYmFjayhudWxsLCBibG9iKTtcblx0XHQgIH1cblx0XHR9KTtcblx0ICB9XG5cblx0ICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcblx0XHRyZXR1cm4gY2FsbGJhY2sobmV3IEJsb2IocmVzdWx0cykpO1xuXHQgIH0pO1xuXHR9O1xuXG5cdC8qXG5cdCAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gU3RyaW5ncyBhcmUgZGVjb2RlZCBieVxuXHQgKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG5cdCAqIGRlc2NyaXB0aW9uIG9mIGVuY29kZVBheWxvYWRBc0JpbmFyeVxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2Rcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcblx0ICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG5cdFx0YmluYXJ5VHlwZSA9IG51bGw7XG5cdCAgfVxuXG5cdCAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuXHQgIHZhciBidWZmZXJzID0gW107XG5cblx0ICB2YXIgbnVtYmVyVG9vTG9uZyA9IGZhbHNlO1xuXHQgIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG5cdFx0dmFyIHRhaWxBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO1xuXHRcdHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcblx0XHR2YXIgbXNnTGVuZ3RoID0gJyc7XG5cblx0XHRmb3IgKHZhciBpID0gMTsgOyBpKyspIHtcblx0XHQgIGlmICh0YWlsQXJyYXlbaV0gPT0gMjU1KSBicmVhaztcblxuXHRcdCAgaWYgKG1zZ0xlbmd0aC5sZW5ndGggPiAzMTApIHtcblx0XHRcdG51bWJlclRvb0xvbmcgPSB0cnVlO1xuXHRcdFx0YnJlYWs7XG5cdFx0ICB9XG5cblx0XHQgIG1zZ0xlbmd0aCArPSB0YWlsQXJyYXlbaV07XG5cdFx0fVxuXG5cdFx0aWYobnVtYmVyVG9vTG9uZykgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cblx0XHRidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMiArIG1zZ0xlbmd0aC5sZW5ndGgpO1xuXHRcdG1zZ0xlbmd0aCA9IHBhcnNlSW50KG1zZ0xlbmd0aCk7XG5cblx0XHR2YXIgbXNnID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMCwgbXNnTGVuZ3RoKTtcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHQgIHRyeSB7XG5cdFx0XHRtc2cgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KG1zZykpO1xuXHRcdCAgfSBjYXRjaCAoZSkge1xuXHRcdFx0Ly8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG5cdFx0XHR2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShtc2cpO1xuXHRcdFx0bXNnID0gJyc7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQgIG1zZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHR5cGVkW2ldKTtcblx0XHRcdH1cblx0XHQgIH1cblx0XHR9XG5cblx0XHRidWZmZXJzLnB1c2gobXNnKTtcblx0XHRidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgbXNnTGVuZ3RoKTtcblx0ICB9XG5cblx0ICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcblx0ICBidWZmZXJzLmZvckVhY2goZnVuY3Rpb24oYnVmZmVyLCBpKSB7XG5cdFx0Y2FsbGJhY2soZXhwb3J0cy5kZWNvZGVQYWNrZXQoYnVmZmVyLCBiaW5hcnlUeXBlLCB0cnVlKSwgaSwgdG90YWwpO1xuXHQgIH0pO1xuXHR9O1xuXG5cdH0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxuXHR9LHtcIi4va2V5c1wiOjIwLFwiYWZ0ZXJcIjoxMSxcImFycmF5YnVmZmVyLnNsaWNlXCI6MTIsXCJiYXNlNjQtYXJyYXlidWZmZXJcIjoxMyxcImJsb2JcIjoxNCxcImhhcy1iaW5hcnlcIjoyMSxcInV0ZjhcIjoyOX1dLDIwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuXHQvKipcblx0ICogR2V0cyB0aGUga2V5cyBmb3IgYW4gb2JqZWN0LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtBcnJheX0ga2V5c1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzIChvYmope1xuXHQgIHZhciBhcnIgPSBbXTtcblx0ICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuXHQgIGZvciAodmFyIGkgaW4gb2JqKSB7XG5cdFx0aWYgKGhhcy5jYWxsKG9iaiwgaSkpIHtcblx0XHQgIGFyci5wdXNoKGkpO1xuXHRcdH1cblx0ICB9XG5cdCAgcmV0dXJuIGFycjtcblx0fTtcblxuXHR9LHt9XSwyMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdChmdW5jdGlvbiAoZ2xvYmFsKXtcblxuXHQvKlxuXHQgKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuXHQgKi9cblxuXHR2YXIgaXNBcnJheSA9IF9kZXJlcV8oJ2lzYXJyYXknKTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gaGFzQmluYXJ5O1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuXHQgKlxuXHQgKiBSaWdodCBub3cgb25seSBCdWZmZXIgYW5kIEFycmF5QnVmZmVyIGFyZSBzdXBwb3J0ZWQuLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYW55dGhpbmdcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gaGFzQmluYXJ5KGRhdGEpIHtcblxuXHQgIGZ1bmN0aW9uIF9oYXNCaW5hcnkob2JqKSB7XG5cdFx0aWYgKCFvYmopIHJldHVybiBmYWxzZTtcblxuXHRcdGlmICggKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuXHRcdFx0IChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG5cdFx0XHQgKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG5cdFx0XHQgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpXG5cdFx0XHQpIHtcblx0XHQgIHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChpc0FycmF5KG9iaikpIHtcblx0XHQgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQgIGlmIChfaGFzQmluYXJ5KG9ialtpXSkpIHtcblx0XHRcdFx0ICByZXR1cm4gdHJ1ZTtcblx0XHRcdCAgfVxuXHRcdCAgfVxuXHRcdH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmopIHtcblx0XHQgIGlmIChvYmoudG9KU09OKSB7XG5cdFx0XHRvYmogPSBvYmoudG9KU09OKCk7XG5cdFx0ICB9XG5cblx0XHQgIGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIF9oYXNCaW5hcnkob2JqW2tleV0pKSB7XG5cdFx0XHQgIHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdCAgfVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICByZXR1cm4gX2hhc0JpbmFyeShkYXRhKTtcblx0fVxuXG5cdH0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxuXHR9LHtcImlzYXJyYXlcIjoyNH1dLDIyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqXG5cdCAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuXHQgKlxuXHQgKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcblx0ICovXG5cblx0dHJ5IHtcblx0ICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0XHQnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdCAgLy8gaWYgWE1MSHR0cCBzdXBwb3J0IGlzIGRpc2FibGVkIGluIElFIHRoZW4gaXQgd2lsbCB0aHJvd1xuXHQgIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxuXHQgIG1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG5cdH1cblxuXHR9LHt9XSwyMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cblx0dmFyIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuXHQgIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuXHRcdGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG5cdCAgfVxuXHQgIHJldHVybiAtMTtcblx0fTtcblx0fSx7fV0sMjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHRtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuXHQgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xuXHR9O1xuXG5cdH0se31dLDI1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblx0LyoqXG5cdCAqIEhlbHBlcnMuXG5cdCAqL1xuXG5cdHZhciBzID0gMTAwMDtcblx0dmFyIG0gPSBzICogNjA7XG5cdHZhciBoID0gbSAqIDYwO1xuXHR2YXIgZCA9IGggKiAyNDtcblx0dmFyIHkgPSBkICogMzY1LjI1O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuXHQgKlxuXHQgKiBPcHRpb25zOlxuXHQgKlxuXHQgKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpe1xuXHQgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHQgIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdmFsKSByZXR1cm4gcGFyc2UodmFsKTtcblx0ICByZXR1cm4gb3B0aW9ucy5sb25nXG5cdFx0PyBsb25nKHZhbClcblx0XHQ6IHNob3J0KHZhbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBwYXJzZShzdHIpIHtcblx0ICBzdHIgPSAnJyArIHN0cjtcblx0ICBpZiAoc3RyLmxlbmd0aCA+IDEwMDAwKSByZXR1cm47XG5cdCAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuXHQgIGlmICghbWF0Y2gpIHJldHVybjtcblx0ICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuXHQgIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG5cdCAgc3dpdGNoICh0eXBlKSB7XG5cdFx0Y2FzZSAneWVhcnMnOlxuXHRcdGNhc2UgJ3llYXInOlxuXHRcdGNhc2UgJ3lycyc6XG5cdFx0Y2FzZSAneXInOlxuXHRcdGNhc2UgJ3knOlxuXHRcdCAgcmV0dXJuIG4gKiB5O1xuXHRcdGNhc2UgJ2RheXMnOlxuXHRcdGNhc2UgJ2RheSc6XG5cdFx0Y2FzZSAnZCc6XG5cdFx0ICByZXR1cm4gbiAqIGQ7XG5cdFx0Y2FzZSAnaG91cnMnOlxuXHRcdGNhc2UgJ2hvdXInOlxuXHRcdGNhc2UgJ2hycyc6XG5cdFx0Y2FzZSAnaHInOlxuXHRcdGNhc2UgJ2gnOlxuXHRcdCAgcmV0dXJuIG4gKiBoO1xuXHRcdGNhc2UgJ21pbnV0ZXMnOlxuXHRcdGNhc2UgJ21pbnV0ZSc6XG5cdFx0Y2FzZSAnbWlucyc6XG5cdFx0Y2FzZSAnbWluJzpcblx0XHRjYXNlICdtJzpcblx0XHQgIHJldHVybiBuICogbTtcblx0XHRjYXNlICdzZWNvbmRzJzpcblx0XHRjYXNlICdzZWNvbmQnOlxuXHRcdGNhc2UgJ3NlY3MnOlxuXHRcdGNhc2UgJ3NlYyc6XG5cdFx0Y2FzZSAncyc6XG5cdFx0ICByZXR1cm4gbiAqIHM7XG5cdFx0Y2FzZSAnbWlsbGlzZWNvbmRzJzpcblx0XHRjYXNlICdtaWxsaXNlY29uZCc6XG5cdFx0Y2FzZSAnbXNlY3MnOlxuXHRcdGNhc2UgJ21zZWMnOlxuXHRcdGNhc2UgJ21zJzpcblx0XHQgIHJldHVybiBuO1xuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBzaG9ydChtcykge1xuXHQgIGlmIChtcyA+PSBkKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuXHQgIGlmIChtcyA+PSBoKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuXHQgIGlmIChtcyA+PSBtKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuXHQgIGlmIChtcyA+PSBzKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuXHQgIHJldHVybiBtcyArICdtcyc7XG5cdH1cblxuXHQvKipcblx0ICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBsb25nKG1zKSB7XG5cdCAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpXG5cdFx0fHwgcGx1cmFsKG1zLCBoLCAnaG91cicpXG5cdFx0fHwgcGx1cmFsKG1zLCBtLCAnbWludXRlJylcblx0XHR8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKVxuXHRcdHx8IG1zICsgJyBtcyc7XG5cdH1cblxuXHQvKipcblx0ICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuXHQgIGlmIChtcyA8IG4pIHJldHVybjtcblx0ICBpZiAobXMgPCBuICogMS41KSByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcblx0ICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xuXHR9XG5cblx0fSx7fV0sMjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQoZnVuY3Rpb24gKGdsb2JhbCl7XG5cdC8qKlxuXHQgKiBKU09OIHBhcnNlLlxuXHQgKlxuXHQgKiBAc2VlIEJhc2VkIG9uIGpRdWVyeSNwYXJzZUpTT04gKE1JVCkgYW5kIEpTT04yXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHR2YXIgcnZhbGlkY2hhcnMgPSAvXltcXF0sOnt9XFxzXSokLztcblx0dmFyIHJ2YWxpZGVzY2FwZSA9IC9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1WzAtOWEtZkEtRl17NH0pL2c7XG5cdHZhciBydmFsaWR0b2tlbnMgPSAvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2c7XG5cdHZhciBydmFsaWRicmFjZXMgPSAvKD86Xnw6fCwpKD86XFxzKlxcWykrL2c7XG5cdHZhciBydHJpbUxlZnQgPSAvXlxccysvO1xuXHR2YXIgcnRyaW1SaWdodCA9IC9cXHMrJC87XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZWpzb24oZGF0YSkge1xuXHQgIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgZGF0YSB8fCAhZGF0YSkge1xuXHRcdHJldHVybiBudWxsO1xuXHQgIH1cblxuXHQgIGRhdGEgPSBkYXRhLnJlcGxhY2UocnRyaW1MZWZ0LCAnJykucmVwbGFjZShydHJpbVJpZ2h0LCAnJyk7XG5cblx0ICAvLyBBdHRlbXB0IHRvIHBhcnNlIHVzaW5nIHRoZSBuYXRpdmUgSlNPTiBwYXJzZXIgZmlyc3Rcblx0ICBpZiAoZ2xvYmFsLkpTT04gJiYgSlNPTi5wYXJzZSkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuXHQgIH1cblxuXHQgIGlmIChydmFsaWRjaGFycy50ZXN0KGRhdGEucmVwbGFjZShydmFsaWRlc2NhcGUsICdAJylcblx0XHQgIC5yZXBsYWNlKHJ2YWxpZHRva2VucywgJ10nKVxuXHRcdCAgLnJlcGxhY2UocnZhbGlkYnJhY2VzLCAnJykpKSB7XG5cdFx0cmV0dXJuIChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgZGF0YSkpKCk7XG5cdCAgfVxuXHR9O1xuXHR9KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcblx0fSx7fV0sMjc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQvKipcblx0ICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xuXHQgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAob2JqKSB7XG5cdCAgdmFyIHN0ciA9ICcnO1xuXG5cdCAgZm9yICh2YXIgaSBpbiBvYmopIHtcblx0XHRpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0ICBpZiAoc3RyLmxlbmd0aCkgc3RyICs9ICcmJztcblx0XHQgIHN0ciArPSBlbmNvZGVVUklDb21wb25lbnQoaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKTtcblx0XHR9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHN0cjtcblx0fTtcblxuXHQvKipcblx0ICogUGFyc2VzIGEgc2ltcGxlIHF1ZXJ5c3RyaW5nIGludG8gYW4gb2JqZWN0XG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBxc1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XG5cdCAgdmFyIHFyeSA9IHt9O1xuXHQgIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XG5cdCAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHR2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XG5cdFx0cXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG5cdCAgfVxuXHQgIHJldHVybiBxcnk7XG5cdH07XG5cblx0fSx7fV0sMjg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQvKipcblx0ICogUGFyc2VzIGFuIFVSSVxuXHQgKlxuXHQgKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHR2YXIgcmUgPSAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLztcblxuXHR2YXIgcGFydHMgPSBbXG5cdFx0J3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXG5cdF07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZXVyaShzdHIpIHtcblx0XHR2YXIgc3JjID0gc3RyLFxuXHRcdFx0YiA9IHN0ci5pbmRleE9mKCdbJyksXG5cdFx0XHRlID0gc3RyLmluZGV4T2YoJ10nKTtcblxuXHRcdGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcblx0XHRcdHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgYikgKyBzdHIuc3Vic3RyaW5nKGIsIGUpLnJlcGxhY2UoLzovZywgJzsnKSArIHN0ci5zdWJzdHJpbmcoZSwgc3RyLmxlbmd0aCk7XG5cdFx0fVxuXG5cdFx0dmFyIG0gPSByZS5leGVjKHN0ciB8fCAnJyksXG5cdFx0XHR1cmkgPSB7fSxcblx0XHRcdGkgPSAxNDtcblxuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xuXHRcdH1cblxuXHRcdGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcblx0XHRcdHVyaS5zb3VyY2UgPSBzcmM7XG5cdFx0XHR1cmkuaG9zdCA9IHVyaS5ob3N0LnN1YnN0cmluZygxLCB1cmkuaG9zdC5sZW5ndGggLSAxKS5yZXBsYWNlKC87L2csICc6Jyk7XG5cdFx0XHR1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xuXHRcdFx0dXJpLmlwdjZ1cmkgPSB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiB1cmk7XG5cdH07XG5cblx0fSx7fV0sMjk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQoZnVuY3Rpb24gKGdsb2JhbCl7XG5cdC8qISBodHRwczovL210aHMuYmUvdXRmOGpzIHYyLjAuMCBieSBAbWF0aGlhcyAqL1xuXHQ7KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHRcdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlcyBgZXhwb3J0c2Bcblx0XHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG5cdFx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWBcblx0XHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cblx0XHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLFxuXHRcdC8vIGFuZCB1c2UgaXQgYXMgYHJvb3RgXG5cdFx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0XHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHRcdH1cblxuXHRcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdFx0dmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cblx0XHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRcdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gW107XG5cdFx0XHR2YXIgY291bnRlciA9IDA7XG5cdFx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdHZhciBleHRyYTtcblx0XHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0XHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0XHR2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0XHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHRcdH1cblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KSB7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4RDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhERkZGKSB7XG5cdFx0XHRcdHRocm93IEVycm9yKFxuXHRcdFx0XHRcdCdMb25lIHN1cnJvZ2F0ZSBVKycgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgK1xuXHRcdFx0XHRcdCcgaXMgbm90IGEgc2NhbGFyIHZhbHVlJ1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRcdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiBzaGlmdCkgJiAweDNGKSB8IDB4ODApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcblx0XHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHN5bWJvbCA9ICcnO1xuXHRcdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0XHRcdGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KTtcblx0XHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XG5cdFx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkUwMDAwMCkgPT0gMCkgeyAvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCk7XG5cdFx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdFx0fVxuXHRcdFx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0XHRcdHJldHVybiBzeW1ib2w7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcpIHtcblx0XHRcdHZhciBjb2RlUG9pbnRzID0gdWNzMmRlY29kZShzdHJpbmcpO1xuXHRcdFx0dmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuXHRcdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0XHR2YXIgY29kZVBvaW50O1xuXHRcdFx0dmFyIGJ5dGVTdHJpbmcgPSAnJztcblx0XHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRcdGNvZGVQb2ludCA9IGNvZGVQb2ludHNbaW5kZXhdO1xuXHRcdFx0XHRieXRlU3RyaW5nICs9IGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJ5dGVTdHJpbmc7XG5cdFx0fVxuXG5cdFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0XHRmdW5jdGlvbiByZWFkQ29udGludWF0aW9uQnl0ZSgpIHtcblx0XHRcdGlmIChieXRlSW5kZXggPj0gYnl0ZUNvdW50KSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGNvbnRpbnVhdGlvbkJ5dGUgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0XHRieXRlSW5kZXgrKztcblxuXHRcdFx0aWYgKChjb250aW51YXRpb25CeXRlICYgMHhDMCkgPT0gMHg4MCkge1xuXHRcdFx0XHRyZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdOKAmXMgbm90IGEgY29udGludWF0aW9uIGJ5dGVcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVjb2RlU3ltYm9sKCkge1xuXHRcdFx0dmFyIGJ5dGUxO1xuXHRcdFx0dmFyIGJ5dGUyO1xuXHRcdFx0dmFyIGJ5dGUzO1xuXHRcdFx0dmFyIGJ5dGU0O1xuXHRcdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdFx0aWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChieXRlSW5kZXggPT0gYnl0ZUNvdW50KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVhZCBmaXJzdCBieXRlXG5cdFx0XHRieXRlMSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0XHQvLyAxLWJ5dGUgc2VxdWVuY2UgKG5vIGNvbnRpbnVhdGlvbiBieXRlcylcblx0XHRcdGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG5cdFx0XHRcdHJldHVybiBieXRlMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0XHR2YXIgYnl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgxRikgPDwgNikgfCBieXRlMjtcblx0XHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDgwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcblx0XHRcdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwODAwKSB7XG5cdFx0XHRcdFx0Y2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpO1xuXHRcdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRcdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHRcdFx0KGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG5cdFx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xuXHRcdH1cblxuXHRcdHZhciBieXRlQXJyYXk7XG5cdFx0dmFyIGJ5dGVDb3VudDtcblx0XHR2YXIgYnl0ZUluZGV4O1xuXHRcdGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnl0ZVN0cmluZykge1xuXHRcdFx0Ynl0ZUFycmF5ID0gdWNzMmRlY29kZShieXRlU3RyaW5nKTtcblx0XHRcdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdFx0XHRieXRlSW5kZXggPSAwO1xuXHRcdFx0dmFyIGNvZGVQb2ludHMgPSBbXTtcblx0XHRcdHZhciB0bXA7XG5cdFx0XHR3aGlsZSAoKHRtcCA9IGRlY29kZVN5bWJvbCgpKSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0Y29kZVBvaW50cy5wdXNoKHRtcCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdWNzMmVuY29kZShjb2RlUG9pbnRzKTtcblx0XHR9XG5cblx0XHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRcdHZhciB1dGY4ID0ge1xuXHRcdFx0J3ZlcnNpb24nOiAnMi4wLjAnLFxuXHRcdFx0J2VuY29kZSc6IHV0ZjhlbmNvZGUsXG5cdFx0XHQnZGVjb2RlJzogdXRmOGRlY29kZVxuXHRcdH07XG5cblx0XHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0XHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdFx0aWYgKFxuXHRcdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdFx0ZGVmaW5lLmFtZFxuXHRcdCkge1xuXHRcdFx0ZGVmaW5lKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdXRmODtcblx0XHRcdH0pO1xuXHRcdH1cdGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xuXHRcdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gdXRmODtcblx0XHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRcdHZhciBvYmplY3QgPSB7fTtcblx0XHRcdFx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gdXRmOCkge1xuXHRcdFx0XHRcdGhhc093blByb3BlcnR5LmNhbGwodXRmOCwga2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHV0Zjhba2V5XSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0XHRyb290LnV0ZjggPSB1dGY4O1xuXHRcdH1cblxuXHR9KHRoaXMpKTtcblxuXHR9KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcblx0fSx7fV0sMzA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LV8nLnNwbGl0KCcnKVxuXHQgICwgbGVuZ3RoID0gNjRcblx0ICAsIG1hcCA9IHt9XG5cdCAgLCBzZWVkID0gMFxuXHQgICwgaSA9IDBcblx0ICAsIHByZXY7XG5cblx0LyoqXG5cdCAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBudW1iZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIuXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUobnVtKSB7XG5cdCAgdmFyIGVuY29kZWQgPSAnJztcblxuXHQgIGRvIHtcblx0XHRlbmNvZGVkID0gYWxwaGFiZXRbbnVtICUgbGVuZ3RoXSArIGVuY29kZWQ7XG5cdFx0bnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuXHQgIH0gd2hpbGUgKG51bSA+IDApO1xuXG5cdCAgcmV0dXJuIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBpbnRlZ2VyIHZhbHVlIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gc3RyaW5nLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gY29udmVydC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGludGVnZXIgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZy5cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShzdHIpIHtcblx0ICB2YXIgZGVjb2RlZCA9IDA7XG5cblx0ICBmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG5cdFx0ZGVjb2RlZCA9IGRlY29kZWQgKiBsZW5ndGggKyBtYXBbc3RyLmNoYXJBdChpKV07XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGRlY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogWWVhc3Q6IEEgdGlueSBncm93aW5nIGlkIGdlbmVyYXRvci5cblx0ICpcblx0ICogQHJldHVybnMge1N0cmluZ30gQSB1bmlxdWUgaWQuXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRmdW5jdGlvbiB5ZWFzdCgpIHtcblx0ICB2YXIgbm93ID0gZW5jb2RlKCtuZXcgRGF0ZSgpKTtcblxuXHQgIGlmIChub3cgIT09IHByZXYpIHJldHVybiBzZWVkID0gMCwgcHJldiA9IG5vdztcblx0ICByZXR1cm4gbm93ICsnLicrIGVuY29kZShzZWVkKyspO1xuXHR9XG5cblx0Ly9cblx0Ly8gTWFwIGVhY2ggY2hhcmFjdGVyIHRvIGl0cyBpbmRleC5cblx0Ly9cblx0Zm9yICg7IGkgPCBsZW5ndGg7IGkrKykgbWFwW2FscGhhYmV0W2ldXSA9IGk7XG5cblx0Ly9cblx0Ly8gRXhwb3NlIHRoZSBgeWVhc3RgLCBgZW5jb2RlYCBhbmQgYGRlY29kZWAgZnVuY3Rpb25zLlxuXHQvL1xuXHR5ZWFzdC5lbmNvZGUgPSBlbmNvZGU7XG5cdHllYXN0LmRlY29kZSA9IGRlY29kZTtcblx0bW9kdWxlLmV4cG9ydHMgPSB5ZWFzdDtcblxuXHR9LHt9XSwzMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciB1cmwgPSBfZGVyZXFfKCcuL3VybCcpO1xuXHR2YXIgcGFyc2VyID0gX2RlcmVxXygnc29ja2V0LmlvLXBhcnNlcicpO1xuXHR2YXIgTWFuYWdlciA9IF9kZXJlcV8oJy4vbWFuYWdlcicpO1xuXHR2YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Jyk7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBsb29rdXA7XG5cblx0LyoqXG5cdCAqIE1hbmFnZXJzIGNhY2hlLlxuXHQgKi9cblxuXHR2YXIgY2FjaGUgPSBleHBvcnRzLm1hbmFnZXJzID0ge307XG5cblx0LyoqXG5cdCAqIExvb2tzIHVwIGFuIGV4aXN0aW5nIGBNYW5hZ2VyYCBmb3IgbXVsdGlwbGV4aW5nLlxuXHQgKiBJZiB0aGUgdXNlciBzdW1tb25zOlxuXHQgKlxuXHQgKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9hJyk7YFxuXHQgKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9iJyk7YFxuXHQgKlxuXHQgKiBXZSByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UgYmFzZWQgb24gc2FtZSBzY2hlbWUvcG9ydC9ob3N0LFxuXHQgKiBhbmQgd2UgaW5pdGlhbGl6ZSBzb2NrZXRzIGZvciBlYWNoIG5hbWVzcGFjZS5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gbG9va3VwKHVyaSwgb3B0cykge1xuXHQgIGlmICh0eXBlb2YgdXJpID09ICdvYmplY3QnKSB7XG5cdFx0b3B0cyA9IHVyaTtcblx0XHR1cmkgPSB1bmRlZmluZWQ7XG5cdCAgfVxuXG5cdCAgb3B0cyA9IG9wdHMgfHwge307XG5cblx0ICB2YXIgcGFyc2VkID0gdXJsKHVyaSk7XG5cdCAgdmFyIHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG5cdCAgdmFyIGlkID0gcGFyc2VkLmlkO1xuXHQgIHZhciBwYXRoID0gcGFyc2VkLnBhdGg7XG5cdCAgdmFyIHNhbWVOYW1lc3BhY2UgPSBjYWNoZVtpZF0gJiYgcGF0aCBpbiBjYWNoZVtpZF0ubnNwcztcblx0ICB2YXIgbmV3Q29ubmVjdGlvbiA9IG9wdHMuZm9yY2VOZXcgfHwgb3B0c1snZm9yY2UgbmV3IGNvbm5lY3Rpb24nXSB8fFxuXHRcdFx0XHRcdFx0ICBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXggfHwgc2FtZU5hbWVzcGFjZTtcblxuXHQgIHZhciBpbztcblxuXHQgIGlmIChuZXdDb25uZWN0aW9uKSB7XG5cdFx0ZGVidWcoJ2lnbm9yaW5nIHNvY2tldCBjYWNoZSBmb3IgJXMnLCBzb3VyY2UpO1xuXHRcdGlvID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuXHQgIH0gZWxzZSB7XG5cdFx0aWYgKCFjYWNoZVtpZF0pIHtcblx0XHQgIGRlYnVnKCduZXcgaW8gaW5zdGFuY2UgZm9yICVzJywgc291cmNlKTtcblx0XHQgIGNhY2hlW2lkXSA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcblx0XHR9XG5cdFx0aW8gPSBjYWNoZVtpZF07XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCk7XG5cdH1cblxuXHQvKipcblx0ICogUHJvdG9jb2wgdmVyc2lvbi5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDtcblxuXHQvKipcblx0ICogYGNvbm5lY3RgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdXJpXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMuY29ubmVjdCA9IGxvb2t1cDtcblxuXHQvKipcblx0ICogRXhwb3NlIGNvbnN0cnVjdG9ycyBmb3Igc3RhbmRhbG9uZSBidWlsZC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5NYW5hZ2VyID0gX2RlcmVxXygnLi9tYW5hZ2VyJyk7XG5cdGV4cG9ydHMuU29ja2V0ID0gX2RlcmVxXygnLi9zb2NrZXQnKTtcblxuXHR9LHtcIi4vbWFuYWdlclwiOjMyLFwiLi9zb2NrZXRcIjozNCxcIi4vdXJsXCI6MzUsXCJkZWJ1Z1wiOjM5LFwic29ja2V0LmlvLXBhcnNlclwiOjQ3fV0sMzI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblxuXHR2YXIgZWlvID0gX2RlcmVxXygnZW5naW5lLmlvLWNsaWVudCcpO1xuXHR2YXIgU29ja2V0ID0gX2RlcmVxXygnLi9zb2NrZXQnKTtcblx0dmFyIEVtaXR0ZXIgPSBfZGVyZXFfKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXHR2YXIgcGFyc2VyID0gX2RlcmVxXygnc29ja2V0LmlvLXBhcnNlcicpO1xuXHR2YXIgb24gPSBfZGVyZXFfKCcuL29uJyk7XG5cdHZhciBiaW5kID0gX2RlcmVxXygnY29tcG9uZW50LWJpbmQnKTtcblx0dmFyIGRlYnVnID0gX2RlcmVxXygnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDptYW5hZ2VyJyk7XG5cdHZhciBpbmRleE9mID0gX2RlcmVxXygnaW5kZXhvZicpO1xuXHR2YXIgQmFja29mZiA9IF9kZXJlcV8oJ2JhY2tvMicpO1xuXG5cdC8qKlxuXHQgKiBJRTYrIGhhc093blByb3BlcnR5XG5cdCAqL1xuXG5cdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0c1xuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IE1hbmFnZXI7XG5cblx0LyoqXG5cdCAqIGBNYW5hZ2VyYCBjb25zdHJ1Y3Rvci5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGVuZ2luZSBpbnN0YW5jZSBvciBlbmdpbmUgdXJpL29wdHNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gTWFuYWdlcih1cmksIG9wdHMpe1xuXHQgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYW5hZ2VyKSkgcmV0dXJuIG5ldyBNYW5hZ2VyKHVyaSwgb3B0cyk7XG5cdCAgaWYgKHVyaSAmJiAoJ29iamVjdCcgPT0gdHlwZW9mIHVyaSkpIHtcblx0XHRvcHRzID0gdXJpO1xuXHRcdHVyaSA9IHVuZGVmaW5lZDtcblx0ICB9XG5cdCAgb3B0cyA9IG9wdHMgfHwge307XG5cblx0ICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgJy9zb2NrZXQuaW8nO1xuXHQgIHRoaXMubnNwcyA9IHt9O1xuXHQgIHRoaXMuc3VicyA9IFtdO1xuXHQgIHRoaXMub3B0cyA9IG9wdHM7XG5cdCAgdGhpcy5yZWNvbm5lY3Rpb24ob3B0cy5yZWNvbm5lY3Rpb24gIT09IGZhbHNlKTtcblx0ICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuXHQgIHRoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheSB8fCAxMDAwKTtcblx0ICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KG9wdHMucmVjb25uZWN0aW9uRGVsYXlNYXggfHwgNTAwMCk7XG5cdCAgdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKG9wdHMucmFuZG9taXphdGlvbkZhY3RvciB8fCAwLjUpO1xuXHQgIHRoaXMuYmFja29mZiA9IG5ldyBCYWNrb2ZmKHtcblx0XHRtaW46IHRoaXMucmVjb25uZWN0aW9uRGVsYXkoKSxcblx0XHRtYXg6IHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgoKSxcblx0XHRqaXR0ZXI6IHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigpXG5cdCAgfSk7XG5cdCAgdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXHQgIHRoaXMudXJpID0gdXJpO1xuXHQgIHRoaXMuY29ubmVjdGluZyA9IFtdO1xuXHQgIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuXHQgIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcblx0ICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuXHQgIHRoaXMuZW5jb2RlciA9IG5ldyBwYXJzZXIuRW5jb2RlcigpO1xuXHQgIHRoaXMuZGVjb2RlciA9IG5ldyBwYXJzZXIuRGVjb2RlcigpO1xuXHQgIHRoaXMuYXV0b0Nvbm5lY3QgPSBvcHRzLmF1dG9Db25uZWN0ICE9PSBmYWxzZTtcblx0ICBpZiAodGhpcy5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG5cdH1cblxuXHQvKipcblx0ICogUHJvcGFnYXRlIGdpdmVuIGV2ZW50IHRvIHNvY2tldHMgYW5kIGVtaXQgb24gYHRoaXNgXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5lbWl0QWxsID0gZnVuY3Rpb24oKSB7XG5cdCAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuXHRcdGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcblx0XHQgIHRoaXMubnNwc1tuc3BdLmVtaXQuYXBwbHkodGhpcy5uc3BzW25zcF0sIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogVXBkYXRlIGBzb2NrZXQuaWRgIG9mIGFsbCBzb2NrZXRzXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTb2NrZXRJZHMgPSBmdW5jdGlvbigpe1xuXHQgIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcblx0XHRpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG5cdFx0ICB0aGlzLm5zcHNbbnNwXS5pZCA9IHRoaXMuZW5naW5lLmlkO1xuXHRcdH1cblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIE1peCBpbiBgRW1pdHRlcmAuXG5cdCAqL1xuXG5cdEVtaXR0ZXIoTWFuYWdlci5wcm90b3R5cGUpO1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBgcmVjb25uZWN0aW9uYCBjb25maWcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiBpdCBzaG91bGQgYXV0b21hdGljYWxseSByZWNvbm5lY3Rcblx0ICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb24gPSBmdW5jdGlvbih2KXtcblx0ICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb247XG5cdCAgdGhpcy5fcmVjb25uZWN0aW9uID0gISF2O1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgY29uZmlnLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gbWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyBiZWZvcmUgZ2l2aW5nIHVwXG5cdCAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uQXR0ZW1wdHMgPSBmdW5jdGlvbih2KXtcblx0ICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cztcblx0ICB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHY7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG5cdCAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXkgPSBmdW5jdGlvbih2KXtcblx0ICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheTtcblx0ICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG5cdCAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNaW4odik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0TWFuYWdlci5wcm90b3R5cGUucmFuZG9taXphdGlvbkZhY3RvciA9IGZ1bmN0aW9uKHYpe1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I7XG5cdCAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG5cdCAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRKaXR0ZXIodik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcblx0ICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheU1heCA9IGZ1bmN0aW9uKHYpe1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuXHQgIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4ID0gdjtcblx0ICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1heCh2KTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgY29ubmVjdGlvbiB0aW1lb3V0LiBgZmFsc2VgIHRvIGRpc2FibGVcblx0ICpcblx0ICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24odil7XG5cdCAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGltZW91dDtcblx0ICB0aGlzLl90aW1lb3V0ID0gdjtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU3RhcnRzIHRyeWluZyB0byByZWNvbm5lY3QgaWYgcmVjb25uZWN0aW9uIGlzIGVuYWJsZWQgYW5kIHdlIGhhdmUgbm90XG5cdCAqIHN0YXJ0ZWQgcmVjb25uZWN0aW5nIHlldFxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUubWF5YmVSZWNvbm5lY3RPbk9wZW4gPSBmdW5jdGlvbigpIHtcblx0ICAvLyBPbmx5IHRyeSB0byByZWNvbm5lY3QgaWYgaXQncyB0aGUgZmlyc3QgdGltZSB3ZSdyZSBjb25uZWN0aW5nXG5cdCAgaWYgKCF0aGlzLnJlY29ubmVjdGluZyAmJiB0aGlzLl9yZWNvbm5lY3Rpb24gJiYgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG5cdFx0Ly8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuXHRcdHRoaXMucmVjb25uZWN0KCk7XG5cdCAgfVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0IGBzb2NrZXRgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCwgY2FsbGJhY2tcblx0ICogQHJldHVybiB7TWFuYWdlcn0gc2VsZlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vcGVuID1cblx0TWFuYWdlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKGZuKXtcblx0ICBkZWJ1ZygncmVhZHlTdGF0ZSAlcycsIHRoaXMucmVhZHlTdGF0ZSk7XG5cdCAgaWYgKH50aGlzLnJlYWR5U3RhdGUuaW5kZXhPZignb3BlbicpKSByZXR1cm4gdGhpcztcblxuXHQgIGRlYnVnKCdvcGVuaW5nICVzJywgdGhpcy51cmkpO1xuXHQgIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuXHQgIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXHQgIHRoaXMuc2tpcFJlY29ubmVjdCA9IGZhbHNlO1xuXG5cdCAgLy8gZW1pdCBgb3BlbmBcblx0ICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbigpIHtcblx0XHRzZWxmLm9ub3BlbigpO1xuXHRcdGZuICYmIGZuKCk7XG5cdCAgfSk7XG5cblx0ICAvLyBlbWl0IGBjb25uZWN0X2Vycm9yYFxuXHQgIHZhciBlcnJvclN1YiA9IG9uKHNvY2tldCwgJ2Vycm9yJywgZnVuY3Rpb24oZGF0YSl7XG5cdFx0ZGVidWcoJ2Nvbm5lY3RfZXJyb3InKTtcblx0XHRzZWxmLmNsZWFudXAoKTtcblx0XHRzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblx0XHRzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcblx0XHRpZiAoZm4pIHtcblx0XHQgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcblx0XHQgIGVyci5kYXRhID0gZGF0YTtcblx0XHQgIGZuKGVycik7XG5cdFx0fSBlbHNlIHtcblx0XHQgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG5cdFx0ICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG5cdFx0fVxuXHQgIH0pO1xuXG5cdCAgLy8gZW1pdCBgY29ubmVjdF90aW1lb3V0YFxuXHQgIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuXHRcdHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcblx0XHRkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuXG5cdFx0Ly8gc2V0IHRpbWVyXG5cdFx0dmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdCAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB0aW1lZCBvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcblx0XHQgIG9wZW5TdWIuZGVzdHJveSgpO1xuXHRcdCAgc29ja2V0LmNsb3NlKCk7XG5cdFx0ICBzb2NrZXQuZW1pdCgnZXJyb3InLCAndGltZW91dCcpO1xuXHRcdCAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X3RpbWVvdXQnLCB0aW1lb3V0KTtcblx0XHR9LCB0aW1lb3V0KTtcblxuXHRcdHRoaXMuc3Vicy5wdXNoKHtcblx0XHQgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXHRcdCAgfVxuXHRcdH0pO1xuXHQgIH1cblxuXHQgIHRoaXMuc3Vicy5wdXNoKG9wZW5TdWIpO1xuXHQgIHRoaXMuc3Vicy5wdXNoKGVycm9yU3ViKTtcblxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgb3Blbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG5cdCAgZGVidWcoJ29wZW4nKTtcblxuXHQgIC8vIGNsZWFyIG9sZCBzdWJzXG5cdCAgdGhpcy5jbGVhbnVwKCk7XG5cblx0ICAvLyBtYXJrIGFzIG9wZW5cblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG5cdCAgdGhpcy5lbWl0KCdvcGVuJyk7XG5cblx0ICAvLyBhZGQgbmV3IHN1YnNcblx0ICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG5cdCAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZGF0YScsIGJpbmQodGhpcywgJ29uZGF0YScpKSk7XG5cdCAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncGluZycsIGJpbmQodGhpcywgJ29ucGluZycpKSk7XG5cdCAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncG9uZycsIGJpbmQodGhpcywgJ29ucG9uZycpKSk7XG5cdCAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZXJyb3InLCBiaW5kKHRoaXMsICdvbmVycm9yJykpKTtcblx0ICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSkpO1xuXHQgIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBhIHBpbmcuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbnBpbmcgPSBmdW5jdGlvbigpe1xuXHQgIHRoaXMubGFzdFBpbmcgPSBuZXcgRGF0ZTtcblx0ICB0aGlzLmVtaXRBbGwoJ3BpbmcnKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gYSBwYWNrZXQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbnBvbmcgPSBmdW5jdGlvbigpe1xuXHQgIHRoaXMuZW1pdEFsbCgncG9uZycsIG5ldyBEYXRlIC0gdGhpcy5sYXN0UGluZyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aXRoIGRhdGEuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbmRhdGEgPSBmdW5jdGlvbihkYXRhKXtcblx0ICB0aGlzLmRlY29kZXIuYWRkKGRhdGEpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiBwYXJzZXIgZnVsbHkgZGVjb2RlcyBhIHBhY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLm9uZGVjb2RlZCA9IGZ1bmN0aW9uKHBhY2tldCkge1xuXHQgIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gc29ja2V0IGVycm9yLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uKGVycil7XG5cdCAgZGVidWcoJ2Vycm9yJywgZXJyKTtcblx0ICB0aGlzLmVtaXRBbGwoJ2Vycm9yJywgZXJyKTtcblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBzb2NrZXQgZm9yIHRoZSBnaXZlbiBgbnNwYC5cblx0ICpcblx0ICogQHJldHVybiB7U29ja2V0fVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5zb2NrZXQgPSBmdW5jdGlvbihuc3Ape1xuXHQgIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcblx0ICBpZiAoIXNvY2tldCkge1xuXHRcdHNvY2tldCA9IG5ldyBTb2NrZXQodGhpcywgbnNwKTtcblx0XHR0aGlzLm5zcHNbbnNwXSA9IHNvY2tldDtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0c29ja2V0Lm9uKCdjb25uZWN0aW5nJywgb25Db25uZWN0aW5nKTtcblx0XHRzb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbigpe1xuXHRcdCAgc29ja2V0LmlkID0gc2VsZi5lbmdpbmUuaWQ7XG5cdFx0fSk7XG5cblx0XHRpZiAodGhpcy5hdXRvQ29ubmVjdCkge1xuXHRcdCAgLy8gbWFudWFsbHkgY2FsbCBoZXJlIHNpbmNlIGNvbm5lY3RpbmcgZXZuZXQgaXMgZmlyZWQgYmVmb3JlIGxpc3RlbmluZ1xuXHRcdCAgb25Db25uZWN0aW5nKCk7XG5cdFx0fVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIG9uQ29ubmVjdGluZygpIHtcblx0XHRpZiAoIX5pbmRleE9mKHNlbGYuY29ubmVjdGluZywgc29ja2V0KSkge1xuXHRcdCAgc2VsZi5jb25uZWN0aW5nLnB1c2goc29ja2V0KTtcblx0XHR9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHNvY2tldDtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKHNvY2tldCl7XG5cdCAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLmNvbm5lY3RpbmcsIHNvY2tldCk7XG5cdCAgaWYgKH5pbmRleCkgdGhpcy5jb25uZWN0aW5nLnNwbGljZShpbmRleCwgMSk7XG5cdCAgaWYgKHRoaXMuY29ubmVjdGluZy5sZW5ndGgpIHJldHVybjtcblxuXHQgIHRoaXMuY2xvc2UoKTtcblx0fTtcblxuXHQvKipcblx0ICogV3JpdGVzIGEgcGFja2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuXHQgIGRlYnVnKCd3cml0aW5nIHBhY2tldCAlaicsIHBhY2tldCk7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgaWYgKCFzZWxmLmVuY29kaW5nKSB7XG5cdFx0Ly8gZW5jb2RlLCB0aGVuIHdyaXRlIHRvIGVuZ2luZSB3aXRoIHJlc3VsdFxuXHRcdHNlbGYuZW5jb2RpbmcgPSB0cnVlO1xuXHRcdHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0LCBmdW5jdGlvbihlbmNvZGVkUGFja2V0cykge1xuXHRcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2VsZi5lbmdpbmUud3JpdGUoZW5jb2RlZFBhY2tldHNbaV0sIHBhY2tldC5vcHRpb25zKTtcblx0XHQgIH1cblx0XHQgIHNlbGYuZW5jb2RpbmcgPSBmYWxzZTtcblx0XHQgIHNlbGYucHJvY2Vzc1BhY2tldFF1ZXVlKCk7XG5cdFx0fSk7XG5cdCAgfSBlbHNlIHsgLy8gYWRkIHBhY2tldCB0byB0aGUgcXVldWVcblx0XHRzZWxmLnBhY2tldEJ1ZmZlci5wdXNoKHBhY2tldCk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJZiBwYWNrZXQgYnVmZmVyIGlzIG5vbi1lbXB0eSwgYmVnaW5zIGVuY29kaW5nIHRoZVxuXHQgKiBuZXh0IHBhY2tldCBpbiBsaW5lLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1BhY2tldFF1ZXVlID0gZnVuY3Rpb24oKSB7XG5cdCAgaWYgKHRoaXMucGFja2V0QnVmZmVyLmxlbmd0aCA+IDAgJiYgIXRoaXMuZW5jb2RpbmcpIHtcblx0XHR2YXIgcGFjayA9IHRoaXMucGFja2V0QnVmZmVyLnNoaWZ0KCk7XG5cdFx0dGhpcy5wYWNrZXQocGFjayk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbigpe1xuXHQgIGRlYnVnKCdjbGVhbnVwJyk7XG5cblx0ICB2YXIgc3ViO1xuXHQgIHdoaWxlIChzdWIgPSB0aGlzLnN1YnMuc2hpZnQoKSkgc3ViLmRlc3Ryb3koKTtcblxuXHQgIHRoaXMucGFja2V0QnVmZmVyID0gW107XG5cdCAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuXHQgIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuXG5cdCAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUuY2xvc2UgPVxuXHRNYW5hZ2VyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcblx0ICBkZWJ1ZygnZGlzY29ubmVjdCcpO1xuXHQgIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG5cdCAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcblx0ICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHRcdC8vIGBvbmNsb3NlYCB3aWxsIG5vdCBmaXJlIGJlY2F1c2Vcblx0XHQvLyBhbiBvcGVuIGV2ZW50IG5ldmVyIGhhcHBlbmVkXG5cdFx0dGhpcy5jbGVhbnVwKCk7XG5cdCAgfVxuXHQgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXHQgIGlmICh0aGlzLmVuZ2luZSkgdGhpcy5lbmdpbmUuY2xvc2UoKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gZW5naW5lIGNsb3NlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbil7XG5cdCAgZGVidWcoJ29uY2xvc2UnKTtcblxuXHQgIHRoaXMuY2xlYW51cCgpO1xuXHQgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXHQgIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24pO1xuXG5cdCAgaWYgKHRoaXMuX3JlY29ubmVjdGlvbiAmJiAhdGhpcy5za2lwUmVjb25uZWN0KSB7XG5cdFx0dGhpcy5yZWNvbm5lY3QoKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEF0dGVtcHQgYSByZWNvbm5lY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbigpe1xuXHQgIGlmICh0aGlzLnJlY29ubmVjdGluZyB8fCB0aGlzLnNraXBSZWNvbm5lY3QpIHJldHVybiB0aGlzO1xuXG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuXHRcdGRlYnVnKCdyZWNvbm5lY3QgZmFpbGVkJyk7XG5cdFx0dGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG5cdFx0dGhpcy5lbWl0QWxsKCdyZWNvbm5lY3RfZmFpbGVkJyk7XG5cdFx0dGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcblx0ICB9IGVsc2Uge1xuXHRcdHZhciBkZWxheSA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuXHRcdGRlYnVnKCd3aWxsIHdhaXQgJWRtcyBiZWZvcmUgcmVjb25uZWN0IGF0dGVtcHQnLCBkZWxheSk7XG5cblx0XHR0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG5cdFx0dmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdCAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG5cdFx0ICBkZWJ1ZygnYXR0ZW1wdGluZyByZWNvbm5lY3QnKTtcblx0XHQgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2F0dGVtcHQnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuXHRcdCAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RpbmcnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuXG5cdFx0ICAvLyBjaGVjayBhZ2FpbiBmb3IgdGhlIGNhc2Ugc29ja2V0IGNsb3NlZCBpbiBhYm92ZSBldmVudHNcblx0XHQgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuXHRcdCAgc2VsZi5vcGVuKGZ1bmN0aW9uKGVycil7XG5cdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHQgIGRlYnVnKCdyZWNvbm5lY3QgYXR0ZW1wdCBlcnJvcicpO1xuXHRcdFx0ICBzZWxmLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuXHRcdFx0ICBzZWxmLnJlY29ubmVjdCgpO1xuXHRcdFx0ICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9lcnJvcicsIGVyci5kYXRhKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHQgIGRlYnVnKCdyZWNvbm5lY3Qgc3VjY2VzcycpO1xuXHRcdFx0ICBzZWxmLm9ucmVjb25uZWN0KCk7XG5cdFx0XHR9XG5cdFx0ICB9KTtcblx0XHR9LCBkZWxheSk7XG5cblx0XHR0aGlzLnN1YnMucHVzaCh7XG5cdFx0ICBkZXN0cm95OiBmdW5jdGlvbigpe1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHQgIH1cblx0XHR9KTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUub25yZWNvbm5lY3QgPSBmdW5jdGlvbigpe1xuXHQgIHZhciBhdHRlbXB0ID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzO1xuXHQgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG5cdCAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG5cdCAgdGhpcy51cGRhdGVTb2NrZXRJZHMoKTtcblx0ICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdCcsIGF0dGVtcHQpO1xuXHR9O1xuXG5cdH0se1wiLi9vblwiOjMzLFwiLi9zb2NrZXRcIjozNCxcImJhY2tvMlwiOjM2LFwiY29tcG9uZW50LWJpbmRcIjozNyxcImNvbXBvbmVudC1lbWl0dGVyXCI6MzgsXCJkZWJ1Z1wiOjM5LFwiZW5naW5lLmlvLWNsaWVudFwiOjEsXCJpbmRleG9mXCI6NDIsXCJzb2NrZXQuaW8tcGFyc2VyXCI6NDd9XSwzMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IG9uO1xuXG5cdC8qKlxuXHQgKiBIZWxwZXIgZm9yIHN1YnNjcmlwdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fEV2ZW50RW1pdHRlcn0gb2JqIHdpdGggYEVtaXR0ZXJgIG1peGluIG9yIGBFdmVudEVtaXR0ZXJgXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIG9uKG9iaiwgZXYsIGZuKSB7XG5cdCAgb2JqLm9uKGV2LCBmbik7XG5cdCAgcmV0dXJuIHtcblx0XHRkZXN0cm95OiBmdW5jdGlvbigpe1xuXHRcdCAgb2JqLnJlbW92ZUxpc3RlbmVyKGV2LCBmbik7XG5cdFx0fVxuXHQgIH07XG5cdH1cblxuXHR9LHt9XSwzNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciBwYXJzZXIgPSBfZGVyZXFfKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG5cdHZhciBFbWl0dGVyID0gX2RlcmVxXygnY29tcG9uZW50LWVtaXR0ZXInKTtcblx0dmFyIHRvQXJyYXkgPSBfZGVyZXFfKCd0by1hcnJheScpO1xuXHR2YXIgb24gPSBfZGVyZXFfKCcuL29uJyk7XG5cdHZhciBiaW5kID0gX2RlcmVxXygnY29tcG9uZW50LWJpbmQnKTtcblx0dmFyIGRlYnVnID0gX2RlcmVxXygnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDpzb2NrZXQnKTtcblx0dmFyIGhhc0JpbiA9IF9kZXJlcV8oJ2hhcy1iaW5hcnknKTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNvY2tldDtcblxuXHQvKipcblx0ICogSW50ZXJuYWwgZXZlbnRzIChibGFja2xpc3RlZCkuXG5cdCAqIFRoZXNlIGV2ZW50cyBjYW4ndCBiZSBlbWl0dGVkIGJ5IHRoZSB1c2VyLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0dmFyIGV2ZW50cyA9IHtcblx0ICBjb25uZWN0OiAxLFxuXHQgIGNvbm5lY3RfZXJyb3I6IDEsXG5cdCAgY29ubmVjdF90aW1lb3V0OiAxLFxuXHQgIGNvbm5lY3Rpbmc6IDEsXG5cdCAgZGlzY29ubmVjdDogMSxcblx0ICBlcnJvcjogMSxcblx0ICByZWNvbm5lY3Q6IDEsXG5cdCAgcmVjb25uZWN0X2F0dGVtcHQ6IDEsXG5cdCAgcmVjb25uZWN0X2ZhaWxlZDogMSxcblx0ICByZWNvbm5lY3RfZXJyb3I6IDEsXG5cdCAgcmVjb25uZWN0aW5nOiAxLFxuXHQgIHBpbmc6IDEsXG5cdCAgcG9uZzogMVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBgRW1pdHRlciNlbWl0YC5cblx0ICovXG5cblx0dmFyIGVtaXQgPSBFbWl0dGVyLnByb3RvdHlwZS5lbWl0O1xuXG5cdC8qKlxuXHQgKiBgU29ja2V0YCBjb25zdHJ1Y3Rvci5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gU29ja2V0KGlvLCBuc3Ape1xuXHQgIHRoaXMuaW8gPSBpbztcblx0ICB0aGlzLm5zcCA9IG5zcDtcblx0ICB0aGlzLmpzb24gPSB0aGlzOyAvLyBjb21wYXRcblx0ICB0aGlzLmlkcyA9IDA7XG5cdCAgdGhpcy5hY2tzID0ge307XG5cdCAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cdCAgdGhpcy5zZW5kQnVmZmVyID0gW107XG5cdCAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcblx0ICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG5cdCAgaWYgKHRoaXMuaW8uYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1peCBpbiBgRW1pdHRlcmAuXG5cdCAqL1xuXG5cdEVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cblx0LyoqXG5cdCAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5zdWJFdmVudHMgPSBmdW5jdGlvbigpIHtcblx0ICBpZiAodGhpcy5zdWJzKSByZXR1cm47XG5cblx0ICB2YXIgaW8gPSB0aGlzLmlvO1xuXHQgIHRoaXMuc3VicyA9IFtcblx0XHRvbihpbywgJ29wZW4nLCBiaW5kKHRoaXMsICdvbm9wZW4nKSksXG5cdFx0b24oaW8sICdwYWNrZXQnLCBiaW5kKHRoaXMsICdvbnBhY2tldCcpKSxcblx0XHRvbihpbywgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKVxuXHQgIF07XG5cdH07XG5cblx0LyoqXG5cdCAqIFwiT3BlbnNcIiB0aGUgc29ja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9wZW4gPVxuXHRTb2NrZXQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpe1xuXHQgIGlmICh0aGlzLmNvbm5lY3RlZCkgcmV0dXJuIHRoaXM7XG5cblx0ICB0aGlzLnN1YkV2ZW50cygpO1xuXHQgIHRoaXMuaW8ub3BlbigpOyAvLyBlbnN1cmUgb3BlblxuXHQgIGlmICgnb3BlbicgPT0gdGhpcy5pby5yZWFkeVN0YXRlKSB0aGlzLm9ub3BlbigpO1xuXHQgIHRoaXMuZW1pdCgnY29ubmVjdGluZycpO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cblx0ICpcblx0ICogQHJldHVybiB7U29ja2V0fSBzZWxmXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKCl7XG5cdCAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG5cdCAgYXJncy51bnNoaWZ0KCdtZXNzYWdlJyk7XG5cdCAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBPdmVycmlkZSBgZW1pdGAuXG5cdCAqIElmIHRoZSBldmVudCBpcyBpbiBgZXZlbnRzYCwgaXQncyBlbWl0dGVkIG5vcm1hbGx5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuXHQgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXYpe1xuXHQgIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG5cdFx0ZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHQgIH1cblxuXHQgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuXHQgIHZhciBwYXJzZXJUeXBlID0gcGFyc2VyLkVWRU5UOyAvLyBkZWZhdWx0XG5cdCAgaWYgKGhhc0JpbihhcmdzKSkgeyBwYXJzZXJUeXBlID0gcGFyc2VyLkJJTkFSWV9FVkVOVDsgfSAvLyBiaW5hcnlcblx0ICB2YXIgcGFja2V0ID0geyB0eXBlOiBwYXJzZXJUeXBlLCBkYXRhOiBhcmdzIH07XG5cblx0ICBwYWNrZXQub3B0aW9ucyA9IHt9O1xuXHQgIHBhY2tldC5vcHRpb25zLmNvbXByZXNzID0gIXRoaXMuZmxhZ3MgfHwgZmFsc2UgIT09IHRoaXMuZmxhZ3MuY29tcHJlc3M7XG5cblx0ICAvLyBldmVudCBhY2sgY2FsbGJhY2tcblx0ICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG5cdFx0ZGVidWcoJ2VtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZCcsIHRoaXMuaWRzKTtcblx0XHR0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcblx0XHRwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuXHQgIH1cblxuXHQgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuXHRcdHRoaXMucGFja2V0KHBhY2tldCk7XG5cdCAgfSBlbHNlIHtcblx0XHR0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuXHQgIH1cblxuXHQgIGRlbGV0ZSB0aGlzLmZsYWdzO1xuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNlbmRzIGEgcGFja2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG5cdCAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuXHQgIHRoaXMuaW8ucGFja2V0KHBhY2tldCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGVuZ2luZSBgb3BlbmAuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG5cdCAgZGVidWcoJ3RyYW5zcG9ydCBpcyBvcGVuIC0gY29ubmVjdGluZycpO1xuXG5cdCAgLy8gd3JpdGUgY29ubmVjdCBwYWNrZXQgaWYgbmVjZXNzYXJ5XG5cdCAgaWYgKCcvJyAhPSB0aGlzLm5zcCkge1xuXHRcdHRoaXMucGFja2V0KHsgdHlwZTogcGFyc2VyLkNPTk5FQ1QgfSk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBlbmdpbmUgYGNsb3NlYC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24ocmVhc29uKXtcblx0ICBkZWJ1ZygnY2xvc2UgKCVzKScsIHJlYXNvbik7XG5cdCAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcblx0ICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG5cdCAgZGVsZXRlIHRoaXMuaWQ7XG5cdCAgdGhpcy5lbWl0KCdkaXNjb25uZWN0JywgcmVhc29uKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdpdGggc29ja2V0IHBhY2tldC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG5cdCAgaWYgKHBhY2tldC5uc3AgIT0gdGhpcy5uc3ApIHJldHVybjtcblxuXHQgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcblx0XHRjYXNlIHBhcnNlci5DT05ORUNUOlxuXHRcdCAgdGhpcy5vbmNvbm5lY3QoKTtcblx0XHQgIGJyZWFrO1xuXG5cdFx0Y2FzZSBwYXJzZXIuRVZFTlQ6XG5cdFx0ICB0aGlzLm9uZXZlbnQocGFja2V0KTtcblx0XHQgIGJyZWFrO1xuXG5cdFx0Y2FzZSBwYXJzZXIuQklOQVJZX0VWRU5UOlxuXHRcdCAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG5cdFx0ICBicmVhaztcblxuXHRcdGNhc2UgcGFyc2VyLkFDSzpcblx0XHQgIHRoaXMub25hY2socGFja2V0KTtcblx0XHQgIGJyZWFrO1xuXG5cdFx0Y2FzZSBwYXJzZXIuQklOQVJZX0FDSzpcblx0XHQgIHRoaXMub25hY2socGFja2V0KTtcblx0XHQgIGJyZWFrO1xuXG5cdFx0Y2FzZSBwYXJzZXIuRElTQ09OTkVDVDpcblx0XHQgIHRoaXMub25kaXNjb25uZWN0KCk7XG5cdFx0ICBicmVhaztcblxuXHRcdGNhc2UgcGFyc2VyLkVSUk9SOlxuXHRcdCAgdGhpcy5lbWl0KCdlcnJvcicsIHBhY2tldC5kYXRhKTtcblx0XHQgIGJyZWFrO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUub25ldmVudCA9IGZ1bmN0aW9uKHBhY2tldCl7XG5cdCAgdmFyIGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcblx0ICBkZWJ1ZygnZW1pdHRpbmcgZXZlbnQgJWonLCBhcmdzKTtcblxuXHQgIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuXHRcdGRlYnVnKCdhdHRhY2hpbmcgYWNrIGNhbGxiYWNrIHRvIGV2ZW50Jyk7XG5cdFx0YXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpO1xuXHQgIH1cblxuXHQgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuXHRcdGVtaXQuYXBwbHkodGhpcywgYXJncyk7XG5cdCAgfSBlbHNlIHtcblx0XHR0aGlzLnJlY2VpdmVCdWZmZXIucHVzaChhcmdzKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLmFjayA9IGZ1bmN0aW9uKGlkKXtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgdmFyIHNlbnQgPSBmYWxzZTtcblx0ICByZXR1cm4gZnVuY3Rpb24oKXtcblx0XHQvLyBwcmV2ZW50IGRvdWJsZSBjYWxsYmFja3Ncblx0XHRpZiAoc2VudCkgcmV0dXJuO1xuXHRcdHNlbnQgPSB0cnVlO1xuXHRcdHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuXHRcdGRlYnVnKCdzZW5kaW5nIGFjayAlaicsIGFyZ3MpO1xuXG5cdFx0dmFyIHR5cGUgPSBoYXNCaW4oYXJncykgPyBwYXJzZXIuQklOQVJZX0FDSyA6IHBhcnNlci5BQ0s7XG5cdFx0c2VsZi5wYWNrZXQoe1xuXHRcdCAgdHlwZTogdHlwZSxcblx0XHQgIGlkOiBpZCxcblx0XHQgIGRhdGE6IGFyZ3Ncblx0XHR9KTtcblx0ICB9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBhY2tub3dsZWdlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbmFjayA9IGZ1bmN0aW9uKHBhY2tldCl7XG5cdCAgdmFyIGFjayA9IHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuXHQgIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBhY2spIHtcblx0XHRkZWJ1ZygnY2FsbGluZyBhY2sgJXMgd2l0aCAlaicsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuXHRcdGFjay5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG5cdFx0ZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuXHQgIH0gZWxzZSB7XG5cdFx0ZGVidWcoJ2JhZCBhY2sgJXMnLCBwYWNrZXQuaWQpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gc2VydmVyIGNvbm5lY3QuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9uY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG5cdCAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuXHQgIHRoaXMuZGlzY29ubmVjdGVkID0gZmFsc2U7XG5cdCAgdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG5cdCAgdGhpcy5lbWl0QnVmZmVyZWQoKTtcblx0fTtcblxuXHQvKipcblx0ICogRW1pdCBidWZmZXJlZCBldmVudHMgKHJlY2VpdmVkIGFuZCBlbWl0dGVkKS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUuZW1pdEJ1ZmZlcmVkID0gZnVuY3Rpb24oKXtcblx0ICB2YXIgaTtcblx0ICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG5cdFx0ZW1pdC5hcHBseSh0aGlzLCB0aGlzLnJlY2VpdmVCdWZmZXJbaV0pO1xuXHQgIH1cblx0ICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcblxuXHQgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBpKyspIHtcblx0XHR0aGlzLnBhY2tldCh0aGlzLnNlbmRCdWZmZXJbaV0pO1xuXHQgIH1cblx0ICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gc2VydmVyIGRpc2Nvbm5lY3QuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9uZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG5cdCAgZGVidWcoJ3NlcnZlciBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG5cdCAgdGhpcy5kZXN0cm95KCk7XG5cdCAgdGhpcy5vbmNsb3NlKCdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBmb3JjZWQgY2xpZW50L3NlcnZlciBzaWRlIGRpc2Nvbm5lY3Rpb25zLFxuXHQgKiB0aGlzIG1ldGhvZCBlbnN1cmVzIHRoZSBtYW5hZ2VyIHN0b3BzIHRyYWNraW5nIHVzIGFuZFxuXHQgKiB0aGF0IHJlY29ubmVjdGlvbnMgZG9uJ3QgZ2V0IHRyaWdnZXJlZCBmb3IgdGhpcy5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlLlxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuXHQgIGlmICh0aGlzLnN1YnMpIHtcblx0XHQvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vicy5sZW5ndGg7IGkrKykge1xuXHRcdCAgdGhpcy5zdWJzW2ldLmRlc3Ryb3koKTtcblx0XHR9XG5cdFx0dGhpcy5zdWJzID0gbnVsbDtcblx0ICB9XG5cblx0ICB0aGlzLmlvLmRlc3Ryb3kodGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQgbWFudWFsbHkuXG5cdCAqXG5cdCAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLmNsb3NlID1cblx0U29ja2V0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcblx0ICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcblx0XHRkZWJ1ZygncGVyZm9ybWluZyBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG5cdFx0dGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuRElTQ09OTkVDVCB9KTtcblx0ICB9XG5cblx0ICAvLyByZW1vdmUgc29ja2V0IGZyb20gcG9vbFxuXHQgIHRoaXMuZGVzdHJveSgpO1xuXG5cdCAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG5cdFx0Ly8gZmlyZSBldmVudHNcblx0XHR0aGlzLm9uY2xvc2UoJ2lvIGNsaWVudCBkaXNjb25uZWN0Jyk7XG5cdCAgfVxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlmIGB0cnVlYCwgY29tcHJlc3NlcyB0aGUgc2VuZGluZyBkYXRhXG5cdCAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24oY29tcHJlc3Mpe1xuXHQgIHRoaXMuZmxhZ3MgPSB0aGlzLmZsYWdzIHx8IHt9O1xuXHQgIHRoaXMuZmxhZ3MuY29tcHJlc3MgPSBjb21wcmVzcztcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHR9LHtcIi4vb25cIjozMyxcImNvbXBvbmVudC1iaW5kXCI6MzcsXCJjb21wb25lbnQtZW1pdHRlclwiOjM4LFwiZGVidWdcIjozOSxcImhhcy1iaW5hcnlcIjo0MSxcInNvY2tldC5pby1wYXJzZXJcIjo0NyxcInRvLWFycmF5XCI6NTF9XSwzNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdChmdW5jdGlvbiAoZ2xvYmFsKXtcblxuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cblx0dmFyIHBhcnNldXJpID0gX2RlcmVxXygncGFyc2V1cmknKTtcblx0dmFyIGRlYnVnID0gX2RlcmVxXygnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDp1cmwnKTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gdXJsO1xuXG5cdC8qKlxuXHQgKiBVUkwgcGFyc2VyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBBbiBvYmplY3QgbWVhbnQgdG8gbWltaWMgd2luZG93LmxvY2F0aW9uLlxuXHQgKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiB1cmwodXJpLCBsb2Mpe1xuXHQgIHZhciBvYmogPSB1cmk7XG5cblx0ICAvLyBkZWZhdWx0IHRvIHdpbmRvdy5sb2NhdGlvblxuXHQgIHZhciBsb2MgPSBsb2MgfHwgZ2xvYmFsLmxvY2F0aW9uO1xuXHQgIGlmIChudWxsID09IHVyaSkgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0O1xuXG5cdCAgLy8gcmVsYXRpdmUgcGF0aCBzdXBwb3J0XG5cdCAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB1cmkpIHtcblx0XHRpZiAoJy8nID09IHVyaS5jaGFyQXQoMCkpIHtcblx0XHQgIGlmICgnLycgPT0gdXJpLmNoYXJBdCgxKSkge1xuXHRcdFx0dXJpID0gbG9jLnByb3RvY29sICsgdXJpO1xuXHRcdCAgfSBlbHNlIHtcblx0XHRcdHVyaSA9IGxvYy5ob3N0ICsgdXJpO1xuXHRcdCAgfVxuXHRcdH1cblxuXHRcdGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG5cdFx0ICBkZWJ1ZygncHJvdG9jb2wtbGVzcyB1cmwgJXMnLCB1cmkpO1xuXHRcdCAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBsb2MpIHtcblx0XHRcdHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG5cdFx0ICB9IGVsc2Uge1xuXHRcdFx0dXJpID0gJ2h0dHBzOi8vJyArIHVyaTtcblx0XHQgIH1cblx0XHR9XG5cblx0XHQvLyBwYXJzZVxuXHRcdGRlYnVnKCdwYXJzZSAlcycsIHVyaSk7XG5cdFx0b2JqID0gcGFyc2V1cmkodXJpKTtcblx0ICB9XG5cblx0ICAvLyBtYWtlIHN1cmUgd2UgdHJlYXQgYGxvY2FsaG9zdDo4MGAgYW5kIGBsb2NhbGhvc3RgIGVxdWFsbHlcblx0ICBpZiAoIW9iai5wb3J0KSB7XG5cdFx0aWYgKC9eKGh0dHB8d3MpJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG5cdFx0ICBvYmoucG9ydCA9ICc4MCc7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKC9eKGh0dHB8d3MpcyQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuXHRcdCAgb2JqLnBvcnQgPSAnNDQzJztcblx0XHR9XG5cdCAgfVxuXG5cdCAgb2JqLnBhdGggPSBvYmoucGF0aCB8fCAnLyc7XG5cblx0ICB2YXIgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoJzonKSAhPT0gLTE7XG5cdCAgdmFyIGhvc3QgPSBpcHY2ID8gJ1snICsgb2JqLmhvc3QgKyAnXScgOiBvYmouaG9zdDtcblxuXHQgIC8vIGRlZmluZSB1bmlxdWUgaWRcblx0ICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAnOicgKyBvYmoucG9ydDtcblx0ICAvLyBkZWZpbmUgaHJlZlxuXHQgIG9iai5ocmVmID0gb2JqLnByb3RvY29sICsgJzovLycgKyBob3N0ICsgKGxvYyAmJiBsb2MucG9ydCA9PSBvYmoucG9ydCA/ICcnIDogKCc6JyArIG9iai5wb3J0KSk7XG5cblx0ICByZXR1cm4gb2JqO1xuXHR9XG5cblx0fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG5cdH0se1wiZGVidWdcIjozOSxcInBhcnNldXJpXCI6NDV9XSwzNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cblx0LyoqXG5cdCAqIEV4cG9zZSBgQmFja29mZmAuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gQmFja29mZjtcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSBiYWNrb2ZmIHRpbWVyIHdpdGggYG9wdHNgLlxuXHQgKlxuXHQgKiAtIGBtaW5gIGluaXRpYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgWzEwMF1cblx0ICogLSBgbWF4YCBtYXggdGltZW91dCBbMTAwMDBdXG5cdCAqIC0gYGppdHRlcmAgWzBdXG5cdCAqIC0gYGZhY3RvcmAgWzJdXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuXHQgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXHQgIHRoaXMubXMgPSBvcHRzLm1pbiB8fCAxMDA7XG5cdCAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcblx0ICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG5cdCAgdGhpcy5qaXR0ZXIgPSBvcHRzLmppdHRlciA+IDAgJiYgb3B0cy5qaXR0ZXIgPD0gMSA/IG9wdHMuaml0dGVyIDogMDtcblx0ICB0aGlzLmF0dGVtcHRzID0gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIGJhY2tvZmYgZHVyYXRpb24uXG5cdCAqXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0QmFja29mZi5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbigpe1xuXHQgIHZhciBtcyA9IHRoaXMubXMgKiBNYXRoLnBvdyh0aGlzLmZhY3RvciwgdGhpcy5hdHRlbXB0cysrKTtcblx0ICBpZiAodGhpcy5qaXR0ZXIpIHtcblx0XHR2YXIgcmFuZCA9ICBNYXRoLnJhbmRvbSgpO1xuXHRcdHZhciBkZXZpYXRpb24gPSBNYXRoLmZsb29yKHJhbmQgKiB0aGlzLmppdHRlciAqIG1zKTtcblx0XHRtcyA9IChNYXRoLmZsb29yKHJhbmQgKiAxMCkgJiAxKSA9PSAwICA/IG1zIC0gZGV2aWF0aW9uIDogbXMgKyBkZXZpYXRpb247XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLm1pbihtcywgdGhpcy5tYXgpIHwgMDtcblx0fTtcblxuXHQvKipcblx0ICogUmVzZXQgdGhlIG51bWJlciBvZiBhdHRlbXB0cy5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0QmFja29mZi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuXHQgIHRoaXMuYXR0ZW1wdHMgPSAwO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIG1pbmltdW0gZHVyYXRpb25cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0QmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24obWluKXtcblx0ICB0aGlzLm1zID0gbWluO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0QmFja29mZi5wcm90b3R5cGUuc2V0TWF4ID0gZnVuY3Rpb24obWF4KXtcblx0ICB0aGlzLm1heCA9IG1heDtcblx0fTtcblxuXHQvKipcblx0ICogU2V0IHRoZSBqaXR0ZXJcblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0QmFja29mZi5wcm90b3R5cGUuc2V0Sml0dGVyID0gZnVuY3Rpb24oaml0dGVyKXtcblx0ICB0aGlzLmppdHRlciA9IGppdHRlcjtcblx0fTtcblxuXG5cdH0se31dLDM3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblx0LyoqXG5cdCAqIFNsaWNlIHJlZmVyZW5jZS5cblx0ICovXG5cblx0dmFyIHNsaWNlID0gW10uc2xpY2U7XG5cblx0LyoqXG5cdCAqIEJpbmQgYG9iamAgdG8gYGZuYC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9ialxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZm4gb3Igc3RyaW5nXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgZm4pe1xuXHQgIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZm4pIGZuID0gb2JqW2ZuXTtcblx0ICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgZm4pIHRocm93IG5ldyBFcnJvcignYmluZCgpIHJlcXVpcmVzIGEgZnVuY3Rpb24nKTtcblx0ICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcblx0ICByZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcblx0ICB9XG5cdH07XG5cblx0fSx7fV0sMzg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5cdC8qKlxuXHQgKiBFeHBvc2UgYEVtaXR0ZXJgLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuXHQgIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqXG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIG1peGluKG9iaikge1xuXHQgIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuXHRcdG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcblx0ICB9XG5cdCAgcmV0dXJuIG9iajtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0ICogQHJldHVybiB7RW1pdHRlcn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUub24gPVxuXHRFbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcblx0ICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cdCAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxuXHRcdC5wdXNoKGZuKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG5cdCAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcblx0ICBmdW5jdGlvbiBvbigpIHtcblx0XHR0aGlzLm9mZihldmVudCwgb24pO1xuXHRcdGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXG5cdCAgb24uZm4gPSBmbjtcblx0ICB0aGlzLm9uKGV2ZW50LCBvbik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG5cdCAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0ICogQHJldHVybiB7RW1pdHRlcn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUub2ZmID1cblx0RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuXHRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuXHRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcblx0ICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cblx0ICAvLyBhbGxcblx0ICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0dGhpcy5fY2FsbGJhY2tzID0ge307XG5cdFx0cmV0dXJuIHRoaXM7XG5cdCAgfVxuXG5cdCAgLy8gc3BlY2lmaWMgZXZlbnRcblx0ICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcblx0ICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cblx0ICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG5cdCAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuXHRcdHJldHVybiB0aGlzO1xuXHQgIH1cblxuXHQgIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG5cdCAgdmFyIGNiO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2IgPSBjYWxsYmFja3NbaV07XG5cdFx0aWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcblx0XHQgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG5cdFx0ICBicmVhaztcblx0XHR9XG5cdCAgfVxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblx0ICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuXHRcdCwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcblxuXHQgIGlmIChjYWxsYmFja3MpIHtcblx0XHRjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHRcdCAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdH1cblx0ICB9XG5cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXHQgIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG5cdCAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG5cdH07XG5cblx0fSx7fV0sMzk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHRhcmd1bWVudHNbNF1bMTddWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKVxuXHR9LHtcIi4vZGVidWdcIjo0MCxcImR1cFwiOjE3fV0sNDA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHRhcmd1bWVudHNbNF1bMThdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKVxuXHR9LHtcImR1cFwiOjE4LFwibXNcIjo0NH1dLDQxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblx0KGZ1bmN0aW9uIChnbG9iYWwpe1xuXG5cdC8qXG5cdCAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG5cdCAqL1xuXG5cdHZhciBpc0FycmF5ID0gX2RlcmVxXygnaXNhcnJheScpO1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cblx0LyoqXG5cdCAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG5cdCAqXG5cdCAqIFJpZ2h0IG5vdyBvbmx5IEJ1ZmZlciBhbmQgQXJyYXlCdWZmZXIgYXJlIHN1cHBvcnRlZC4uXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBoYXNCaW5hcnkoZGF0YSkge1xuXG5cdCAgZnVuY3Rpb24gX2hhc0JpbmFyeShvYmopIHtcblx0XHRpZiAoIW9iaikgcmV0dXJuIGZhbHNlO1xuXG5cdFx0aWYgKCAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcblx0XHRcdCAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuXHRcdFx0IChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuXHRcdFx0IChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuXHRcdFx0KSB7XG5cdFx0ICByZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoaXNBcnJheShvYmopKSB7XG5cdFx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuXHRcdFx0ICBpZiAoX2hhc0JpbmFyeShvYmpbaV0pKSB7XG5cdFx0XHRcdCAgcmV0dXJuIHRydWU7XG5cdFx0XHQgIH1cblx0XHQgIH1cblx0XHR9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqKSB7XG5cdFx0ICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2hhcy1iaW5hcnkvcHVsbC80XG5cdFx0ICBpZiAob2JqLnRvSlNPTiAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiBvYmoudG9KU09OKSB7XG5cdFx0XHRvYmogPSBvYmoudG9KU09OKCk7XG5cdFx0ICB9XG5cblx0XHQgIGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIF9oYXNCaW5hcnkob2JqW2tleV0pKSB7XG5cdFx0XHQgIHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdCAgfVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICByZXR1cm4gX2hhc0JpbmFyeShkYXRhKTtcblx0fVxuXG5cdH0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxuXHR9LHtcImlzYXJyYXlcIjo0M31dLDQyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblx0YXJndW1lbnRzWzRdWzIzXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cylcblx0fSx7XCJkdXBcIjoyM31dLDQzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblx0YXJndW1lbnRzWzRdWzI0XVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cylcblx0fSx7XCJkdXBcIjoyNH1dLDQ0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblx0YXJndW1lbnRzWzRdWzI1XVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cylcblx0fSx7XCJkdXBcIjoyNX1dLDQ1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblx0YXJndW1lbnRzWzRdWzI4XVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cylcblx0fSx7XCJkdXBcIjoyOH1dLDQ2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblx0KGZ1bmN0aW9uIChnbG9iYWwpe1xuXHQvKmdsb2JhbCBCbG9iLEZpbGUqL1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgcmVxdWlyZW1lbnRzXG5cdCAqL1xuXG5cdHZhciBpc0FycmF5ID0gX2RlcmVxXygnaXNhcnJheScpO1xuXHR2YXIgaXNCdWYgPSBfZGVyZXFfKCcuL2lzLWJ1ZmZlcicpO1xuXG5cdC8qKlxuXHQgKiBSZXBsYWNlcyBldmVyeSBCdWZmZXIgfCBBcnJheUJ1ZmZlciBpbiBwYWNrZXQgd2l0aCBhIG51bWJlcmVkIHBsYWNlaG9sZGVyLlxuXHQgKiBBbnl0aGluZyB3aXRoIGJsb2JzIG9yIGZpbGVzIHNob3VsZCBiZSBmZWQgdGhyb3VnaCByZW1vdmVCbG9icyBiZWZvcmUgY29taW5nXG5cdCAqIGhlcmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG5cdCAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuXHQgIHZhciBidWZmZXJzID0gW107XG5cdCAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcblxuXHQgIGZ1bmN0aW9uIF9kZWNvbnN0cnVjdFBhY2tldChkYXRhKSB7XG5cdFx0aWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuXHRcdGlmIChpc0J1ZihkYXRhKSkge1xuXHRcdCAgdmFyIHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcblx0XHQgIGJ1ZmZlcnMucHVzaChkYXRhKTtcblx0XHQgIHJldHVybiBwbGFjZWhvbGRlcjtcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcblx0XHQgIHZhciBuZXdEYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcblx0XHQgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0bmV3RGF0YVtpXSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKTtcblx0XHQgIH1cblx0XHQgIHJldHVybiBuZXdEYXRhO1xuXHRcdH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIGRhdGEgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcblx0XHQgIHZhciBuZXdEYXRhID0ge307XG5cdFx0ICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuXHRcdFx0bmV3RGF0YVtrZXldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSk7XG5cdFx0ICB9XG5cdFx0ICByZXR1cm4gbmV3RGF0YTtcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGE7XG5cdCAgfVxuXG5cdCAgdmFyIHBhY2sgPSBwYWNrZXQ7XG5cdCAgcGFjay5kYXRhID0gX2RlY29uc3RydWN0UGFja2V0KHBhY2tldERhdGEpO1xuXHQgIHBhY2suYXR0YWNobWVudHMgPSBidWZmZXJzLmxlbmd0aDsgLy8gbnVtYmVyIG9mIGJpbmFyeSAnYXR0YWNobWVudHMnXG5cdCAgcmV0dXJuIHtwYWNrZXQ6IHBhY2ssIGJ1ZmZlcnM6IGJ1ZmZlcnN9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gZXZlbnQgcGFja2V0IHdpdGggcGxhY2Vob2xkZXJzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG5cdCAqIEByZXR1cm4ge09iamVjdH0gcmVjb25zdHJ1Y3RlZCBwYWNrZXRcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5yZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgYnVmZmVycykge1xuXHQgIHZhciBjdXJQbGFjZUhvbGRlciA9IDA7XG5cblx0ICBmdW5jdGlvbiBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YSkge1xuXHRcdGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG5cdFx0ICB2YXIgYnVmID0gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuXHRcdCAgcmV0dXJuIGJ1Zjtcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcblx0XHQgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0ZGF0YVtpXSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKTtcblx0XHQgIH1cblx0XHQgIHJldHVybiBkYXRhO1xuXHRcdH0gZWxzZSBpZiAoZGF0YSAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgZGF0YSkge1xuXHRcdCAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcblx0XHRcdGRhdGFba2V5XSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0pO1xuXHRcdCAgfVxuXHRcdCAgcmV0dXJuIGRhdGE7XG5cdFx0fVxuXHRcdHJldHVybiBkYXRhO1xuXHQgIH1cblxuXHQgIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhKTtcblx0ICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcblx0ICByZXR1cm4gcGFja2V0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBc3luY2hyb25vdXNseSByZW1vdmVzIEJsb2JzIG9yIEZpbGVzIGZyb20gZGF0YSB2aWFcblx0ICogRmlsZVJlYWRlcidzIHJlYWRBc0FycmF5QnVmZmVyIG1ldGhvZC4gVXNlZCBiZWZvcmUgZW5jb2Rpbmdcblx0ICogZGF0YSBhcyBtc2dwYWNrLiBDYWxscyBjYWxsYmFjayB3aXRoIHRoZSBibG9ibGVzcyBkYXRhLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZXhwb3J0cy5yZW1vdmVCbG9icyA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG5cdCAgZnVuY3Rpb24gX3JlbW92ZUJsb2JzKG9iaiwgY3VyS2V5LCBjb250YWluaW5nT2JqZWN0KSB7XG5cdFx0aWYgKCFvYmopIHJldHVybiBvYmo7XG5cblx0XHQvLyBjb252ZXJ0IGFueSBibG9iXG5cdFx0aWYgKChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuXHRcdFx0KGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpKSB7XG5cdFx0ICBwZW5kaW5nQmxvYnMrKztcblxuXHRcdCAgLy8gYXN5bmMgZmlsZXJlYWRlclxuXHRcdCAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdCAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHsgLy8gdGhpcy5yZXN1bHQgPT0gYXJyYXlidWZmZXJcblx0XHRcdGlmIChjb250YWluaW5nT2JqZWN0KSB7XG5cdFx0XHQgIGNvbnRhaW5pbmdPYmplY3RbY3VyS2V5XSA9IHRoaXMucmVzdWx0O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHQgIGJsb2JsZXNzRGF0YSA9IHRoaXMucmVzdWx0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBpZiBub3RoaW5nIHBlbmRpbmcgaXRzIGNhbGxiYWNrIHRpbWVcblx0XHRcdGlmKCEgLS1wZW5kaW5nQmxvYnMpIHtcblx0XHRcdCAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcblx0XHRcdH1cblx0XHQgIH07XG5cblx0XHQgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIob2JqKTsgLy8gYmxvYiAtPiBhcnJheWJ1ZmZlclxuXHRcdH0gZWxzZSBpZiAoaXNBcnJheShvYmopKSB7IC8vIGhhbmRsZSBhcnJheVxuXHRcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcblx0XHRcdF9yZW1vdmVCbG9icyhvYmpbaV0sIGksIG9iaik7XG5cdFx0ICB9XG5cdFx0fSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaiAmJiAhaXNCdWYob2JqKSkgeyAvLyBhbmQgb2JqZWN0XG5cdFx0ICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdFx0XHRfcmVtb3ZlQmxvYnMob2JqW2tleV0sIGtleSwgb2JqKTtcblx0XHQgIH1cblx0XHR9XG5cdCAgfVxuXG5cdCAgdmFyIHBlbmRpbmdCbG9icyA9IDA7XG5cdCAgdmFyIGJsb2JsZXNzRGF0YSA9IGRhdGE7XG5cdCAgX3JlbW92ZUJsb2JzKGJsb2JsZXNzRGF0YSk7XG5cdCAgaWYgKCFwZW5kaW5nQmxvYnMpIHtcblx0XHRjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuXHQgIH1cblx0fTtcblxuXHR9KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcblx0fSx7XCIuL2lzLWJ1ZmZlclwiOjQ4LFwiaXNhcnJheVwiOjQzfV0sNDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblxuXHR2YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG5cdHZhciBqc29uID0gX2RlcmVxXygnanNvbjMnKTtcblx0dmFyIGlzQXJyYXkgPSBfZGVyZXFfKCdpc2FycmF5Jyk7XG5cdHZhciBFbWl0dGVyID0gX2RlcmVxXygnY29tcG9uZW50LWVtaXR0ZXInKTtcblx0dmFyIGJpbmFyeSA9IF9kZXJlcV8oJy4vYmluYXJ5Jyk7XG5cdHZhciBpc0J1ZiA9IF9kZXJlcV8oJy4vaXMtYnVmZmVyJyk7XG5cblx0LyoqXG5cdCAqIFByb3RvY29sIHZlcnNpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMucHJvdG9jb2wgPSA0O1xuXG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZXMuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMudHlwZXMgPSBbXG5cdCAgJ0NPTk5FQ1QnLFxuXHQgICdESVNDT05ORUNUJyxcblx0ICAnRVZFTlQnLFxuXHQgICdCSU5BUllfRVZFTlQnLFxuXHQgICdBQ0snLFxuXHQgICdCSU5BUllfQUNLJyxcblx0ICAnRVJST1InXG5cdF07XG5cblx0LyoqXG5cdCAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5DT05ORUNUID0gMDtcblxuXHQvKipcblx0ICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLkRJU0NPTk5FQ1QgPSAxO1xuXG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLkVWRU5UID0gMjtcblxuXHQvKipcblx0ICogUGFja2V0IHR5cGUgYGFja2AuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMuQUNLID0gMztcblxuXHQvKipcblx0ICogUGFja2V0IHR5cGUgYGVycm9yYC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5FUlJPUiA9IDQ7XG5cblx0LyoqXG5cdCAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMuQklOQVJZX0VWRU5UID0gNTtcblxuXHQvKipcblx0ICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMuQklOQVJZX0FDSyA9IDY7XG5cblx0LyoqXG5cdCAqIEVuY29kZXIgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMuRW5jb2RlciA9IEVuY29kZXI7XG5cblx0LyoqXG5cdCAqIERlY29kZXIgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMuRGVjb2RlciA9IERlY29kZXI7XG5cblx0LyoqXG5cdCAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2Vcblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gRW5jb2RlcigpIHt9XG5cblx0LyoqXG5cdCAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuXHQgKiBidWZmZXIgc2VxdWVuY2UsIGRlcGVuZGluZyBvbiBwYWNrZXQgdHlwZS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3Rcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBmdW5jdGlvbiB0byBoYW5kbGUgZW5jb2RpbmdzIChsaWtlbHkgZW5naW5lLndyaXRlKVxuXHQgKiBAcmV0dXJuIENhbGxzIGNhbGxiYWNrIHdpdGggQXJyYXkgb2YgZW5jb2RpbmdzXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spe1xuXHQgIGRlYnVnKCdlbmNvZGluZyBwYWNrZXQgJWonLCBvYmopO1xuXG5cdCAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBvYmoudHlwZSkge1xuXHRcdGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0XHR2YXIgZW5jb2RpbmcgPSBlbmNvZGVBc1N0cmluZyhvYmopO1xuXHRcdGNhbGxiYWNrKFtlbmNvZGluZ10pO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogRW5jb2RlIHBhY2tldCBhcyBzdHJpbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBlbmNvZGVBc1N0cmluZyhvYmopIHtcblx0ICB2YXIgc3RyID0gJyc7XG5cdCAgdmFyIG5zcCA9IGZhbHNlO1xuXG5cdCAgLy8gZmlyc3QgaXMgdHlwZVxuXHQgIHN0ciArPSBvYmoudHlwZTtcblxuXHQgIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuXHQgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gb2JqLnR5cGUpIHtcblx0XHRzdHIgKz0gb2JqLmF0dGFjaG1lbnRzO1xuXHRcdHN0ciArPSAnLSc7XG5cdCAgfVxuXG5cdCAgLy8gaWYgd2UgaGF2ZSBhIG5hbWVzcGFjZSBvdGhlciB0aGFuIGAvYFxuXHQgIC8vIHdlIGFwcGVuZCBpdCBmb2xsb3dlZCBieSBhIGNvbW1hIGAsYFxuXHQgIGlmIChvYmoubnNwICYmICcvJyAhPSBvYmoubnNwKSB7XG5cdFx0bnNwID0gdHJ1ZTtcblx0XHRzdHIgKz0gb2JqLm5zcDtcblx0ICB9XG5cblx0ICAvLyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGUgaWRcblx0ICBpZiAobnVsbCAhPSBvYmouaWQpIHtcblx0XHRpZiAobnNwKSB7XG5cdFx0ICBzdHIgKz0gJywnO1xuXHRcdCAgbnNwID0gZmFsc2U7XG5cdFx0fVxuXHRcdHN0ciArPSBvYmouaWQ7XG5cdCAgfVxuXG5cdCAgLy8ganNvbiBkYXRhXG5cdCAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcblx0XHRpZiAobnNwKSBzdHIgKz0gJywnO1xuXHRcdHN0ciArPSBqc29uLnN0cmluZ2lmeShvYmouZGF0YSk7XG5cdCAgfVxuXG5cdCAgZGVidWcoJ2VuY29kZWQgJWogYXMgJXMnLCBvYmosIHN0cik7XG5cdCAgcmV0dXJuIHN0cjtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmNvZGUgcGFja2V0IGFzICdidWZmZXIgc2VxdWVuY2UnIGJ5IHJlbW92aW5nIGJsb2JzLCBhbmRcblx0ICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuXHQgKiBhIGxpc3Qgb2YgYnVmZmVycy5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuXHQgKiBAcmV0dXJuIHtCdWZmZXJ9IGVuY29kZWRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spIHtcblxuXHQgIGZ1bmN0aW9uIHdyaXRlRW5jb2RpbmcoYmxvYmxlc3NEYXRhKSB7XG5cdFx0dmFyIGRlY29uc3RydWN0aW9uID0gYmluYXJ5LmRlY29uc3RydWN0UGFja2V0KGJsb2JsZXNzRGF0YSk7XG5cdFx0dmFyIHBhY2sgPSBlbmNvZGVBc1N0cmluZyhkZWNvbnN0cnVjdGlvbi5wYWNrZXQpO1xuXHRcdHZhciBidWZmZXJzID0gZGVjb25zdHJ1Y3Rpb24uYnVmZmVycztcblxuXHRcdGJ1ZmZlcnMudW5zaGlmdChwYWNrKTsgLy8gYWRkIHBhY2tldCBpbmZvIHRvIGJlZ2lubmluZyBvZiBkYXRhIGxpc3Rcblx0XHRjYWxsYmFjayhidWZmZXJzKTsgLy8gd3JpdGUgYWxsIHRoZSBidWZmZXJzXG5cdCAgfVxuXG5cdCAgYmluYXJ5LnJlbW92ZUJsb2JzKG9iaiwgd3JpdGVFbmNvZGluZyk7XG5cdH1cblxuXHQvKipcblx0ICogQSBzb2NrZXQuaW8gRGVjb2RlciBpbnN0YW5jZVxuXHQgKlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gRGVjb2RlcigpIHtcblx0ICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1peCBpbiBgRW1pdHRlcmAgd2l0aCBEZWNvZGVyLlxuXHQgKi9cblxuXHRFbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuXHQvKipcblx0ICogRGVjb2RlcyBhbiBlY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gb2JqIC0gZW5jb2RlZCBwYWNrZXRcblx0ICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RGVjb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob2JqKSB7XG5cdCAgdmFyIHBhY2tldDtcblx0ICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIG9iaikge1xuXHRcdHBhY2tldCA9IGRlY29kZVN0cmluZyhvYmopO1xuXHRcdGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBwYWNrZXQudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gcGFja2V0LnR5cGUpIHsgLy8gYmluYXJ5IHBhY2tldCdzIGpzb25cblx0XHQgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG5ldyBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCk7XG5cblx0XHQgIC8vIG5vIGF0dGFjaG1lbnRzLCBsYWJlbGVkIGJpbmFyeSBidXQgbm8gYmluYXJ5IGRhdGEgdG8gZm9sbG93XG5cdFx0ICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yLnJlY29uUGFjay5hdHRhY2htZW50cyA9PT0gMCkge1xuXHRcdFx0dGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcblx0XHQgIH1cblx0XHR9IGVsc2UgeyAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG5cdFx0ICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuXHRcdH1cblx0ICB9XG5cdCAgZWxzZSBpZiAoaXNCdWYob2JqKSB8fCBvYmouYmFzZTY0KSB7IC8vIHJhdyBiaW5hcnkgZGF0YVxuXHRcdGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG5cdFx0ICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldCcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0ICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcblx0XHQgIGlmIChwYWNrZXQpIHsgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG5cdFx0XHR0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xuXHRcdFx0dGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcblx0XHQgIH1cblx0XHR9XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgb2JqKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cikge1xuXHQgIHZhciBwID0ge307XG5cdCAgdmFyIGkgPSAwO1xuXG5cdCAgLy8gbG9vayB1cCB0eXBlXG5cdCAgcC50eXBlID0gTnVtYmVyKHN0ci5jaGFyQXQoMCkpO1xuXHQgIGlmIChudWxsID09IGV4cG9ydHMudHlwZXNbcC50eXBlXSkgcmV0dXJuIGVycm9yKCk7XG5cblx0ICAvLyBsb29rIHVwIGF0dGFjaG1lbnRzIGlmIHR5cGUgYmluYXJ5XG5cdCAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IHAudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gcC50eXBlKSB7XG5cdFx0dmFyIGJ1ZiA9ICcnO1xuXHRcdHdoaWxlIChzdHIuY2hhckF0KCsraSkgIT0gJy0nKSB7XG5cdFx0ICBidWYgKz0gc3RyLmNoYXJBdChpKTtcblx0XHQgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuXHRcdH1cblx0XHRpZiAoYnVmICE9IE51bWJlcihidWYpIHx8IHN0ci5jaGFyQXQoaSkgIT0gJy0nKSB7XG5cdFx0ICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYXR0YWNobWVudHMnKTtcblx0XHR9XG5cdFx0cC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuXHQgIH1cblxuXHQgIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG5cdCAgaWYgKCcvJyA9PSBzdHIuY2hhckF0KGkgKyAxKSkge1xuXHRcdHAubnNwID0gJyc7XG5cdFx0d2hpbGUgKCsraSkge1xuXHRcdCAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuXHRcdCAgaWYgKCcsJyA9PSBjKSBicmVhaztcblx0XHQgIHAubnNwICs9IGM7XG5cdFx0ICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcblx0XHR9XG5cdCAgfSBlbHNlIHtcblx0XHRwLm5zcCA9ICcvJztcblx0ICB9XG5cblx0ICAvLyBsb29rIHVwIGlkXG5cdCAgdmFyIG5leHQgPSBzdHIuY2hhckF0KGkgKyAxKTtcblx0ICBpZiAoJycgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcblx0XHRwLmlkID0gJyc7XG5cdFx0d2hpbGUgKCsraSkge1xuXHRcdCAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuXHRcdCAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuXHRcdFx0LS1pO1xuXHRcdFx0YnJlYWs7XG5cdFx0ICB9XG5cdFx0ICBwLmlkICs9IHN0ci5jaGFyQXQoaSk7XG5cdFx0ICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcblx0XHR9XG5cdFx0cC5pZCA9IE51bWJlcihwLmlkKTtcblx0ICB9XG5cblx0ICAvLyBsb29rIHVwIGpzb24gZGF0YVxuXHQgIGlmIChzdHIuY2hhckF0KCsraSkpIHtcblx0XHR0cnkge1xuXHRcdCAgcC5kYXRhID0ganNvbi5wYXJzZShzdHIuc3Vic3RyKGkpKTtcblx0XHR9IGNhdGNoKGUpe1xuXHRcdCAgcmV0dXJuIGVycm9yKCk7XG5cdFx0fVxuXHQgIH1cblxuXHQgIGRlYnVnKCdkZWNvZGVkICVzIGFzICVqJywgc3RyLCBwKTtcblx0ICByZXR1cm4gcDtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWFsbG9jYXRlcyBhIHBhcnNlcidzIHJlc291cmNlc1xuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHREZWNvZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdCAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuXHRcdHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBIG1hbmFnZXIgb2YgYSBiaW5hcnkgZXZlbnQncyAnYnVmZmVyIHNlcXVlbmNlJy4gU2hvdWxkXG5cdCAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG5cdCAqIGRlY29kZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpIHtcblx0ICB0aGlzLnJlY29uUGFjayA9IHBhY2tldDtcblx0ICB0aGlzLmJ1ZmZlcnMgPSBbXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG5cdCAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cblx0ICpcblx0ICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcblx0ICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3Jcblx0ICogICBhIHJlY29uc3RydWN0ZWQgcGFja2V0IG9iamVjdCBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gcmVjZWl2ZWQuXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRCaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS50YWtlQmluYXJ5RGF0YSA9IGZ1bmN0aW9uKGJpbkRhdGEpIHtcblx0ICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcblx0ICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PSB0aGlzLnJlY29uUGFjay5hdHRhY2htZW50cykgeyAvLyBkb25lIHdpdGggYnVmZmVyIGxpc3Rcblx0XHR2YXIgcGFja2V0ID0gYmluYXJ5LnJlY29uc3RydWN0UGFja2V0KHRoaXMucmVjb25QYWNrLCB0aGlzLmJ1ZmZlcnMpO1xuXHRcdHRoaXMuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuXHRcdHJldHVybiBwYWNrZXQ7XG5cdCAgfVxuXHQgIHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRCaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS5maW5pc2hlZFJlY29uc3RydWN0aW9uID0gZnVuY3Rpb24oKSB7XG5cdCAgdGhpcy5yZWNvblBhY2sgPSBudWxsO1xuXHQgIHRoaXMuYnVmZmVycyA9IFtdO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGVycm9yKGRhdGEpe1xuXHQgIHJldHVybiB7XG5cdFx0dHlwZTogZXhwb3J0cy5FUlJPUixcblx0XHRkYXRhOiAncGFyc2VyIGVycm9yJ1xuXHQgIH07XG5cdH1cblxuXHR9LHtcIi4vYmluYXJ5XCI6NDYsXCIuL2lzLWJ1ZmZlclwiOjQ4LFwiY29tcG9uZW50LWVtaXR0ZXJcIjo0OSxcImRlYnVnXCI6MzksXCJpc2FycmF5XCI6NDMsXCJqc29uM1wiOjUwfV0sNDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQoZnVuY3Rpb24gKGdsb2JhbCl7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBpc0J1ZjtcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIGJ1ZmZlciBvciBhbiBhcnJheWJ1ZmZlci5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGlzQnVmKG9iaikge1xuXHQgIHJldHVybiAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG5cdFx0XHQgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG5cdH1cblxuXHR9KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcblx0fSx7fV0sNDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHRhcmd1bWVudHNbNF1bMTVdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKVxuXHR9LHtcImR1cFwiOjE1fV0sNTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQoZnVuY3Rpb24gKGdsb2JhbCl7XG5cdC8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cblx0OyhmdW5jdGlvbiAoKSB7XG5cdCAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXG5cdCAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cblx0ICB2YXIgaXNMb2FkZXIgPSB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZDtcblxuXHQgIC8vIEEgc2V0IG9mIHR5cGVzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggb2JqZWN0cyBmcm9tIHByaW1pdGl2ZXMuXG5cdCAgdmFyIG9iamVjdFR5cGVzID0ge1xuXHRcdFwiZnVuY3Rpb25cIjogdHJ1ZSxcblx0XHRcIm9iamVjdFwiOiB0cnVlXG5cdCAgfTtcblxuXHQgIC8vIERldGVjdCB0aGUgYGV4cG9ydHNgIG9iamVjdCBleHBvc2VkIGJ5IENvbW1vbkpTIGltcGxlbWVudGF0aW9ucy5cblx0ICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG5cdCAgLy8gVXNlIHRoZSBgZ2xvYmFsYCBvYmplY3QgZXhwb3NlZCBieSBOb2RlIChpbmNsdWRpbmcgQnJvd3NlcmlmeSB2aWFcblx0ICAvLyBgaW5zZXJ0LW1vZHVsZS1nbG9iYWxzYCksIE5hcndoYWwsIGFuZCBSaW5nbyBhcyB0aGUgZGVmYXVsdCBjb250ZXh0LFxuXHQgIC8vIGFuZCB0aGUgYHdpbmRvd2Agb2JqZWN0IGluIGJyb3dzZXJzLiBSaGlubyBleHBvcnRzIGEgYGdsb2JhbGAgZnVuY3Rpb25cblx0ICAvLyBpbnN0ZWFkLlxuXHQgIHZhciByb290ID0gb2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93IHx8IHRoaXMsXG5cdFx0ICBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbDtcblxuXHQgIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1wiZ2xvYmFsXCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJ3aW5kb3dcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcInNlbGZcIl0gPT09IGZyZWVHbG9iYWwpKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdCAgfVxuXG5cdCAgLy8gUHVibGljOiBJbml0aWFsaXplcyBKU09OIDMgdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QsIGF0dGFjaGluZyB0aGVcblx0ICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuXHQgIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0LCBleHBvcnRzKSB7XG5cdFx0Y29udGV4dCB8fCAoY29udGV4dCA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG5cdFx0ZXhwb3J0cyB8fCAoZXhwb3J0cyA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG5cblx0XHQvLyBOYXRpdmUgY29uc3RydWN0b3IgYWxpYXNlcy5cblx0XHR2YXIgTnVtYmVyID0gY29udGV4dFtcIk51bWJlclwiXSB8fCByb290W1wiTnVtYmVyXCJdLFxuXHRcdFx0U3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuXHRcdFx0T2JqZWN0ID0gY29udGV4dFtcIk9iamVjdFwiXSB8fCByb290W1wiT2JqZWN0XCJdLFxuXHRcdFx0RGF0ZSA9IGNvbnRleHRbXCJEYXRlXCJdIHx8IHJvb3RbXCJEYXRlXCJdLFxuXHRcdFx0U3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuXHRcdFx0VHlwZUVycm9yID0gY29udGV4dFtcIlR5cGVFcnJvclwiXSB8fCByb290W1wiVHlwZUVycm9yXCJdLFxuXHRcdFx0TWF0aCA9IGNvbnRleHRbXCJNYXRoXCJdIHx8IHJvb3RbXCJNYXRoXCJdLFxuXHRcdFx0bmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXG5cdFx0aWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuXHRcdCAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcblx0XHQgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG5cdFx0dmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcblx0XHRcdGdldENsYXNzID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXG5cdFx0XHRpc1Byb3BlcnR5LCBmb3JFYWNoLCB1bmRlZjtcblxuXHRcdC8vIFRlc3QgdGhlIGBEYXRlI2dldFVUQypgIG1ldGhvZHMuIEJhc2VkIG9uIHdvcmsgYnkgQFlhZmZsZS5cblx0XHR2YXIgaXNFeHRlbmRlZCA9IG5ldyBEYXRlKC0zNTA5ODI3MzM0NTczMjkyKTtcblx0XHR0cnkge1xuXHRcdCAgLy8gVGhlIGBnZXRVVENGdWxsWWVhcmAsIGBNb250aGAsIGFuZCBgRGF0ZWAgbWV0aG9kcyByZXR1cm4gbm9uc2Vuc2ljYWxcblx0XHQgIC8vIHJlc3VsdHMgZm9yIGNlcnRhaW4gZGF0ZXMgaW4gT3BlcmEgPj0gMTAuNTMuXG5cdFx0ICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXG5cdFx0XHQvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuXHRcdFx0Ly8gYnV0IGNsaXBzIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGRhdGUgbWV0aG9kcyB0byB0aGUgcmFuZ2Ugb2Zcblx0XHRcdC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cblx0XHRcdGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuXHRcdH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuXHRcdC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG5cdFx0Ly8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxuXHRcdGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG5cdFx0ICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuXHRcdFx0Ly8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuXHRcdFx0cmV0dXJuIGhhc1tuYW1lXTtcblx0XHQgIH1cblx0XHQgIHZhciBpc1N1cHBvcnRlZDtcblx0XHQgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcblx0XHRcdC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcblx0XHRcdC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuXHRcdFx0aXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcblx0XHQgIH0gZWxzZSBpZiAobmFtZSA9PSBcImpzb25cIikge1xuXHRcdFx0Ly8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG5cdFx0XHQvLyBzdXBwb3J0ZWQuXG5cdFx0XHRpc1N1cHBvcnRlZCA9IGhhcyhcImpzb24tc3RyaW5naWZ5XCIpICYmIGhhcyhcImpzb24tcGFyc2VcIik7XG5cdFx0ICB9IGVsc2Uge1xuXHRcdFx0dmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG5cdFx0XHQvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXG5cdFx0XHRpZiAobmFtZSA9PSBcImpzb24tc3RyaW5naWZ5XCIpIHtcblx0XHRcdCAgdmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuXHRcdFx0ICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XG5cdFx0XHRcdC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXG5cdFx0XHRcdCh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0ICByZXR1cm4gMTtcblx0XHRcdFx0fSkudG9KU09OID0gdmFsdWU7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdCAgc3RyaW5naWZ5U3VwcG9ydGVkID1cblx0XHRcdFx0XHQvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG5cdFx0XHRcdFx0Ly8gcHJpbWl0aXZlcyBhcyBvYmplY3QgbGl0ZXJhbHMuXG5cdFx0XHRcdFx0c3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxuXHRcdFx0XHRcdC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuXHRcdFx0XHRcdC8vIGxpdGVyYWxzLlxuXHRcdFx0XHRcdHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxuXHRcdFx0XHRcdHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcIlwiJyAmJlxuXHRcdFx0XHRcdC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvclxuXHRcdFx0XHRcdC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cblx0XHRcdFx0XHQvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcblx0XHRcdFx0XHQvLyB3aXRoaW4gYW4gb2JqZWN0IG9yIGFycmF5KS5cblx0XHRcdFx0XHRzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxuXHRcdFx0XHRcdC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXCJ1bmRlZmluZWRcImAuIFNhZmFyaSA8PSA1LjEuNyBhbmRcblx0XHRcdFx0XHQvLyBGRiAzLjFiMyBwYXNzIHRoaXMgdGVzdC5cblx0XHRcdFx0XHRzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxuXHRcdFx0XHRcdC8vIFNhZmFyaSA8PSA1LjEuNyBhbmQgRkYgMy4xYjMgdGhyb3cgYEVycm9yYHMgYW5kIGBUeXBlRXJyb3Jgcyxcblx0XHRcdFx0XHQvLyByZXNwZWN0aXZlbHksIGlmIHRoZSB2YWx1ZSBpcyBvbWl0dGVkIGVudGlyZWx5LlxuXHRcdFx0XHRcdHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxuXHRcdFx0XHRcdC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIsXG5cdFx0XHRcdFx0Ly8gc3RyaW5nLCBhcnJheSwgb2JqZWN0LCBCb29sZWFuLCBvciBgbnVsbGAgbGl0ZXJhbC4gVGhpcyBhcHBsaWVzIHRvXG5cdFx0XHRcdFx0Ly8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcblx0XHRcdFx0XHQvLyBpbnNpZGUgb2JqZWN0IG9yIGFycmF5IGxpdGVyYWxzLiBZVUkgMy4wLjBiMSBpZ25vcmVzIGN1c3RvbSBgdG9KU09OYFxuXHRcdFx0XHRcdC8vIG1ldGhvZHMgZW50aXJlbHkuXG5cdFx0XHRcdFx0c3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcblx0XHRcdFx0XHRzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuXHRcdFx0XHRcdC8vIFByb3RvdHlwZSA8PSAxLjYuMSBzZXJpYWxpemVzIGBbdW5kZWZpbmVkXWAgYXMgYFwiW11cImAgaW5zdGVhZCBvZlxuXHRcdFx0XHRcdC8vIGBcIltudWxsXVwiYC5cblx0XHRcdFx0XHRzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuXHRcdFx0XHRcdC8vIFlVSSAzLjAuMGIxIGZhaWxzIHRvIHNlcmlhbGl6ZSBgbnVsbGAgbGl0ZXJhbHMuXG5cdFx0XHRcdFx0c3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXG5cdFx0XHRcdFx0Ly8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuXHRcdFx0XHRcdC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFwiWzEsdHJ1ZSxdLFwiLiBGRiAzLjFiM1xuXHRcdFx0XHRcdC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XG5cdFx0XHRcdFx0Ly8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuXHRcdFx0XHRcdHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXCJbbnVsbCxudWxsLG51bGxdXCIgJiZcblx0XHRcdFx0XHQvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xuXHRcdFx0XHRcdC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuXHRcdFx0XHRcdHN0cmluZ2lmeSh7IFwiYVwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcIlxceDAwXFxiXFxuXFxmXFxyXFx0XCJdIH0pID09IHNlcmlhbGl6ZWQgJiZcblx0XHRcdFx0XHQvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXG5cdFx0XHRcdFx0c3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiZcblx0XHRcdFx0XHRzdHJpbmdpZnkoWzEsIDJdLCBudWxsLCAxKSA9PSBcIltcXG4gMSxcXG4gMlxcbl1cIiAmJlxuXHRcdFx0XHRcdC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcblx0XHRcdFx0XHQvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG5cdFx0XHRcdFx0c3RyaW5naWZ5KG5ldyBEYXRlKC04LjY0ZTE1KSkgPT0gJ1wiLTI3MTgyMS0wNC0yMFQwMDowMDowMC4wMDBaXCInICYmXG5cdFx0XHRcdFx0Ly8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cblx0XHRcdFx0XHRzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuXHRcdFx0XHRcdC8vIEZpcmVmb3ggPD0gMTEuMCBpbmNvcnJlY3RseSBzZXJpYWxpemVzIHllYXJzIHByaW9yIHRvIDAgYXMgbmVnYXRpdmVcblx0XHRcdFx0XHQvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxuXHRcdFx0XHRcdHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcblx0XHRcdFx0XHQvLyBTYWZhcmkgPD0gNS4xLjUgYW5kIE9wZXJhID49IDEwLjUzIGluY29ycmVjdGx5IHNlcmlhbGl6ZSBtaWxsaXNlY29uZFxuXHRcdFx0XHRcdC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cblx0XHRcdFx0XHRzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG5cdFx0XHRcdH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuXHRcdFx0XHQgIHN0cmluZ2lmeVN1cHBvcnRlZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHQgIH1cblx0XHRcdCAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG5cdFx0XHR9XG5cdFx0XHQvLyBUZXN0IGBKU09OLnBhcnNlYC5cblx0XHRcdGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG5cdFx0XHQgIHZhciBwYXJzZSA9IGV4cG9ydHMucGFyc2U7XG5cdFx0XHQgIGlmICh0eXBlb2YgcGFyc2UgPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdCAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuXHRcdFx0XHQgIC8vIENvbmZvcm1pbmcgaW1wbGVtZW50YXRpb25zIHNob3VsZCBhbHNvIGNvZXJjZSB0aGUgaW5pdGlhbCBhcmd1bWVudCB0b1xuXHRcdFx0XHQgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXG5cdFx0XHRcdCAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG5cdFx0XHRcdFx0Ly8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cblx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuXHRcdFx0XHRcdHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG5cdFx0XHRcdFx0aWYgKHBhcnNlU3VwcG9ydGVkKSB7XG5cdFx0XHRcdFx0ICB0cnkge1xuXHRcdFx0XHRcdFx0Ly8gU2FmYXJpIDw9IDUuMS4yIGFuZCBGRiAzLjFiMSBhbGxvdyB1bmVzY2FwZWQgdGFicyBpbiBzdHJpbmdzLlxuXHRcdFx0XHRcdFx0cGFyc2VTdXBwb3J0ZWQgPSAhcGFyc2UoJ1wiXFx0XCInKTtcblx0XHRcdFx0XHQgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblx0XHRcdFx0XHQgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdCAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xuXHRcdFx0XHRcdFx0ICAvLyBkZWNpbWFsIHBvaW50cy4gRkYgNC4wLCA0LjAuMSwgYW5kIElFIDktMTAgYWxzbyBhbGxvd1xuXHRcdFx0XHRcdFx0ICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuXHRcdFx0XHRcdFx0ICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cdFx0XHRcdFx0ICB9XG5cdFx0XHRcdFx0ICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHQgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG5cdFx0XHRcdFx0XHQgIC8vIHBvaW50cy4gVGhlc2UgZW52aXJvbm1lbnRzLCBhbG9uZyB3aXRoIEZGIDMuMWIxIGFuZCAyLFxuXHRcdFx0XHRcdFx0ICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cblx0XHRcdFx0XHRcdCAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXHRcdFx0XHRcdCAgfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0ICB9XG5cdFx0XHRcdH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuXHRcdFx0XHQgIHBhcnNlU3VwcG9ydGVkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdCAgfVxuXHRcdFx0ICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuXHRcdFx0fVxuXHRcdCAgfVxuXHRcdCAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG5cdFx0fVxuXG5cdFx0aWYgKCFoYXMoXCJqc29uXCIpKSB7XG5cdFx0ICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuXHRcdCAgdmFyIGZ1bmN0aW9uQ2xhc3MgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsXG5cdFx0XHQgIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiLFxuXHRcdFx0ICBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCIsXG5cdFx0XHQgIHN0cmluZ0NsYXNzID0gXCJbb2JqZWN0IFN0cmluZ11cIixcblx0XHRcdCAgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIixcblx0XHRcdCAgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cblx0XHQgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cblx0XHQgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuXHRcdCAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG5cdFx0ICBpZiAoIWlzRXh0ZW5kZWQpIHtcblx0XHRcdHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cdFx0XHQvLyBBIG1hcHBpbmcgYmV0d2VlbiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlblxuXHRcdFx0Ly8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cblx0XHRcdHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuXHRcdFx0Ly8gSW50ZXJuYWw6IENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIFVuaXggZXBvY2ggYW5kIHRoZVxuXHRcdFx0Ly8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cblx0XHRcdHZhciBnZXREYXkgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcblx0XHRcdCAgcmV0dXJuIE1vbnRoc1ttb250aF0gKyAzNjUgKiAoeWVhciAtIDE5NzApICsgZmxvb3IoKHllYXIgLSAxOTY5ICsgKG1vbnRoID0gKyhtb250aCA+IDEpKSkgLyA0KSAtIGZsb29yKCh5ZWFyIC0gMTkwMSArIG1vbnRoKSAvIDEwMCkgKyBmbG9vcigoeWVhciAtIDE2MDEgKyBtb250aCkgLyA0MDApO1xuXHRcdFx0fTtcblx0XHQgIH1cblxuXHRcdCAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cblx0XHQgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuXHRcdCAgaWYgKCEoaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xuXHRcdFx0aXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuXHRcdFx0ICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3Rvcjtcblx0XHRcdCAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuXHRcdFx0XHQvLyBUaGUgKnByb3RvKiBwcm9wZXJ0eSBjYW5ub3QgYmUgc2V0IG11bHRpcGxlIHRpbWVzIGluIHJlY2VudFxuXHRcdFx0XHQvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXG5cdFx0XHRcdFwidG9TdHJpbmdcIjogMVxuXHRcdFx0ICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xuXHRcdFx0XHQvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuXHRcdFx0XHQvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxuXHRcdFx0XHRpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG5cdFx0XHRcdCAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcblx0XHRcdFx0ICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXG5cdFx0XHRcdCAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuXHRcdFx0XHQgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcblx0XHRcdFx0ICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXG5cdFx0XHRcdCAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcblx0XHRcdFx0ICByZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR9O1xuXHRcdFx0ICB9IGVsc2Uge1xuXHRcdFx0XHQvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG5cdFx0XHRcdGNvbnN0cnVjdG9yID0gbWVtYmVycy5jb25zdHJ1Y3Rvcjtcblx0XHRcdFx0Ly8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG5cdFx0XHRcdC8vIG90aGVyIGVudmlyb25tZW50cy5cblx0XHRcdFx0aXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuXHRcdFx0XHQgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuXHRcdFx0XHQgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcblx0XHRcdFx0fTtcblx0XHRcdCAgfVxuXHRcdFx0ICBtZW1iZXJzID0gbnVsbDtcblx0XHRcdCAgcmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSk7XG5cdFx0XHR9O1xuXHRcdCAgfVxuXG5cdFx0ICAvLyBJbnRlcm5hbDogTm9ybWFsaXplcyB0aGUgYGZvci4uLmluYCBpdGVyYXRpb24gYWxnb3JpdGhtIGFjcm9zc1xuXHRcdCAgLy8gZW52aXJvbm1lbnRzLiBFYWNoIGVudW1lcmF0ZWQga2V5IGlzIHlpZWxkZWQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLlxuXHRcdCAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG5cdFx0XHQvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcblx0XHRcdC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXG5cdFx0XHQvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cblx0XHRcdChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0ICB0aGlzLnZhbHVlT2YgPSAwO1xuXHRcdFx0fSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG5cdFx0XHQvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cblx0XHRcdG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuXHRcdFx0Zm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG5cdFx0XHQgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG5cdFx0XHQgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG5cdFx0XHRcdHNpemUrKztcblx0XHRcdCAgfVxuXHRcdFx0fVxuXHRcdFx0UHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG5cdFx0XHQvLyBOb3JtYWxpemUgdGhlIGl0ZXJhdGlvbiBhbGdvcml0aG0uXG5cdFx0XHRpZiAoIXNpemUpIHtcblx0XHRcdCAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuXHRcdFx0ICBtZW1iZXJzID0gW1widmFsdWVPZlwiLCBcInRvU3RyaW5nXCIsIFwidG9Mb2NhbGVTdHJpbmdcIiwgXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLCBcImlzUHJvdG90eXBlT2ZcIiwgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdO1xuXHRcdFx0ICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcblx0XHRcdCAgLy8gcHJvcGVydGllcy5cblx0XHRcdCAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG5cdFx0XHRcdHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBsZW5ndGg7XG5cdFx0XHRcdHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXCJmdW5jdGlvblwiICYmIG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHldICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBpc1Byb3BlcnR5O1xuXHRcdFx0XHRmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuXHRcdFx0XHQgIC8vIEdlY2tvIDw9IDEuMCBlbnVtZXJhdGVzIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgdW5kZXJcblx0XHRcdFx0ICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuXHRcdFx0XHQgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKHByb3BlcnR5KTtcblx0XHRcdFx0ICB9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cblx0XHRcdFx0Zm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xuXHRcdFx0ICB9O1xuXHRcdFx0fSBlbHNlIGlmIChzaXplID09IDIpIHtcblx0XHRcdCAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cblx0XHRcdCAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG5cdFx0XHRcdC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuXHRcdFx0XHR2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuXHRcdFx0XHRmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuXHRcdFx0XHQgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG5cdFx0XHRcdCAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cblx0XHRcdFx0ICAvLyBlbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG5cdFx0XHRcdCAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHRjYWxsYmFjayhwcm9wZXJ0eSk7XG5cdFx0XHRcdCAgfVxuXHRcdFx0XHR9XG5cdFx0XHQgIH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0ICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxuXHRcdFx0ICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcblx0XHRcdFx0dmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGlzQ29uc3RydWN0b3I7XG5cdFx0XHRcdGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdCAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcblx0XHRcdFx0XHRjYWxsYmFjayhwcm9wZXJ0eSk7XG5cdFx0XHRcdCAgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuXHRcdFx0XHQvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG5cdFx0XHRcdGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XG5cdFx0XHRcdCAgY2FsbGJhY2socHJvcGVydHkpO1xuXHRcdFx0XHR9XG5cdFx0XHQgIH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcblx0XHQgIH07XG5cblx0XHQgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcblx0XHQgIC8vIGBmaWx0ZXJgIGFyZ3VtZW50IG1heSBzcGVjaWZ5IGVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgYWx0ZXJzIGhvdyBvYmplY3QgYW5kXG5cdFx0ICAvLyBhcnJheSBtZW1iZXJzIGFyZSBzZXJpYWxpemVkLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBudW1iZXJzIHRoYXRcblx0XHQgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxuXHRcdCAgLy8gYXJndW1lbnQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG5cdFx0ICAvLyBsZXZlbCBvZiB0aGUgb3V0cHV0LlxuXHRcdCAgaWYgKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSkge1xuXHRcdFx0Ly8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cblx0XHRcdHZhciBFc2NhcGVzID0ge1xuXHRcdFx0ICA5MjogXCJcXFxcXFxcXFwiLFxuXHRcdFx0ICAzNDogJ1xcXFxcIicsXG5cdFx0XHQgIDg6IFwiXFxcXGJcIixcblx0XHRcdCAgMTI6IFwiXFxcXGZcIixcblx0XHRcdCAgMTA6IFwiXFxcXG5cIixcblx0XHRcdCAgMTM6IFwiXFxcXHJcIixcblx0XHRcdCAgOTogXCJcXFxcdFwiXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcblx0XHRcdC8vIGxlbmd0aCBpcyBhdCBsZWFzdCBlcXVhbCB0byBgd2lkdGhgLiBUaGUgYHdpZHRoYCBtdXN0IGJlIDw9IDYuXG5cdFx0XHR2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG5cdFx0XHR2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XG5cdFx0XHQgIC8vIFRoZSBgfHwgMGAgZXhwcmVzc2lvbiBpcyBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgYSBidWcgaW5cblx0XHRcdCAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG5cdFx0XHQgIHJldHVybiAobGVhZGluZ1plcm9lcyArICh2YWx1ZSB8fCAwKSkuc2xpY2UoLXdpZHRoKTtcblx0XHRcdH07XG5cblx0XHRcdC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuXHRcdFx0Ly8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxuXHRcdFx0Ly8gdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcblx0XHRcdC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG5cdFx0XHR2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xuXHRcdFx0dmFyIHF1b3RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHQgIHZhciByZXN1bHQgPSAnXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgdXNlQ2hhckluZGV4ID0gIWNoYXJJbmRleEJ1Z2d5IHx8IGxlbmd0aCA+IDEwO1xuXHRcdFx0ICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcblx0XHRcdCAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0XHRcdHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xuXHRcdFx0XHQvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxuXHRcdFx0XHQvLyBzaG9ydGhhbmQgZXNjYXBlIHNlcXVlbmNlOyBvdGhlcndpc2UsIGFwcGVuZCB0aGUgY2hhcmFjdGVyIGFzLWlzLlxuXHRcdFx0XHRzd2l0Y2ggKGNoYXJDb2RlKSB7XG5cdFx0XHRcdCAgY2FzZSA4OiBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMzQ6IGNhc2UgOTI6XG5cdFx0XHRcdFx0cmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHQgIGRlZmF1bHQ6XG5cdFx0XHRcdFx0aWYgKGNoYXJDb2RlIDwgMzIpIHtcblx0XHRcdFx0XHQgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcblx0XHRcdFx0XHQgIGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xuXHRcdFx0XHR9XG5cdFx0XHQgIH1cblx0XHRcdCAgcmV0dXJuIHJlc3VsdCArICdcIic7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyBhbiBvYmplY3QuIEltcGxlbWVudHMgdGhlXG5cdFx0XHQvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cblx0XHRcdHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuXHRcdFx0ICB2YXIgdmFsdWUsIGNsYXNzTmFtZSwgeWVhciwgbW9udGgsIGRhdGUsIHRpbWUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIHJlc3VsdHMsIGVsZW1lbnQsIGluZGV4LCBsZW5ndGgsIHByZWZpeCwgcmVzdWx0O1xuXHRcdFx0ICB0cnkge1xuXHRcdFx0XHQvLyBOZWNlc3NhcnkgZm9yIGhvc3Qgb2JqZWN0IHN1cHBvcnQuXG5cdFx0XHRcdHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcblx0XHRcdCAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXHRcdFx0ICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XG5cdFx0XHRcdCAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcblx0XHRcdFx0XHQvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG5cdFx0XHRcdFx0Ly8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG5cdFx0XHRcdFx0Ly8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cblx0XHRcdFx0XHRpZiAoZ2V0RGF5KSB7XG5cdFx0XHRcdFx0ICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG5cdFx0XHRcdFx0ICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcblx0XHRcdFx0XHQgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG5cdFx0XHRcdFx0ICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG5cdFx0XHRcdFx0ICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcblx0XHRcdFx0XHQgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuXHRcdFx0XHRcdCAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcblx0XHRcdFx0XHQgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcblx0XHRcdFx0XHQgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuXHRcdFx0XHRcdCAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3Rcblx0XHRcdFx0XHQgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cblx0XHRcdFx0XHQgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuXHRcdFx0XHRcdCAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuXHRcdFx0XHRcdCAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cblx0XHRcdFx0XHQgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG5cdFx0XHRcdFx0ICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcblx0XHRcdFx0XHQgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xuXHRcdFx0XHRcdCAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XG5cdFx0XHRcdFx0ICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG5cdFx0XHRcdFx0ICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuXHRcdFx0XHRcdCAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xuXHRcdFx0XHRcdCAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcblx0XHRcdFx0XHQgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG5cdFx0XHRcdFx0ICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cblx0XHRcdFx0XHR2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXG5cdFx0XHRcdFx0ICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcblx0XHRcdFx0XHQgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cblx0XHRcdFx0XHQgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxuXHRcdFx0XHRcdCAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG5cdFx0XHRcdFx0ICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cblx0XHRcdFx0XHQgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xuXHRcdFx0XHQgIH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBudWxsO1xuXHRcdFx0XHQgIH1cblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG5cdFx0XHRcdCAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIGFkZHMgbm9uLXN0YW5kYXJkIGB0b0pTT05gIG1ldGhvZHMgdG8gdGhlXG5cdFx0XHRcdCAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuXHRcdFx0XHQgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcblx0XHRcdFx0ICAvLyBkZWZpbmVkIGRpcmVjdGx5IG9uIGFuIGluc3RhbmNlLlxuXHRcdFx0XHQgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcblx0XHRcdFx0fVxuXHRcdFx0ICB9XG5cdFx0XHQgIGlmIChjYWxsYmFjaykge1xuXHRcdFx0XHQvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG5cdFx0XHRcdC8vIGZvciBzZXJpYWxpemF0aW9uLlxuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuXHRcdFx0ICB9XG5cdFx0XHQgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gXCJudWxsXCI7XG5cdFx0XHQgIH1cblx0XHRcdCAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG5cdFx0XHQgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG5cdFx0XHRcdC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXG5cdFx0XHRcdHJldHVybiBcIlwiICsgdmFsdWU7XG5cdFx0XHQgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSB7XG5cdFx0XHRcdC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcblx0XHRcdFx0Ly8gYFwibnVsbFwiYC5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDAgPyBcIlwiICsgdmFsdWUgOiBcIm51bGxcIjtcblx0XHRcdCAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcblx0XHRcdFx0Ly8gU3RyaW5ncyBhcmUgZG91YmxlLXF1b3RlZCBhbmQgZXNjYXBlZC5cblx0XHRcdFx0cmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG5cdFx0XHQgIH1cblx0XHRcdCAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cblx0XHRcdCAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG5cdFx0XHRcdC8vIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZiB1bmlxdWUgbmVzdGVkIG9iamVjdHMuXG5cdFx0XHRcdGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcblx0XHRcdFx0ICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcblx0XHRcdFx0XHQvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuXHRcdFx0XHRcdHRocm93IFR5cGVFcnJvcigpO1xuXHRcdFx0XHQgIH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG5cdFx0XHRcdHN0YWNrLnB1c2godmFsdWUpO1xuXHRcdFx0XHRyZXN1bHRzID0gW107XG5cdFx0XHRcdC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cblx0XHRcdFx0cHJlZml4ID0gaW5kZW50YXRpb247XG5cdFx0XHRcdGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG5cdFx0XHRcdGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuXHRcdFx0XHQgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cblx0XHRcdFx0ICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuXHRcdFx0XHRcdGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcblx0XHRcdFx0XHRyZXN1bHRzLnB1c2goZWxlbWVudCA9PT0gdW5kZWYgPyBcIm51bGxcIiA6IGVsZW1lbnQpO1xuXHRcdFx0XHQgIH1cblx0XHRcdFx0ICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJbXFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIl1cIiA6IChcIltcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIl1cIikpIDogXCJbXVwiO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuXHRcdFx0XHQgIC8vIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMsIG9yIHRoZSBvYmplY3Rcblx0XHRcdFx0ICAvLyBpdHNlbGYuXG5cdFx0XHRcdCAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcblx0XHRcdFx0XHR2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuXHRcdFx0XHRcdGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuXHRcdFx0XHRcdCAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG5cdFx0XHRcdFx0ICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cblx0XHRcdFx0XHQgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcblx0XHRcdFx0XHQgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG5cdFx0XHRcdFx0ICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXG5cdFx0XHRcdFx0ICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuXHRcdFx0XHRcdCAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQgIH0pO1xuXHRcdFx0XHQgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cblx0XHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHQgIH1cblx0XHRcdH07XG5cblx0XHRcdC8vIFB1YmxpYzogYEpTT04uc3RyaW5naWZ5YC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG5cdFx0XHRleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcblx0XHRcdCAgdmFyIHdoaXRlc3BhY2UsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCBjbGFzc05hbWU7XG5cdFx0XHQgIGlmIChvYmplY3RUeXBlc1t0eXBlb2YgZmlsdGVyXSAmJiBmaWx0ZXIpIHtcblx0XHRcdFx0aWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKGZpbHRlcikpID09IGZ1bmN0aW9uQ2xhc3MpIHtcblx0XHRcdFx0ICBjYWxsYmFjayA9IGZpbHRlcjtcblx0XHRcdFx0fSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuXHRcdFx0XHQgIC8vIENvbnZlcnQgdGhlIHByb3BlcnR5IG5hbWVzIGFycmF5IGludG8gYSBtYWtlc2hpZnQgc2V0LlxuXHRcdFx0XHQgIHByb3BlcnRpZXMgPSB7fTtcblx0XHRcdFx0ICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG5cdFx0XHRcdH1cblx0XHRcdCAgfVxuXHRcdFx0ICBpZiAod2lkdGgpIHtcblx0XHRcdFx0aWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcblx0XHRcdFx0ICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG5cdFx0XHRcdCAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cblx0XHRcdFx0ICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG5cdFx0XHRcdFx0Zm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuXHRcdFx0XHQgIH1cblx0XHRcdFx0fSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcblx0XHRcdFx0ICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG5cdFx0XHRcdH1cblx0XHRcdCAgfVxuXHRcdFx0ICAvLyBPcGVyYSA8PSA3LjU0dTIgZGlzY2FyZHMgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZW1wdHkgc3RyaW5nIGtleXNcblx0XHRcdCAgLy8gKGBcIlwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3Rcblx0XHRcdCAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cblx0XHRcdCAgcmV0dXJuIHNlcmlhbGl6ZShcIlwiLCAodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSBzb3VyY2UsIHZhbHVlKSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIFwiXCIsIFtdKTtcblx0XHRcdH07XG5cdFx0ICB9XG5cblx0XHQgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuXHRcdCAgaWYgKCFoYXMoXCJqc29uLXBhcnNlXCIpKSB7XG5cdFx0XHR2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHRcdFx0Ly8gSW50ZXJuYWw6IEEgbWFwIG9mIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciB1bmVzY2FwZWRcblx0XHRcdC8vIGVxdWl2YWxlbnRzLlxuXHRcdFx0dmFyIFVuZXNjYXBlcyA9IHtcblx0XHRcdCAgOTI6IFwiXFxcXFwiLFxuXHRcdFx0ICAzNDogJ1wiJyxcblx0XHRcdCAgNDc6IFwiL1wiLFxuXHRcdFx0ICA5ODogXCJcXGJcIixcblx0XHRcdCAgMTE2OiBcIlxcdFwiLFxuXHRcdFx0ICAxMTA6IFwiXFxuXCIsXG5cdFx0XHQgIDEwMjogXCJcXGZcIixcblx0XHRcdCAgMTE0OiBcIlxcclwiXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBJbnRlcm5hbDogU3RvcmVzIHRoZSBwYXJzZXIgc3RhdGUuXG5cdFx0XHR2YXIgSW5kZXgsIFNvdXJjZTtcblxuXHRcdFx0Ly8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuXHRcdFx0dmFyIGFib3J0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0ICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG5cdFx0XHQgIHRocm93IFN5bnRheEVycm9yKCk7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG5cdFx0XHQvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcblx0XHRcdC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cblx0XHRcdHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHQgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcblx0XHRcdCAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRcdGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuXHRcdFx0XHRzd2l0Y2ggKGNoYXJDb2RlKSB7XG5cdFx0XHRcdCAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuXHRcdFx0XHRcdC8vIFNraXAgd2hpdGVzcGFjZSB0b2tlbnMsIGluY2x1ZGluZyB0YWJzLCBjYXJyaWFnZSByZXR1cm5zLCBsaW5lXG5cdFx0XHRcdFx0Ly8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuXHRcdFx0XHRcdEluZGV4Kys7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdCAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuXHRcdFx0XHRcdC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcblx0XHRcdFx0XHQvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cblx0XHRcdFx0XHR2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuXHRcdFx0XHRcdEluZGV4Kys7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHQgIGNhc2UgMzQ6XG5cdFx0XHRcdFx0Ly8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcblx0XHRcdFx0XHQvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXG5cdFx0XHRcdFx0Ly8gc2VudGluZWwgYEBgIGNoYXJhY3RlciB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gcHVuY3R1YXRvcnMgYW5kXG5cdFx0XHRcdFx0Ly8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG5cdFx0XHRcdFx0Zm9yICh2YWx1ZSA9IFwiQFwiLCBJbmRleCsrOyBJbmRleCA8IGxlbmd0aDspIHtcblx0XHRcdFx0XHQgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuXHRcdFx0XHRcdCAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcblx0XHRcdFx0XHRcdC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcblx0XHRcdFx0XHRcdC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cblx0XHRcdFx0XHRcdGFib3J0KCk7XG5cdFx0XHRcdFx0ICB9IGVsc2UgaWYgKGNoYXJDb2RlID09IDkyKSB7XG5cdFx0XHRcdFx0XHQvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG5cdFx0XHRcdFx0XHQvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcblx0XHRcdFx0XHRcdC8vIGVzY2FwZSBzZXF1ZW5jZS5cblx0XHRcdFx0XHRcdGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG5cdFx0XHRcdFx0XHRzd2l0Y2ggKGNoYXJDb2RlKSB7XG5cdFx0XHRcdFx0XHQgIGNhc2UgOTI6IGNhc2UgMzQ6IGNhc2UgNDc6IGNhc2UgOTg6IGNhc2UgMTE2OiBjYXNlIDExMDogY2FzZSAxMDI6IGNhc2UgMTE0OlxuXHRcdFx0XHRcdFx0XHQvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG5cdFx0XHRcdFx0XHRcdHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XG5cdFx0XHRcdFx0XHRcdEluZGV4Kys7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ICBjYXNlIDExNzpcblx0XHRcdFx0XHRcdFx0Ly8gYFxcdWAgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuXHRcdFx0XHRcdFx0XHQvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuXHRcdFx0XHRcdFx0XHQvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG5cdFx0XHRcdFx0XHRcdGJlZ2luID0gKytJbmRleDtcblx0XHRcdFx0XHRcdFx0Zm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuXHRcdFx0XHRcdFx0XHQgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuXHRcdFx0XHRcdFx0XHQgIC8vIEEgdmFsaWQgc2VxdWVuY2UgY29tcHJpc2VzIGZvdXIgaGV4ZGlnaXRzIChjYXNlLVxuXHRcdFx0XHRcdFx0XHQgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG5cdFx0XHRcdFx0XHRcdCAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG5cdFx0XHRcdFx0XHRcdFx0YWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0ICB9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Ly8gUmV2aXZlIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cblx0XHRcdFx0XHRcdFx0dmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHQgIGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxuXHRcdFx0XHRcdFx0XHRhYm9ydCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCAgfSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChjaGFyQ29kZSA9PSAzNCkge1xuXHRcdFx0XHRcdFx0ICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxuXHRcdFx0XHRcdFx0ICAvLyBzdHJpbmcuXG5cdFx0XHRcdFx0XHQgIGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG5cdFx0XHRcdFx0XHRiZWdpbiA9IEluZGV4O1xuXHRcdFx0XHRcdFx0Ly8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cblx0XHRcdFx0XHRcdHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xuXHRcdFx0XHRcdFx0ICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXG5cdFx0XHRcdFx0XHR2YWx1ZSArPSBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcblx0XHRcdFx0XHQgIH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSAzNCkge1xuXHRcdFx0XHRcdCAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG5cdFx0XHRcdFx0ICBJbmRleCsrO1xuXHRcdFx0XHRcdCAgcmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxuXHRcdFx0XHRcdGFib3J0KCk7XG5cdFx0XHRcdCAgZGVmYXVsdDpcblx0XHRcdFx0XHQvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cblx0XHRcdFx0XHRiZWdpbiA9IEluZGV4O1xuXHRcdFx0XHRcdC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cblx0XHRcdFx0XHRpZiAoY2hhckNvZGUgPT0gNDUpIHtcblx0XHRcdFx0XHQgIGlzU2lnbmVkID0gdHJ1ZTtcblx0XHRcdFx0XHQgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG5cdFx0XHRcdFx0aWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG5cdFx0XHRcdFx0ICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXG5cdFx0XHRcdFx0ICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcblx0XHRcdFx0XHRcdC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cblx0XHRcdFx0XHRcdGFib3J0KCk7XG5cdFx0XHRcdFx0ICB9XG5cdFx0XHRcdFx0ICBpc1NpZ25lZCA9IGZhbHNlO1xuXHRcdFx0XHRcdCAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuXHRcdFx0XHRcdCAgZm9yICg7IEluZGV4IDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspO1xuXHRcdFx0XHRcdCAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXG5cdFx0XHRcdFx0ICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuXHRcdFx0XHRcdCAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSA0Nikge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24gPSArK0luZGV4O1xuXHRcdFx0XHRcdFx0Ly8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxuXHRcdFx0XHRcdFx0Zm9yICg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuXHRcdFx0XHRcdFx0aWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG5cdFx0XHRcdFx0XHQgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cblx0XHRcdFx0XHRcdCAgYWJvcnQoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdEluZGV4ID0gcG9zaXRpb247XG5cdFx0XHRcdFx0ICB9XG5cdFx0XHRcdFx0ICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXG5cdFx0XHRcdFx0ICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxuXHRcdFx0XHRcdCAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG5cdFx0XHRcdFx0ICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XG5cdFx0XHRcdFx0XHRjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuXHRcdFx0XHRcdFx0Ly8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuXHRcdFx0XHRcdFx0Ly8gc3BlY2lmaWVkLlxuXHRcdFx0XHRcdFx0aWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG5cdFx0XHRcdFx0XHQgIEluZGV4Kys7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuXHRcdFx0XHRcdFx0Zm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcblx0XHRcdFx0XHRcdGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuXHRcdFx0XHRcdFx0ICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuXHRcdFx0XHRcdFx0ICBhYm9ydCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0SW5kZXggPSBwb3NpdGlvbjtcblx0XHRcdFx0XHQgIH1cblx0XHRcdFx0XHQgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG5cdFx0XHRcdFx0ICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxuXHRcdFx0XHRcdGlmIChpc1NpZ25lZCkge1xuXHRcdFx0XHRcdCAgYWJvcnQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuXHRcdFx0XHRcdGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJ0cnVlXCIpIHtcblx0XHRcdFx0XHQgIEluZGV4ICs9IDQ7XG5cdFx0XHRcdFx0ICByZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcImZhbHNlXCIpIHtcblx0XHRcdFx0XHQgIEluZGV4ICs9IDU7XG5cdFx0XHRcdFx0ICByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcblx0XHRcdFx0XHQgIEluZGV4ICs9IDQ7XG5cdFx0XHRcdFx0ICByZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gVW5yZWNvZ25pemVkIHRva2VuLlxuXHRcdFx0XHRcdGFib3J0KCk7XG5cdFx0XHRcdH1cblx0XHRcdCAgfVxuXHRcdFx0ICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG5cdFx0XHQgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuXHRcdFx0ICByZXR1cm4gXCIkXCI7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBJbnRlcm5hbDogUGFyc2VzIGEgSlNPTiBgdmFsdWVgIHRva2VuLlxuXHRcdFx0dmFyIGdldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0ICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcblx0XHRcdCAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG5cdFx0XHRcdC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuXHRcdFx0XHRhYm9ydCgpO1xuXHRcdFx0ICB9XG5cdFx0XHQgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG5cdFx0XHRcdCAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxuXHRcdFx0XHQgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxuXHRcdFx0XHRpZiAodmFsdWUgPT0gXCJbXCIpIHtcblx0XHRcdFx0ICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cblx0XHRcdFx0ICByZXN1bHRzID0gW107XG5cdFx0XHRcdCAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGxleCgpO1xuXHRcdFx0XHRcdC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PSBcIl1cIikge1xuXHRcdFx0XHRcdCAgYnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuXHRcdFx0XHRcdC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcblx0XHRcdFx0XHQvLyBuZXh0LlxuXHRcdFx0XHRcdGlmIChoYXNNZW1iZXJzKSB7XG5cdFx0XHRcdFx0ICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gbGV4KCk7XG5cdFx0XHRcdFx0XHRpZiAodmFsdWUgPT0gXCJdXCIpIHtcblx0XHRcdFx0XHRcdCAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gYXJyYXkgbGl0ZXJhbC5cblx0XHRcdFx0XHRcdCAgYWJvcnQoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQgIH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cblx0XHRcdFx0XHRcdGFib3J0KCk7XG5cdFx0XHRcdFx0ICB9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIEVsaXNpb25zIGFuZCBsZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZC5cblx0XHRcdFx0XHRpZiAodmFsdWUgPT0gXCIsXCIpIHtcblx0XHRcdFx0XHQgIGFib3J0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcblx0XHRcdFx0ICB9XG5cdFx0XHRcdCAgcmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcblx0XHRcdFx0ICAvLyBQYXJzZXMgYSBKU09OIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgb2JqZWN0LlxuXHRcdFx0XHQgIHJlc3VsdHMgPSB7fTtcblx0XHRcdFx0ICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuXHRcdFx0XHRcdHZhbHVlID0gbGV4KCk7XG5cdFx0XHRcdFx0Ly8gQSBjbG9zaW5nIGN1cmx5IGJyYWNlIG1hcmtzIHRoZSBlbmQgb2YgdGhlIG9iamVjdCBsaXRlcmFsLlxuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PSBcIn1cIikge1xuXHRcdFx0XHRcdCAgYnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuXHRcdFx0XHRcdC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cblx0XHRcdFx0XHRpZiAoaGFzTWVtYmVycykge1xuXHRcdFx0XHRcdCAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGxleCgpO1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlID09IFwifVwiKSB7XG5cdFx0XHRcdFx0XHQgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuXHRcdFx0XHRcdFx0ICBhYm9ydCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCAgfSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxuXHRcdFx0XHRcdFx0YWJvcnQoKTtcblx0XHRcdFx0XHQgIH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG5cdFx0XHRcdFx0Ly8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG5cdFx0XHRcdFx0Ly8gbmFtZSBhbmQgdmFsdWUuXG5cdFx0XHRcdFx0aWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuXHRcdFx0XHRcdCAgYWJvcnQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuXHRcdFx0XHQgIH1cblx0XHRcdFx0ICByZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuXHRcdFx0XHRhYm9ydCgpO1xuXHRcdFx0ICB9XG5cdFx0XHQgIHJldHVybiB2YWx1ZTtcblx0XHRcdH07XG5cblx0XHRcdC8vIEludGVybmFsOiBVcGRhdGVzIGEgdHJhdmVyc2VkIG9iamVjdCBtZW1iZXIuXG5cdFx0XHR2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG5cdFx0XHQgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG5cdFx0XHQgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xuXHRcdFx0XHRkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcblx0XHRcdCAgfSBlbHNlIHtcblx0XHRcdFx0c291cmNlW3Byb3BlcnR5XSA9IGVsZW1lbnQ7XG5cdFx0XHQgIH1cblx0XHRcdH07XG5cblx0XHRcdC8vIEludGVybmFsOiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYSBwYXJzZWQgSlNPTiBvYmplY3QsIGludm9raW5nIHRoZVxuXHRcdFx0Ly8gYGNhbGxiYWNrYCBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZS4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcblx0XHRcdC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG5cdFx0XHR2YXIgd2FsayA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuXHRcdFx0ICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLCBsZW5ndGg7XG5cdFx0XHQgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuXHRcdFx0XHQvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XG5cdFx0XHRcdC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuXHRcdFx0XHQvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXG5cdFx0XHRcdGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XG5cdFx0XHRcdCAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuXHRcdFx0XHRcdHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XG5cdFx0XHRcdCAgfVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuXHRcdFx0XHRcdHVwZGF0ZSh2YWx1ZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcblx0XHRcdFx0ICB9KTtcblx0XHRcdFx0fVxuXHRcdFx0ICB9XG5cdFx0XHQgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcblx0XHRcdH07XG5cblx0XHRcdC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cblx0XHRcdGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuXHRcdFx0ICB2YXIgcmVzdWx0LCB2YWx1ZTtcblx0XHRcdCAgSW5kZXggPSAwO1xuXHRcdFx0ICBTb3VyY2UgPSBcIlwiICsgc291cmNlO1xuXHRcdFx0ICByZXN1bHQgPSBnZXQobGV4KCkpO1xuXHRcdFx0ICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cblx0XHRcdCAgaWYgKGxleCgpICE9IFwiJFwiKSB7XG5cdFx0XHRcdGFib3J0KCk7XG5cdFx0XHQgIH1cblx0XHRcdCAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cblx0XHRcdCAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuXHRcdFx0ICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcblx0XHRcdH07XG5cdFx0ICB9XG5cdFx0fVxuXG5cdFx0ZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcblx0XHRyZXR1cm4gZXhwb3J0cztcblx0ICB9XG5cblx0ICBpZiAoZnJlZUV4cG9ydHMgJiYgIWlzTG9hZGVyKSB7XG5cdFx0Ly8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXG5cdFx0cnVuSW5Db250ZXh0KHJvb3QsIGZyZWVFeHBvcnRzKTtcblx0ICB9IGVsc2Uge1xuXHRcdC8vIEV4cG9ydCBmb3Igd2ViIGJyb3dzZXJzIGFuZCBKYXZhU2NyaXB0IGVuZ2luZXMuXG5cdFx0dmFyIG5hdGl2ZUpTT04gPSByb290LkpTT04sXG5cdFx0XHRwcmV2aW91c0pTT04gPSByb290W1wiSlNPTjNcIl0sXG5cdFx0XHRpc1Jlc3RvcmVkID0gZmFsc2U7XG5cblx0XHR2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgKHJvb3RbXCJKU09OM1wiXSA9IHtcblx0XHQgIC8vIFB1YmxpYzogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBnbG9iYWwgYEpTT05gIG9iamVjdCBhbmRcblx0XHQgIC8vIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBKU09OM2Agb2JqZWN0LlxuXHRcdCAgXCJub0NvbmZsaWN0XCI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICghaXNSZXN0b3JlZCkge1xuXHRcdFx0ICBpc1Jlc3RvcmVkID0gdHJ1ZTtcblx0XHRcdCAgcm9vdC5KU09OID0gbmF0aXZlSlNPTjtcblx0XHRcdCAgcm9vdFtcIkpTT04zXCJdID0gcHJldmlvdXNKU09OO1xuXHRcdFx0ICBuYXRpdmVKU09OID0gcHJldmlvdXNKU09OID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBKU09OMztcblx0XHQgIH1cblx0XHR9KSk7XG5cblx0XHRyb290LkpTT04gPSB7XG5cdFx0ICBcInBhcnNlXCI6IEpTT04zLnBhcnNlLFxuXHRcdCAgXCJzdHJpbmdpZnlcIjogSlNPTjMuc3RyaW5naWZ5XG5cdFx0fTtcblx0ICB9XG5cblx0ICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cblx0ICBpZiAoaXNMb2FkZXIpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24gKCkge1xuXHRcdCAgcmV0dXJuIEpTT04zO1xuXHRcdH0pO1xuXHQgIH1cblx0fSkuY2FsbCh0aGlzKTtcblxuXHR9KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcblx0fSx7fV0sNTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHRtb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblxuXHRmdW5jdGlvbiB0b0FycmF5KGxpc3QsIGluZGV4KSB7XG5cdFx0dmFyIGFycmF5ID0gW11cblxuXHRcdGluZGV4ID0gaW5kZXggfHwgMFxuXG5cdFx0Zm9yICh2YXIgaSA9IGluZGV4IHx8IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJheVxuXHR9XG5cblx0fSx7fV19LHt9LFszMV0pKDMxKVxuXHR9KTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=